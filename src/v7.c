/*
 * Copyright (c) 2013-2014 Cesanta Software Limited
 * All rights reserved
 *
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http: *www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <http://cesanta.com/products.html>.
 */

/*
 * === C/C++ API
 *
 * V7 uses 64-bit `v7_val_t` type to store JavaScript values. There are
 * several families of functions V7 provides:
 *
 * - `v7_exec_*()` execute a piece of JavaScript code, put result in `v7_val_t`
 * - `v7_create_*()` convert C/C++ values into JavaScript `v7_val_t` values
 * - `v7_to_*()` convert JavaScript `v7_val_t` values into C/C++ values
 * - `v7_is_*()` test whether JavaScript `v7_val_t` value is of given type
 * - misc functions that throw exceptions, operate on arrays & objects,
 *   call JS functions, etc
 *
 * NOTE: V7 instance is single threaded. It does not protect
 * it's data structures by mutexes. If V7 instance is shared between several
 * threads, a care should be taken to serialize accesses.
 */

#ifndef V7_HEADER_INCLUDED
#define V7_HEADER_INCLUDED

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
#endif

#include <stddef.h> /* For size_t */
#include <stdio.h>  /* For FILE */

#define V7_VERSION "1.0"

#if (defined(_WIN32) && !defined(__MINGW32__) && !defined(__MINGW64__)) || \
    (defined(_MSC_VER) && _MSC_VER <= 1200)
#define V7_WINDOWS
#endif

#ifdef V7_WINDOWS
typedef unsigned __int64 uint64_t;
#else
#include <inttypes.h>
#endif
typedef uint64_t v7_val_t;

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

struct v7; /* Opaque structure. V7 engine handler. */
typedef v7_val_t (*v7_cfunction_t)(struct v7 *, v7_val_t, v7_val_t);

/* Create V7 instance */
struct v7 *v7_create(void);

struct v7_create_opts {
  size_t object_arena_size;
  size_t function_arena_size;
  size_t property_arena_size;
#ifdef V7_STACK_SIZE
  void *c_stack_base;
#endif
};
struct v7 *v7_create_opt(struct v7_create_opts);

/* Destroy V7 instance */
void v7_destroy(struct v7 *);

enum v7_err { V7_OK, V7_SYNTAX_ERROR, V7_EXEC_EXCEPTION, V7_STACK_OVERFLOW };

/*
 * Execute JavaScript `js_code`, store result in `result` variable.
 * Return:
 *
 *  - V7_OK on success. `result` contains the result of execution.
 *  - V7_SYNTAX_ERROR if `js_code` in not a valid code. `result` is undefined.
 *  - V7_EXEC_EXCEPTION if `js_code` threw an exception. `result` stores
 *    an exception object.
 */
enum v7_err v7_exec(struct v7 *, v7_val_t *result, const char *js_code);

/*
 * Same as `v7_exec()`, but loads source code from `path` file.
 */
enum v7_err v7_exec_file(struct v7 *, v7_val_t *result, const char *path);

/*
 * Same as `v7_exec()`, but passes `this_obj` as `this` to the execution
 * context.
 */
enum v7_err v7_exec_with(struct v7 *, v7_val_t *result, const char *js_code,
                         v7_val_t this_obj);

/*
 * Compile JavaScript code `js_code` into the byte code and write generated
 * byte code into opened file stream `fp`. If `generate_binary_output` is 0,
 * then generated byte code is in human-readable text format. Otherwise, it is
 * in the binary format, suitable for execution by V7 instance.
 * NOTE: `fp` must be a valid, opened, writable file stream.
 */
void v7_compile(const char *js_code, int generate_binary_output, FILE *fp);

/*
 * Perform garbage collection.
 * Pass true to full in order to reclaim unused heap back to the OS.
 */
void v7_gc(struct v7 *, int full);

/* Create an empty object */
v7_val_t v7_create_object(struct v7 *v7);

/* Create an empty array object */
v7_val_t v7_create_array(struct v7 *v7);

/*
 * Create function object. `func` is a C callback, `nargs` is a number of
 * arguments
 */
v7_val_t v7_create_function(struct v7 *, v7_cfunction_t func, int nargs);

/* Create JavaScript value that holds C/C++ callback pointer. */
v7_val_t v7_create_cfunction(v7_cfunction_t func);

/* Make f a JS constructor function for objects with prototype in proto. */
v7_val_t v7_create_constructor(struct v7 *v7, v7_val_t proto, v7_cfunction_t f,
                               int num_args);

/* Create numeric primitive value */
v7_val_t v7_create_number(double num);

/* Create boolean primitive value (either `true` or `false`) */
v7_val_t v7_create_boolean(int is_true);

/* Create `null` primitive value */
v7_val_t v7_create_null(void);

/* Create `undefined` primitive value */
v7_val_t v7_create_undefined(void);

/*
 * Create string primitive value.
 * `str` must point to the utf8 string of length `len`.
 */
v7_val_t v7_create_string(struct v7 *, const char *str, size_t len, int copy);

/*
 * Create RegExp object.
 * `regex`, `regex_len` specify a pattern, `flags` and `flags_len` specify
 * flags. Both utf8 encoded. For example, `regex` is `(.+)`, `flags` is `gi`.
 */
v7_val_t v7_create_regexp(struct v7 *, const char *regex, size_t regex_len,
                          const char *flags, size_t flags_len);

/*
 * Create JavaScript value that holds C/C++ `void *` pointer.
 */
v7_val_t v7_create_foreign(void *ptr);

/* Return true if given value is a JavaScript object */
int v7_is_object(v7_val_t);

/* Return true if given value is a JavaScript function object */
int v7_is_function(v7_val_t);

/* Return true if given value is a primitive string value */
int v7_is_string(v7_val_t);

/* Return true if given value is a primitive boolean value */
int v7_is_boolean(v7_val_t);

/* Return true if given value is a primitive number value */
int v7_is_number(v7_val_t);

/* Return true if given value is a primitive `null` value */
int v7_is_null(v7_val_t);

/* Return true if given value is a primitive `undefined` value */
int v7_is_undefined(v7_val_t);

/* Return true if given value is a JavaScript RegExp object*/
int v7_is_regexp(struct v7 *, v7_val_t);

/* Return true if given value holds C callback */
int v7_is_cfunction(v7_val_t);

/* Return true if given value holds `void *` pointer */
int v7_is_foreign(v7_val_t);

/* Return true if given value is an array object */
int v7_is_array(struct v7 *, v7_val_t);

/* Return `void *` pointer stored in `v7_val_t` */
void *v7_to_foreign(v7_val_t);

/* Return boolean stored in `v7_val_t`: 0 for `false`, non-0 for `true` */
int v7_to_boolean(v7_val_t);

/* Return `double` value stored in `v7_val_t` */
double v7_to_number(v7_val_t);

/* Return `v7_cfunction_t` callback pointer stored in `v7_val_t` */
v7_cfunction_t v7_to_cfunction(v7_val_t);

/*
 * Return pointer to string stored in `v7_val_t`.
 * String length returned in `string_len`. Returned string pointer is
 * guaranteed to be 0-terminated, suitable for standard C library string API.
 *
 * CAUTION: creating new JavaScript object, array, or string may kick in a
 * garbage collector, which in turn may relocate string data and invalidate
 * pointer returned by `v7_to_string()`.
 */
const char *v7_to_string(struct v7 *, v7_val_t *value, size_t *string_len);

/* Return root level (`global`) object of the given V7 instance. */
v7_val_t v7_get_global_object(struct v7 *);

/*
 * Lookup property `name`, `len` in object `obj`. If `obj` holds no such
 * property, an `undefined` value is returned.
 */
v7_val_t v7_get(struct v7 *v7, v7_val_t obj, const char *name, size_t len);

/*
 * Generate JSON representation of the JavaScript value `val` into a buffer
 * `buf`, `buf_len`. If `buf_len` is too small to hold generated JSON string,
 * `v7_to_json()` allocates required memory. In that case, it is caller's
 * responsibility to free the allocated buffer. Generated JSON string is
 * guaranteed to be 0-terminated.
 *
 * Example code:
 *
 *     char buf[100], *p;
 *     p = v7_to_json(v7, obj, buf, sizeof(buf));
 *     printf("JSON string: [%s]\n", p);
 *     if (p != buf) {
 *       free(p);
 *     }
 */
char *v7_to_json(struct v7 *, v7_val_t val, char *buf, size_t buf_len);

/* print a value to stdout */
void v7_print(struct v7 *, v7_val_t val);

/* print a value into a file */
void v7_fprint(FILE *f, struct v7 *v7, v7_val_t v);

/* print a value to stdout followed by a newline */
void v7_println(struct v7 *, v7_val_t val);

/* print a value into a file followed by a newline */
void v7_fprintln(FILE *f, struct v7 *v7, v7_val_t v);

/* Return true if given value is `true`, as in JavaScript `if (v)` statement */
int v7_is_true(struct v7 *v7, v7_val_t v);

/*
 * Call function `func` with arguments `args`, using `this_obj` as `this`.
 * `args` could be either undefined value, or be an array with arguments.
 */
v7_val_t v7_apply(struct v7 *, v7_val_t func, v7_val_t this_obj, v7_val_t args);

/* Throw an exception (Error object) with given formatted message. */
void v7_throw(struct v7 *, const char *msg_fmt, ...);

/* Throw an already existing object. */
void v7_throw_value(struct v7 *, v7_val_t v);

#define V7_PROPERTY_READ_ONLY 1
#define V7_PROPERTY_DONT_ENUM 2
#define V7_PROPERTY_DONT_DELETE 4
#define V7_PROPERTY_HIDDEN 8
#define V7_PROPERTY_GETTER 16
#define V7_PROPERTY_SETTER 32

/*
 * Set object property. `name`, `name_len` specify property name, `attrs`
 * specify property attributes, `val` is a property value. Return non-zero
 * on success, 0 on error (e.g. out of memory).
 */
int v7_set(struct v7 *v7, v7_val_t obj, const char *name, size_t name_len,
           unsigned int attrs, v7_val_t val);

/*
 * A helper function to define object's method backed by a C function `func`.
 * Return value is the same as for `v7_set()`.
 */
int v7_set_method(struct v7 *, v7_val_t obj, const char *name,
                  v7_cfunction_t func);

/* Return array length */
unsigned long v7_array_length(struct v7 *v7, v7_val_t arr);

/* Insert value `v` in array `arr` at index `index`. */
int v7_array_set(struct v7 *v7, v7_val_t arr, unsigned long index, v7_val_t v);

/* Insert value `v` in array `arr` at the end of the array. */
int v7_array_push(struct v7 *, v7_val_t arr, v7_val_t v);

/*
 * Return array member at index `index`. If `index` is out of bounds, undefined
 * is returned.
 */
v7_val_t v7_array_get(struct v7 *, v7_val_t arr, unsigned long index);

/* Set object's prototype. Return old prototype or undefined on error. */
v7_val_t v7_set_proto(v7_val_t obj, v7_val_t proto);

/* Returns last parser error message. */
const char *v7_get_parser_error(struct v7 *v7);

enum v7_heap_stat_what {
  V7_HEAP_STAT_HEAP_SIZE,
  V7_HEAP_STAT_HEAP_USED,
  V7_HEAP_STAT_STRING_HEAP_RESERVED,
  V7_HEAP_STAT_STRING_HEAP_USED,
  V7_HEAP_STAT_OBJ_HEAP_MAX,
  V7_HEAP_STAT_OBJ_HEAP_FREE,
  V7_HEAP_STAT_OBJ_HEAP_CELL_SIZE,
  V7_HEAP_STAT_FUNC_HEAP_MAX,
  V7_HEAP_STAT_FUNC_HEAP_FREE,
  V7_HEAP_STAT_FUNC_HEAP_CELL_SIZE,
  V7_HEAP_STAT_PROP_HEAP_MAX,
  V7_HEAP_STAT_PROP_HEAP_FREE,
  V7_HEAP_STAT_PROP_HEAP_CELL_SIZE,
  V7_HEAP_STAT_FUNC_AST_SIZE,
  V7_HEAP_STAT_FUNC_OWNED,
  V7_HEAP_STAT_FUNC_OWNED_MAX
};

#if V7_ENABLE__Memory__stats
/* Returns a given heap statistics */
int v7_heap_stat(struct v7 *v7, enum v7_heap_stat_what what);
#endif

/*
 * Set an optional C stack limit.
 *
 * It sets a flag that will cause the interpreter
 * to throw an InterruptedError.
 * It's safe to call it from signal handlers and ISRs
 * on single threaded environments.
 */
void v7_interrupt(struct v7 *v7);

/*
 * Tells the GC about a JS value variable/field owned
 * by C code.
 * *
 * User C code should own v7_val_t variables
 * if the value's lifetime crosses any invocation
 * to the v7 runtime that creates new objects or new
 * properties and thus can potentially trigger GC.
 *
 * The registration of the variable prevents the GC from mistakenly treat
 * the object as garbage. The GC might be triggered potentially
 * allows the GC to update pointers
 *
 * User code should also explicitly disown the variables with v7_disown once
 * it goes out of scope or the structure containing the v7_val_t field is freed.
 *
 * Example:
 *
 *  ```
 *    struct v7_val cb;
 *    v7_own(v7, &cb);
 *    cb = v7_array_get(v7, args, 0);
 *    // do something with cb
 *    v7_disown(v7, &cb);
 *  ```
 */
void v7_own(struct v7 *v7, v7_val_t *v);

/*
 * Returns 1 if value is found, 0 otherwise
 */
int v7_disown(struct v7 *v7, v7_val_t *v);

int v7_main(int argc, char *argv[], void (*init_func)(struct v7 *));

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* V7_HEADER_INCLUDED */
#ifndef V7_FEATURES_H_INCLUDED
#define V7_FEATURES_H_INCLUDED

#define V7_BUILD_PROFILE_MINIMAL 1
#define V7_BUILD_PROFILE_MEDIUM 2
#define V7_BUILD_PROFILE_FULL 3

#ifndef V7_BUILD_PROFILE
#define V7_BUILD_PROFILE V7_BUILD_PROFILE_FULL
#endif

/* Only one will actually be used based on V7_BUILD_PROFILE. */

#endif /* V7_FEATURES_H_INCLUDED */
#if V7_BUILD_PROFILE == V7_BUILD_PROFILE_FULL
/*
 * DO NOT EDIT.
 * This file is generated by scripts/gen-features-full.pl.
 */

#define V7_ENABLE__Array__reduce 1
#define V7_ENABLE__Date 1
#define V7_ENABLE__Date__UTC 1
#define V7_ENABLE__Date__getters 1
#define V7_ENABLE__Date__now 1
#define V7_ENABLE__Date__parse 1
#define V7_ENABLE__Date__setters 1
#define V7_ENABLE__Date__toJSON 1
#define V7_ENABLE__Date__toLocaleString 1
#define V7_ENABLE__Date__toString 1
#define V7_ENABLE__Function__call 1
#define V7_ENABLE__Math 1
#define V7_ENABLE__Math__abs 1
#define V7_ENABLE__Math__acos 1
#define V7_ENABLE__Math__asin 1
#define V7_ENABLE__Math__atan 1
#define V7_ENABLE__Math__atan2 1
#define V7_ENABLE__Math__ceil 1
#define V7_ENABLE__Math__constants 1
#define V7_ENABLE__Math__cos 1
#define V7_ENABLE__Math__exp 1
#define V7_ENABLE__Math__floor 1
#define V7_ENABLE__Math__log 1
#define V7_ENABLE__Math__max 1
#define V7_ENABLE__Math__min 1
#define V7_ENABLE__Math__pow 1
#define V7_ENABLE__Math__random 1
#define V7_ENABLE__Math__round 1
#define V7_ENABLE__Math__sin 1
#define V7_ENABLE__Math__sqrt 1
#define V7_ENABLE__Math__tan 1
#define V7_ENABLE__Memory__stats 1
#define V7_ENABLE__NUMBER__NEGATIVE_INFINITY 1
#define V7_ENABLE__NUMBER__POSITIVE_INFINITY 1
#define V7_ENABLE__Object__create 1
#define V7_ENABLE__Object__defineProperties 1
#define V7_ENABLE__Object__defineProperty 1
#define V7_ENABLE__Object__getOwnPropertyDescriptor 1
#define V7_ENABLE__Object__getOwnPropertyNames 1
#define V7_ENABLE__Object__getPrototypeOf 1
#define V7_ENABLE__Object__hasOwnProperty 1
#define V7_ENABLE__Object__isExtensible 1
#define V7_ENABLE__Object__isPrototypeOf 1
#define V7_ENABLE__Object__keys 1
#define V7_ENABLE__Object__preventExtensions 1
#define V7_ENABLE__Object__propertyIsEnumerable 1
#define V7_ENABLE__RegExp 1
#define V7_ENABLE__String__localeCompare 1
#define V7_ENABLE__String__localeLowerCase 1
#define V7_ENABLE__String__localeUpperCase 1
#define V7_ENABLE__UTF 1

#endif /* V7_BUILD_PROFILE == V7_BUILD_PROFILE_FULL */
#if V7_BUILD_PROFILE == V7_BUILD_PROFILE_MEDIUM

#define V7_ENABLE__Date 1
#define V7_ENABLE__Date__now 1
#define V7_ENABLE__Date__UTC 1
#define V7_ENABLE__Math 1
#define V7_ENABLE__Math__atan2 1
#define V7_ENABLE__RegExp 1
#define V7_ENABLE__UTF 1

#endif /* V7_BUILD_PROFILE == V7_BUILD_PROFILE_MEDIUM */
#if V7_BUILD_PROFILE == V7_BUILD_PROFILE_MINIMAL

/* This space is intentionally left blank. */

#endif /* V7_BUILD_PROFILE == V7_BUILD_PROFILE_MINIMAL */
/*
 * Copyright (c) 2013-2014 Cesanta Software Limited
 * All rights reserved
 *
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <http://cesanta.com/products.html>.
 */

#ifdef V7_EXPOSE_PRIVATE
#define V7_PRIVATE
#define V7_EXTERN extern
#else
#define V7_PRIVATE static
#define V7_EXTERN static
#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef V7_TOKENIZER_H_INCLUDED
#define V7_TOKENIZER_H_INCLUDED


enum v7_tok {
  TOK_END_OF_INPUT,
  TOK_NUMBER,
  TOK_STRING_LITERAL,
  TOK_REGEX_LITERAL,
  TOK_IDENTIFIER,

  /* Punctuators */
  TOK_OPEN_CURLY,
  TOK_CLOSE_CURLY,
  TOK_OPEN_PAREN,
  TOK_CLOSE_PAREN,
  TOK_COMMA,
  TOK_OPEN_BRACKET,
  TOK_CLOSE_BRACKET,
  TOK_DOT,
  TOK_COLON,
  TOK_SEMICOLON,

  /* Equality ops, in this order */
  TOK_EQ,
  TOK_EQ_EQ,
  TOK_NE,
  TOK_NE_NE,

  /* Assigns */
  TOK_ASSIGN,
  TOK_REM_ASSIGN,
  TOK_MUL_ASSIGN,
  TOK_DIV_ASSIGN,
  TOK_XOR_ASSIGN,
  TOK_PLUS_ASSIGN,
  TOK_MINUS_ASSIGN,
  TOK_OR_ASSIGN,
  TOK_AND_ASSIGN,
  TOK_LSHIFT_ASSIGN,
  TOK_RSHIFT_ASSIGN,
  TOK_URSHIFT_ASSIGN,
  TOK_AND,
  TOK_LOGICAL_OR,
  TOK_PLUS,
  TOK_MINUS,
  TOK_PLUS_PLUS,
  TOK_MINUS_MINUS,
  TOK_LOGICAL_AND,
  TOK_OR,
  TOK_QUESTION,
  TOK_TILDA,
  TOK_REM,
  TOK_MUL,
  TOK_DIV,
  TOK_XOR,

  /* Relational ops, must go in this order */
  TOK_LE,
  TOK_LT,
  TOK_GE,
  TOK_GT,
  TOK_LSHIFT,
  TOK_RSHIFT,
  TOK_URSHIFT,
  TOK_NOT,

  /* Keywords. must be in the same order as tokenizer.c::s_keywords array */
  TOK_BREAK,
  TOK_CASE,
  TOK_CATCH,
  TOK_CONTINUE,
  TOK_DEBUGGER,
  TOK_DEFAULT,
  TOK_DELETE,
  TOK_DO,
  TOK_ELSE,
  TOK_FALSE,
  TOK_FINALLY,
  TOK_FOR,
  TOK_FUNCTION,
  TOK_IF,
  TOK_IN,
  TOK_INSTANCEOF,
  TOK_NEW,
  TOK_NULL,
  TOK_RETURN,
  TOK_SWITCH,
  TOK_THIS,
  TOK_THROW,
  TOK_TRUE,
  TOK_TRY,
  TOK_TYPEOF,
  TOK_VAR,
  TOK_VOID,
  TOK_WHILE,
  TOK_WITH,

  /* TODO(lsm): process these reserved words too */
  TOK_CLASS,
  TOK_ENUM,
  TOK_EXTENDS,
  TOK_SUPER,
  TOK_CONST,
  TOK_EXPORT,
  TOK_IMPORT,
  TOK_IMPLEMENTS,
  TOK_LET,
  TOK_PRIVATE,
  TOK_PUBLIC,
  TOK_INTERFACE,
  TOK_PACKAGE,
  TOK_PROTECTED,
  TOK_STATIC,
  TOK_YIELD,

  NUM_TOKENS
};

#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

V7_PRIVATE int skip_to_next_tok(const char **ptr);
V7_PRIVATE enum v7_tok get_tok(const char **s, double *n, enum v7_tok prev_tok);
V7_PRIVATE int is_reserved_word_token(enum v7_tok tok);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* V7_TOKENIZER_H_INCLUDED */
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === Memory Buffers
 *
 * Mbufs are mutable/growing memory buffers, like C++ strings.
 * Mbuf can append data to the end of a buffer, or insert data into arbitrary
 * position in the middle of a buffer. The buffer grows automatically when
 * needed.
 */

#ifndef MBUF_H_INCLUDED
#define MBUF_H_INCLUDED

#if defined(__cplusplus)
extern "C" {
#endif

#include <stdlib.h>

#ifndef MBUF_SIZE_MULTIPLIER
#define MBUF_SIZE_MULTIPLIER 1.5
#endif

/* Memory buffer descriptor */
struct mbuf {
  char *buf;   /* Buffer pointer */
  size_t len;  /* Data length. Data is located between offset 0 and len. */
  size_t size; /* Buffer size allocated by realloc(1). Must be >= len */
};

/*
 * Initialize an Mbuf.
 * `initial_capacity` specifies the initial capacity of the mbuf.
 */
void mbuf_init(struct mbuf *, size_t initial_capacity);

/* Free the space allocated for the mbuffer and resets the mbuf structure. */
void mbuf_free(struct mbuf *);

/*
 * Appends data to the Mbuf.
 *
 * Return the number of bytes appended, or 0 if out of memory.
 */
size_t mbuf_append(struct mbuf *, const void *data, size_t data_size);

/*
 * Insert data at a specified offset in the Mbuf.
 *
 * Existing data will be shifted forwards and the buffer will
 * be grown if necessary.
 * Return the number of bytes inserted.
 */
size_t mbuf_insert(struct mbuf *, size_t, const void *, size_t);

/* Remove `data_size` bytes from the beginning of the buffer. */
void mbuf_remove(struct mbuf *, size_t data_size);

/*
 * Resize an Mbuf.
 *
 * If `new_size` is smaller than buffer's `len`, the
 * resize is not performed.
 */
void mbuf_resize(struct mbuf *, size_t new_size);

/* Shrink an Mbuf by resizing its `size` to `len`. */
void mbuf_trim(struct mbuf *);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* MBUF_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef _UTF_H_
#define _UTF_H_ 1

#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

typedef unsigned char uchar;

typedef unsigned short Rune; /* 16 bits */

#define nelem(a) (sizeof(a) / sizeof(a)[0])

enum {
  UTFmax = 3,               /* maximum bytes per rune */
  Runesync = 0x80,          /* cannot represent part of a UTF sequence (<) */
  Runeself = 0x80,          /* rune and UTF sequences are the same (<) */
  Runeerror = 0xFFFD        /* decoding error in UTF */
  /* Runemax    = 0xFFFC */ /* maximum rune value */
};

/* Edit .+1,/^$/ | cfn $PLAN9/src/lib9/utf/?*.c | grep -v static |grep -v __ */
int chartorune(Rune *rune, const char *str);
int fullrune(char *str, int n);
int isdigitrune(Rune c);
int isnewline(Rune c);
int iswordchar(Rune c);
int isalpharune(Rune c);
int islowerrune(Rune c);
int isspacerune(Rune c);
int isupperrune(Rune c);
int runetochar(char *str, Rune *rune);
Rune tolowerrune(Rune c);
Rune toupperrune(Rune c);
int utfnlen(char *s, long m);
char *utfnshift(char *s, long m);

#if 0 /* Not implemented. */
int istitlerune(Rune c);
int runelen(Rune c);
int runenlen(Rune *r, int nrune);
Rune *runestrcat(Rune *s1, Rune *s2);
Rune *runestrchr(Rune *s, Rune c);
Rune *runestrcpy(Rune *s1, Rune *s2);
Rune *runestrdup(Rune *s);
Rune *runestrecpy(Rune *s1, Rune *es1, Rune *s2);
int runestrcmp(Rune *s1, Rune *s2);
long runestrlen(Rune *s);
Rune *runestrncat(Rune *s1, Rune *s2, long n);
int runestrncmp(Rune *s1, Rune *s2, long n);
Rune *runestrncpy(Rune *s1, Rune *s2, long n);
Rune *runestrrchr(Rune *s, Rune c);
Rune *runestrstr(Rune *s1, Rune *s2);
Rune totitlerune(Rune c);
char *utfecpy(char *to, char *e, char *from);
int utflen(char *s);
char *utfrrune(char *s, long c);
char *utfrune(char *s, long c);
char *utfutf(char *s1, char *s2);
#endif

#if defined(__cplusplus)
}
#endif /* __cplusplus */
#endif /* _UTF_H_ */
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */

#ifndef OSDEP_HEADER_INCLUDED
#define OSDEP_HEADER_INCLUDED

#if !defined(NS_DISABLE_FILESYSTEM) && defined(AVR_NOFS)
#define NS_DISABLE_FILESYSTEM
#endif

#undef UNICODE                  /* Use ANSI WinAPI functions */
#undef _UNICODE                 /* Use multibyte encoding on Windows */
#define _MBCS                   /* Use multibyte encoding on Windows */
#define _INTEGRAL_MAX_BITS 64   /* Enable _stati64() on Windows */
#define _CRT_SECURE_NO_WARNINGS /* Disable deprecation warning in VS2005+ */
#undef WIN32_LEAN_AND_MEAN      /* Let windows.h always include winsock2.h */
#undef _XOPEN_SOURCE
#define _XOPEN_SOURCE 600    /* For flockfile() on Linux */
#define __STDC_FORMAT_MACROS /* <inttypes.h> wants this for C++ */
#define __STDC_LIMIT_MACROS  /* C++ wants that for INT64_MAX */
#ifndef _LARGEFILE_SOURCE
#define _LARGEFILE_SOURCE /* Enable fseeko() and ftello() functions */
#endif
#define _FILE_OFFSET_BITS 64 /* Enable 64-bit file offsets */

#ifndef BYTE_ORDER
#define LITTLE_ENDIAN 0x41424344
#define BIG_ENDIAN 0x44434241
#define PDP_ENDIAN 0x42414443
/* TODO(lsm): fix for big-endian machines. 'ABCD' is not portable */
/*#define BYTE_ORDER 'ABCD'*/
#define BYTE_ORDER LITTLE_ENDIAN
#endif

/*
 * MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
 * MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
 * MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
 * MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
 * MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
 * MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio 2003)
 * MSVC++ 7.0  _MSC_VER == 1300
 * MSVC++ 6.0  _MSC_VER == 1200
 * MSVC++ 5.0  _MSC_VER == 1100
 */
#ifdef _MSC_VER
#pragma warning(disable : 4127) /* FD_SET() emits warning, disable it */
#pragma warning(disable : 4204) /* missing c99 support */
#endif

#if !(defined(AVR_LIBC) || defined(PICOTCP))
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <signal.h>
#endif

#ifdef PICOTCP
#define time(x) PICO_TIME()
#ifndef SOMAXCONN
#define SOMAXCONN (16)
#endif
#ifdef _POSIX_VERSION
#define signal(...)
#endif
#endif

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef va_copy
#ifdef __va_copy
#define va_copy __va_copy
#else
#define va_copy(x, y) (x) = (y)
#endif
#endif

#ifdef _WIN32
#ifdef _MSC_VER
#pragma comment(lib, "ws2_32.lib") /* Linking with winsock library */
#endif
#include <windows.h>
#include <process.h>
#ifndef EINPROGRESS
#define EINPROGRESS WSAEINPROGRESS
#endif
#ifndef EWOULDBLOCK
#define EWOULDBLOCK WSAEWOULDBLOCK
#endif
#ifndef __func__
#define STRX(x) #x
#define STR(x) STRX(x)
#define __func__ __FILE__ ":" STR(__LINE__)
#endif
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#define sleep(x) Sleep((x) *1000)
#define to64(x) _atoi64(x)
#define popen(x, y) _popen((x), (y))
#define pclose(x) _pclose(x)
#if defined(_MSC_VER) && _MSC_VER >= 1400
#define fseeko(x, y, z) _fseeki64((x), (y), (z))
#else
#define fseeko(x, y, z) fseek((x), (y), (z))
#endif
typedef int socklen_t;
typedef unsigned char uint8_t;
typedef unsigned int uint32_t;
typedef unsigned short uint16_t;
typedef unsigned __int64 uint64_t;
typedef __int64 int64_t;
typedef SOCKET sock_t;
typedef uint32_t in_addr_t;
#ifndef pid_t
#define pid_t HANDLE
#endif
#define INT64_FMT "I64d"
#ifdef __MINGW32__
typedef struct stat ns_stat_t;
#else
typedef struct _stati64 ns_stat_t;
#endif
#ifndef S_ISDIR
#define S_ISDIR(x) ((x) &_S_IFDIR)
#endif
#define DIRSEP '\\'

/* POSIX opendir/closedir/readdir API for Windows. */
struct dirent {
  char d_name[MAX_PATH];
};

typedef struct DIR {
  HANDLE handle;
  WIN32_FIND_DATAW info;
  struct dirent result;
} DIR;

DIR *opendir(const char *name);
int closedir(DIR *dir);
struct dirent *readdir(DIR *dir);

#else /* not _WIN32 */
#ifndef NO_LIBC
#include <dirent.h>
#include <fcntl.h>
#include <netdb.h>
#include <pthread.h>
#include <unistd.h>
#include <arpa/inet.h> /* For inet_pton() when NS_ENABLE_IPV6 is defined */
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/select.h>
#endif
#include <errno.h>
#include <inttypes.h>
#include <stdarg.h>
#ifndef AVR_LIBC
#define closesocket(x) close(x)
#define __cdecl
#define INVALID_SOCKET (-1)
#define INT64_FMT PRId64
#define to64(x) strtoll(x, NULL, 10)
typedef int sock_t;
typedef struct stat ns_stat_t;
#define DIRSEP '/'
#endif
#ifdef __APPLE__
int64_t strtoll(const char *str, char **endptr, int base);
#endif
#endif /* _WIN32 */

#ifdef NS_ENABLE_DEBUG
#define DBG(x)                  \
  do {                          \
    printf("%-20s ", __func__); \
    printf x;                   \
    putchar('\n');              \
    fflush(stdout);             \
  } while (0)
#else
#define DBG(x)
#endif

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
#endif

#if !defined(NO_LIBC) && !defined(NS_DISABLE_FILESYSTEM)
typedef FILE *c_file_t;
/*
 * Cannot use fopen & Co directly and
 * override them with -D because
 * these overrides conflicts with
 * functions in stdio.h
 */
#define c_fopen fopen
#define c_fread fread
#define c_fwrite fwrite
#define c_fclose fclose
#define c_rename rename
#define c_remove remove
#define c_fseek fseek
#define c_ftell ftell
#define c_rewind rewind
#define c_ferror ferror
#define INVALID_FILE NULL
#else
/*
 * TODO(alashkin): move to .h file (v7.h?)
 */
c_file_t c_fopen(const char *filename, const char *mode);
size_t c_fread(void *ptr, size_t size, size_t count, c_file_t fd);
size_t c_fwrite(const void *ptr, size_t size, size_t count, c_file_t fd);
int c_fclose(c_file_t fd);
int c_rename(const char *oldname, const char *newname);
int c_remove(const char *filename);
void c_rewind(c_file_t fd);
int c_ferror(c_file_t fd);
#endif

#endif /* OSDEP_HEADER_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#if !defined(BASE64_H_INCLUDED) && !defined(DISABLE_BASE64)
#define BASE64_H_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

void cs_base64_encode(const unsigned char *src, int src_len, char *dst);
int cs_base64_decode(const unsigned char *s, int len, char *dst);

#ifdef __cplusplus
}
#endif
#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef MD5_HEADER_DEFINED
#define MD5_HEADER_DEFINED


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

typedef struct MD5Context {
  uint32_t buf[4];
  uint32_t bits[2];
  unsigned char in[64];
} MD5_CTX;

void MD5_Init(MD5_CTX *c);
void MD5_Update(MD5_CTX *c, const unsigned char *data, size_t len);
void MD5_Final(unsigned char *md, MD5_CTX *c);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#if !defined(NS_SHA1_HEADER_INCLUDED) && !defined(DISABLE_SHA1)
#define NS_SHA1_HEADER_INCLUDED


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

typedef struct {
  uint32_t state[5];
  uint32_t count[2];
  unsigned char buffer[64];
} SHA1_CTX;

void SHA1Init(SHA1_CTX *);
void SHA1Update(SHA1_CTX *, const unsigned char *data, uint32_t len);
void SHA1Final(unsigned char digest[20], SHA1_CTX *);
void hmac_sha1(const unsigned char *key, size_t key_len,
               const unsigned char *text, size_t text_len,
               unsigned char out[20]);
#ifdef __cplusplus
}
#endif /* __cplusplus */
#endif /* NS_SHA1_HEADER_INCLUDED */
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */

#ifndef STR_UTIL_H
#define STR_UTIL_H

#include <stdarg.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

int c_snprintf(char *buf, size_t buf_size, const char *format, ...);
int c_vsnprintf(char *buf, size_t buf_size, const char *format, va_list ap);

#ifdef __cplusplus
}
#endif
#endif
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */

/*
 * === Non-Standard API
 *
 *   V7 has several non-standard extensions for `String.prototype` in
 *   order to give a compact and fast API to access raw data obtained from
 *   File, Socket, and hardware input/output such as I2C.
 *   V7 IO API functions return
 *   string data as a result of read operations, and that string data is a
 *   raw byte array. ECMA6 provides `ArrayBuffer` and `DataView` API for dealing
 *   with raw bytes, because strings in JavaScript are Unicode. That standard
 *   API is too bloated for the embedded use, and does not allow to use handy
 *   String API (e.g. `.match()`) against data.
 *
 *   V7 internally stores strings as byte arrays. All strings created by the
 *   String API are UTF8 encoded. Strings that are the result of
 *   input/output API calls might not be a valid UTF8 strings, but nevertheless
 *   they are represented as strings, and the following API allows to access
 *   underlying byte sequence:
 *
 * ==== String.prototype.at(position) -> number or NaN
 *      Return byte at index
 *     `position`. Byte value is in 0,255 range. If `position` is out of bounds
 *     (either negative or larger then the byte array length), NaN is returned.
 *     Example: `"ы".at(0)` returns 0xd1.
 *
 * ==== String.prototype.blen -> number
 *     Return string length in bytes.
 *     Example: `"ы".blen` returns 2. Note that `"ы".length` is 1, since that
 *     string consists of a single Unicode character (2-byte).
 *
 * === Builtin API
 *
 * Builtin API provides additional JavaScript interfaces available for V7
 * scripts.
 * File API is a wrapper around standard C calls `fopen()`, `fclose()`,
 * `fread()`, `fwrite()`, `rename()`, `remove()`.
 * Crypto API provides functions for base64, md5, and sha1 encoding/decoding.
 * Socket API provides low-level socket API.
 *
 * ==== File.open(file_name [, mode]) -> file_object or null
 * Open a file `path`. For
 * list of valid `mode` values, see `fopen()` documentation. If `mode` is
 * not specified, mode `rb` is used, i.e. file is opened in read-only mode.
 * Return an opened file object, or null on error. Example:
 * `var f = File.open('/etc/passwd'); f.close();`
 *
 * ==== file_obj.close() -> undefined
 * Close opened file object.
 * NOTE: it is user's responsibility to close all opened file streams. V7
 * does not do that automatically.
 *
 * ==== file_obj.read() -> string
 * Read portion of data from
 * an opened file stream. Return string with data, or empty string on EOF
 * or error.
 *
 * ==== file_obj.readAll() -> string
 * Same as `read()`, but keeps reading data until EOF.
 *
 * ==== file_obj.write(str) -> num_bytes_written
 * Write string `str` to the opened file object. Return number of bytes written.
 *
 * ==== File.rename(old_name, new_name) -> errno
 * Rename file `old_name` to
 * `new_name`. Return 0 on success, or `errno` value on error.
 *
 * ==== File.list(dir_name) -> array_of_names
 * Return a list of files in a given directory, or `undefined` on error.
 *
 * ==== File.remove(file_name) -> errno
 * Delete file `file_name`.
 * Return 0 on success, or `errno` value on error.
 *
 * ==== Crypto.base64_encode(str)
 * Base64-encode input string `str` and return encoded string.
 *
 * ==== Crypto.base64_decode(str)
 * Base64-decode input string `str` and return decoded string.
 *
 * ==== Crypto.md5(str), Crypto.md5_hex(str)
 * Generate MD5 hash from input string `str`. Return 16-byte hash (`md5()`),
 * or stringified hexadecimal representation of the hash (`md5_hex`).
 *
 * ==== Crypto.sha1(str), Crypto.sha1_hex(str)
 * Generate SHA1 hash from input string `str`. Return 20-byte hash (`sha1()`),
 * or stringified hexadecimal representation of the hash (`sha1_hex`).
 *
 * ==== Socket.connect(host, port [, is_udp]) -> socket_obj
 * Connect to a given host. `host` can be a string IP address, or a host name.
 * Optional `is_udp` parameter, if true, indicates that socket should be UDP.
 * Return socket object on success, null on error.
 *
 * ==== Socket.listen(port [, ip_address [,is_udp]]) -> socket_obj
 * Create a listening socket on a given port. Optional `ip_address` argument
 * specifies and IP address to bind to. Optional `is_udp` parameter, if true,
 * indicates that socket should be UDP. Return socket object on success,
 * null on error.
 *
 * ==== socket_obj.accept() -> socket_obj
 * Sleep until new incoming connection is arrived. Return accepted socket
 * object on success, or `null` on error.
 *
 * ==== socket_obj.close() -> numeric_errno
 * Close socket object. Return 0 on success, or system errno on error.
 *
 * ==== socket_obj.recv() -> string
 * Read data from socket. Return data string, or empty string if peer has
 * disconnected, or `null` on error.
 *
 * ==== socket_obj.recvAll() -> string
 * Same as `recv()`, but keeps reading data until socket is closed.
 *
 * ==== sock.send(string) -> num_bytes_sent
 * Send string to the socket. Return number of bytes sent, or 0 on error.
 * Simple HTTP client example:
 *
 *    var s = Socket.connect("google.com", 80);
 *    s.send("GET / HTTP/1.0\n\n");
 *    var reply = s.recv();
 */

#ifndef BUILTIN_HEADER_DEFINED
#define BUILTIN_HEADER_DEFINED

void init_file(struct v7 *);
void init_socket(struct v7 *);
void init_crypto(struct v7 *);

#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef AST_H_INCLUDED
#define AST_H_INCLUDED

#include <stdio.h>

#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

enum ast_tag {
  AST_NOP,
  AST_SCRIPT,
  AST_VAR,
  AST_VAR_DECL,
  AST_FUNC_DECL,
  AST_IF,
  AST_FUNC,

  AST_ASSIGN,
  AST_REM_ASSIGN,
  AST_MUL_ASSIGN,
  AST_DIV_ASSIGN,
  AST_XOR_ASSIGN,
  AST_PLUS_ASSIGN,
  AST_MINUS_ASSIGN,
  AST_OR_ASSIGN,
  AST_AND_ASSIGN,
  AST_LSHIFT_ASSIGN,
  AST_RSHIFT_ASSIGN,
  AST_URSHIFT_ASSIGN,

  AST_NUM,
  AST_IDENT,
  AST_STRING,
  AST_REGEX,
  AST_LABEL,

  AST_SEQ,
  AST_WHILE,
  AST_DOWHILE,
  AST_FOR,
  AST_FOR_IN,
  AST_COND,

  AST_DEBUGGER,
  AST_BREAK,
  AST_LABELED_BREAK,
  AST_CONTINUE,
  AST_LABELED_CONTINUE,
  AST_RETURN,
  AST_VALUE_RETURN,
  AST_THROW,

  AST_TRY,
  AST_SWITCH,
  AST_CASE,
  AST_DEFAULT,
  AST_WITH,

  AST_LOGICAL_OR,
  AST_LOGICAL_AND,
  AST_OR,
  AST_XOR,
  AST_AND,

  AST_EQ,
  AST_EQ_EQ,
  AST_NE,
  AST_NE_NE,

  AST_LE,
  AST_LT,
  AST_GE,
  AST_GT,
  AST_IN,
  AST_INSTANCEOF,

  AST_LSHIFT,
  AST_RSHIFT,
  AST_URSHIFT,

  AST_ADD,
  AST_SUB,

  AST_REM,
  AST_MUL,
  AST_DIV,

  AST_POSITIVE,
  AST_NEGATIVE,
  AST_NOT,
  AST_LOGICAL_NOT,
  AST_VOID,
  AST_DELETE,
  AST_TYPEOF,
  AST_PREINC,
  AST_PREDEC,

  AST_POSTINC,
  AST_POSTDEC,

  AST_MEMBER,
  AST_INDEX,
  AST_CALL,

  AST_NEW,

  AST_ARRAY,
  AST_OBJECT,
  AST_PROP,
  AST_GETTER,
  AST_SETTER,

  AST_THIS,
  AST_TRUE,
  AST_FALSE,
  AST_NULL,
  AST_UNDEFINED,

  AST_USE_STRICT,

  AST_MAX_TAG
};

struct ast {
  struct mbuf mbuf;
  int refcnt;
};

typedef unsigned long ast_off_t;

#ifdef __GNUC__
/*
 * TODO(mkm): GCC complains that bitfields on char are not standard
 */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
#endif
struct ast_node_def {
#ifndef V7_DISABLE_AST_TAG_NAMES
  const char *name; /* tag name, for debugging and serialization */
#endif
  /* int because some archs cannot address flash with byte instructions */
  unsigned int has_varint : 1;   /* has a varint body */
  unsigned int has_inlined : 1;  /* inlined data whose size is in varint fld */
  unsigned int num_skips : 3;    /* number of skips */
  unsigned int num_subtrees : 3; /* number of fixed subtrees */
};
extern const struct ast_node_def ast_node_defs[];
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

enum ast_which_skip {
  AST_END_SKIP = 0,
  AST_VAR_NEXT_SKIP = 1,
  AST_SCRIPT_FIRST_VAR_SKIP = AST_VAR_NEXT_SKIP,
  AST_FOR_BODY_SKIP = 1,
  AST_DO_WHILE_COND_SKIP = 1,
  AST_END_IF_TRUE_SKIP = 1,
  AST_TRY_CATCH_SKIP = 1,
  AST_TRY_FINALLY_SKIP = 2,
  AST_FUNC_FIRST_VAR_SKIP = AST_VAR_NEXT_SKIP,
  AST_FUNC_BODY_SKIP = 2,
  AST_SWITCH_DEFAULT_SKIP = 1
};

V7_PRIVATE void ast_init(struct ast *, size_t);
V7_PRIVATE void ast_optimize(struct ast *);
V7_PRIVATE void ast_free(struct ast *);
V7_PRIVATE ast_off_t ast_add_node(struct ast *, enum ast_tag);
V7_PRIVATE ast_off_t ast_insert_node(struct ast *, ast_off_t, enum ast_tag);
V7_PRIVATE ast_off_t ast_set_skip(struct ast *, ast_off_t, enum ast_which_skip);
V7_PRIVATE ast_off_t ast_get_skip(struct ast *, ast_off_t, enum ast_which_skip);
V7_PRIVATE ast_off_t
ast_modify_skip(struct ast *, ast_off_t, ast_off_t, enum ast_which_skip);
V7_PRIVATE enum ast_tag ast_fetch_tag(struct ast *, ast_off_t *);
V7_PRIVATE void ast_move_to_children(struct ast *, ast_off_t *);

V7_PRIVATE void ast_add_inlined_node(struct ast *, enum ast_tag, const char *,
                                     size_t);
V7_PRIVATE void ast_insert_inlined_node(struct ast *, ast_off_t, enum ast_tag,
                                        const char *, size_t);

V7_PRIVATE char *ast_get_inlined_data(struct ast *, ast_off_t, size_t *);
V7_PRIVATE void ast_get_num(struct ast *, ast_off_t, double *);
V7_PRIVATE void ast_skip_tree(struct ast *, ast_off_t *);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* AST_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef V7_PARSER_H_INCLUDED
#define V7_PARSER_H_INCLUDED


#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

struct v7_pstate {
  const char *file_name;
  const char *source_code;
  const char *pc;   /* Current parsing position */
  int line_no;      /* Line number */
  int prev_line_no; /* Line number of previous token */
  int inhibit_in;   /* True while `in` expressions are inhibited */
  int in_function;  /* True if in a function */
  int in_loop;      /* True if in a loop */
  int in_switch;    /* True if in a switch block */
  int in_strict;    /* True if in strict mode */
};

V7_PRIVATE enum v7_err parse(struct v7 *, struct ast *, const char *, int);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* V7_PARSER_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef MM_H_INCLUDED
#define MM_H_INCLUDED


typedef void (*gc_cell_destructor_t)(struct v7 *v7, void *);

struct gc_block {
  struct gc_block *next;
  struct gc_cell *base;
  size_t size;
};

struct gc_arena {
  struct gc_block *blocks;
  size_t size_increment;
  struct gc_cell *free; /* head of free list */
  size_t cell_size;

#if V7_ENABLE__Memory__stats
  unsigned long allocations; /* cumulative counter of allocations */
  unsigned long garbage;     /* cumulative counter of garbage */
  unsigned long alive;       /* number of living cells */
#endif

  gc_cell_destructor_t destructor;

  int verbose;
  const char *name; /* for debugging purposes */
};

#endif /* GC_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef V7_INTERNAL_H_INCLUDED
#define V7_INTERNAL_H_INCLUDED


/* Check whether we're compiling in an environment with no filesystem */
#if defined(ARDUINO) && (ARDUINO == 106)
#define V7_NO_FS
#endif

#ifndef FAST
#define FAST
#endif

#ifndef STATIC
#define STATIC
#endif

#ifndef ENDL
#define ENDL "\n"
#endif

/*
 * In some compilers (watcom) NAN == NAN (and other comparisons) don't follow
 * the rules of IEEE 754. Since we don't know a priori which compilers
 * will generate correct code, we disable the fallback on selected platforms.
 * TODO(mkm): selectively disable on clang/gcc once we test this out.
 */
#define V7_BROKEN_NAN

#ifdef __GNUC__
#define NORETURN __attribute__((noreturn))
#define UNUSED __attribute__((unused))
#define NOINLINE __attribute__((noinline))
#else
#define NORETURN
#define UNUSED
#define NOINLINE
#endif

#define _POSIX_C_SOURCE 200809L

#include <assert.h>
#ifndef NO_LIBC
#include <ctype.h>
#endif
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setjmp.h>

/* Public API. Implemented in api.c */

#ifdef V7_WINDOWS
#define vsnprintf _vsnprintf
#define snprintf _snprintf
#define isnan(x) _isnan(x)
#define isinf(x) (!_finite(x))
#define __unused
typedef __int64 int64_t;
typedef int int32_t;
typedef unsigned int uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char uint8_t;
typedef unsigned long uintptr_t;
#define __func__ ""
#else
#include <stdint.h>
#endif


/* Private API */

/* Max captures for String.replace() */
#define V7_RE_MAX_REPL_SUB 255

/* MSVC6 doesn't have standard C math constants defined */
#ifndef M_E
#define M_E 2.71828182845904523536028747135266250
#endif

#ifndef M_LOG2E
#define M_LOG2E 1.44269504088896340735992468100189214
#endif

#ifndef M_LOG10E
#define M_LOG10E 0.434294481903251827651128918916605082
#endif

#ifndef M_LN2
#define M_LN2 0.693147180559945309417232121458176568
#endif

#ifndef M_LN10
#define M_LN10 2.30258509299404568401799145468436421
#endif

#ifndef M_PI
#define M_PI 3.14159265358979323846264338327950288
#endif

#ifndef M_SQRT2
#define M_SQRT2 1.41421356237309504880168872420969808
#endif

#ifndef M_SQRT1_2
#define M_SQRT1_2 0.707106781186547524400844362104849039
#endif

#ifndef NAN
extern double _v7_nan;
#define HAS_V7_NAN
#define NAN (_v7_nan)
#endif

#ifndef INFINITY
extern double _v7_infinity;
#define HAS_V7_INFINITY
#define INFINITY (_v7_infinity)
#endif

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif

/* TODO(lsm): move VM definitions to vm.h */
#ifndef VM_H_INCLUDED
#define V7_VALUE_DEFINED
typedef uint64_t val_t;
#endif

/*
 * JavaScript value is either a primitive, or an object.
 * There are 5 primitive types: Undefined, Null, Boolean, Number, String.
 * Non-primitive type is an Object type. There are several classes of Objects,
 * see description of `struct v7_object` below for more details.
 * This enumeration combines types and object classes in one enumeration.
 * NOTE(lsm): compile with `-fshort-enums` to reduce sizeof(enum v7_type) to 1.
 */
enum v7_type {
  /* Primitive types */
  V7_TYPE_UNDEFINED,
  V7_TYPE_NULL,
  V7_TYPE_BOOLEAN,
  V7_TYPE_NUMBER,
  V7_TYPE_STRING,
  V7_TYPE_FOREIGN,
  V7_TYPE_CFUNCTION,

  /* Different classes of Object type */
  V7_TYPE_GENERIC_OBJECT,
  V7_TYPE_BOOLEAN_OBJECT,
  V7_TYPE_STRING_OBJECT,
  V7_TYPE_NUMBER_OBJECT,
  V7_TYPE_FUNCTION_OBJECT,
  V7_TYPE_CFUNCTION_OBJECT,
  V7_TYPE_REGEXP_OBJECT,
  V7_TYPE_ARRAY_OBJECT,
  V7_TYPE_DATE_OBJECT,
  V7_TYPE_ERROR_OBJECT,
  V7_TYPE_MAX_OBJECT_TYPE,
  V7_NUM_TYPES
};

enum cached_strings {
  PREDEFINED_STR_LENGTH,
  PREDEFINED_STR_PROTOTYPE,
  PREDEFINED_STR_CONSTRUCTOR,
  PREDEFINED_STR_ARGUMENTS,

  PREDEFINED_STR_MAX
};

enum error_ctor {
  TYPE_ERROR,
  SYNTAX_ERROR,
  REFERENCE_ERROR,
  INTERNAL_ERROR,
  RANGE_ERROR,

  ERROR_CTOR_MAX
};


struct v7 {
  val_t global_object;
  val_t this_object;

  val_t object_prototype;
  val_t array_prototype;
  val_t boolean_prototype;
  val_t error_prototype;
  val_t string_prototype;
  val_t regexp_prototype;
  val_t number_prototype;
  val_t date_prototype;
  val_t function_prototype;

  /*
   * Stack of execution contexts.
   * Each execution context object in the call stack has hidden properties:
   *  *  "_p": Parent context (for closures)
   *  *  "_e": Exception environment
   *
   * Hidden properties have V7_PROPERTY_HIDDEN flag set.
   * Execution contexts should be allocated on heap, because they might not be
   * on a call stack but still referenced (closures).
   */
  val_t call_stack;

#ifdef V7_ENABLE_BCODE
  val_t stack[512]; /* value stack for bcode interpreter */
  int sp;           /* current stack pointer, stack grow upwards */
#endif

  struct mbuf owned_strings;   /* Sequence of (varint len, char data[]) */
  struct mbuf foreign_strings; /* Sequence of (varint len, char *data) */

  struct mbuf tmp_stack; /* Stack of val_t* elements, used as root set */
  int need_gc;           /* Set to true to trigger GC when safe */

  struct gc_arena object_arena;
  struct gc_arena function_arena;
  struct gc_arena property_arena;
#if V7_ENABLE__Memory__stats
  size_t function_arena_ast_size;
#endif
  struct mbuf owned_values; /* buffer for GC roots owned by C code */

  int strict_mode; /* true if currently in strict mode */

  val_t error_objects[ERROR_CTOR_MAX];

  val_t thrown_error;
  char error_msg[60];     /* Exception message */
  int creating_exception; /* Avoids reentrant exception creation */
#if defined(__cplusplus)
  ::jmp_buf jmp_buf;
  ::jmp_buf label_jmp_buf;
#else
  jmp_buf jmp_buf;       /* Exception environment for v7_exec() */
  jmp_buf label_jmp_buf; /* Target for non local (labeled) breaks */
#endif
  char *label;      /* Inner label */
  size_t label_len; /* Inner label length */
  int lab_cont;     /* True if re-entering a loop with labeled continue */

  struct mbuf json_visited_stack; /* Detecting cycle in to_json */

  /* Parser state */
  struct v7_pstate pstate; /* Parsing state */
  enum v7_tok cur_tok;     /* Current token */
  const char *tok;         /* Parsed terminal token (ident, number, string) */
  unsigned long tok_len;   /* Length of the parsed terminal token */
  size_t last_var_node;    /* Offset of last var node or function/script node */
  int after_newline;       /* True if the cur_tok starts a new line */
  double cur_tok_dbl;      /* When tokenizing, parser stores TOK_NUMBER here */

  val_t predefined_strings[PREDEFINED_STR_MAX];
  /* singleton, pointer because of amalgamation */
  struct v7_property *cur_dense_prop;

  volatile int interrupt;
#ifdef V7_STACK_SIZE
  void *sp_limit;
#endif
};

enum jmp_type { NO_JMP, THROW_JMP, BREAK_JMP, CONTINUE_JMP };

/* Vector, describes some memory location pointed by 'p' with length 'len' */
struct v7_vec {
  const char *p;
  int len;
};
#define V7_VEC(str) \
  { (str), sizeof(str) - 1 }

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(array) (sizeof(array) / sizeof(array[0]))
#endif

#define V7_STATIC_ASSERT(COND, MSG) \
  typedef char static_assertion_##MSG[2 * (!!(COND)) - 1]

#ifndef NDEBUG
#define V7_CHECK(v7, COND)                                            \
  do {                                                                \
    if (!(COND))                                                      \
      throw_exception(v7, INTERNAL_ERROR, "%s line %d: %s", __func__, \
                      __LINE__, #COND);                               \
  } while (0)
#else
#define V7_CHECK(v7, COND)                                                 \
  do {                                                                     \
    if (!(COND)) throw_exception(v7, INTERNAL_ERROR, "line %d", __LINE__); \
  } while (0)
#endif

#define TRACE_VAL(v7, val)                                     \
  do {                                                         \
    char buf[200], *p = v7_to_json(v7, val, buf, sizeof(buf)); \
    printf("%s %d: [%s]\n", __func__, __LINE__, p);            \
    if (p != buf) free(p);                                     \
  } while (0)

#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

void v7_throw_value(struct v7 *, v7_val_t v) NORETURN;
V7_PRIVATE void throw_exception(struct v7 *, enum error_ctor, const char *,
                                ...) NORETURN;
V7_PRIVATE size_t unescape(const char *s, size_t len, char *to);

V7_PRIVATE void init_js_stdlib(struct v7 *);

V7_PRIVATE val_t Regex_ctor(struct v7 *v7, val_t this_obj, val_t args);

V7_PRIVATE double v7_char_code_at(struct v7 *v7, val_t s, val_t at);

V7_PRIVATE val_t rx_exec(struct v7 *v7, val_t rx, val_t str, int lind);

V7_PRIVATE size_t gc_arena_size(struct gc_arena *);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* V7_INTERNAL_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef VM_H_INCLUDED
#define VM_H_INCLUDED


/* TODO(mkm): remove ifdef once v7 has been moved here */
#ifndef V7_VALUE_DEFINED
typedef uint64_t val_t;
#endif

/*
 *  Double-precision floating-point number, IEEE 754
 *
 *  64 bit (8 bytes) in total
 *  1  bit sign
 *  11 bits exponent
 *  52 bits mantissa
 *      7         6        5        4        3        2        1        0
 *  seeeeeee|eeeemmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm|mmmmmmmm
 *
 * If an exponent is all-1 and mantissa is all-0, then it is an INFINITY:
 *  11111111|11110000|00000000|00000000|00000000|00000000|00000000|00000000
 *
 * If an exponent is all-1 and mantissa's MSB is 1, it is a quiet NaN:
 *  11111111|11111000|00000000|00000000|00000000|00000000|00000000|00000000
 *
 *  V7 NaN-packing:
 *    sign and exponent is 0xfff
 *    4 bits specify type (tag), must be non-zero
 *    48 bits specify value
 *
 *  11111111|1111tttt|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv
 *   NaN marker |type|  48-bit placeholder for values: pointers, strings
 *
 * On 64-bit platforms, pointers are really 48 bit only, so they can fit,
 * provided they are sign extended
 */

#define V7_TAG_OBJECT ((uint64_t) 0xFFFF << 48)
#define V7_TAG_FOREIGN ((uint64_t) 0xFFFE << 48)
#define V7_TAG_UNDEFINED ((uint64_t) 0xFFFD << 48)
#define V7_TAG_BOOLEAN ((uint64_t) 0xFFFC << 48)
#define V7_TAG_NAN ((uint64_t) 0xFFFB << 48)
#define V7_TAG_STRING_I ((uint64_t) 0xFFFA << 48)  /* Inlined string len < 5 */
#define V7_TAG_STRING_5 ((uint64_t) 0xFFF9 << 48)  /* Inlined string len 5 */
#define V7_TAG_STRING_O ((uint64_t) 0xFFF8 << 48)  /* Owned string */
#define V7_TAG_STRING_F ((uint64_t) 0xFFF7 << 48)  /* Foreign string */
#define V7_TAG_STRING_C ((uint64_t) 0xFFF6 << 48)  /* String chunk */
#define V7_TAG_FUNCTION ((uint64_t) 0xFFF5 << 48)  /* JavaScript function */
#define V7_TAG_CFUNCTION ((uint64_t) 0xFFF4 << 48) /* C function */
#define V7_TAG_GETSETTER ((uint64_t) 0xFFF3 << 48) /* getter+setter */
#define V7_TAG_REGEXP ((uint64_t) 0xFFF2 << 48)    /* Regex */
#define V7_TAG_NOVALUE ((uint64_t) 0xFFF1 << 48)   /* Sentinel for no value */
#define V7_TAG_MASK ((uint64_t) 0xFFFF << 48)

#define V7_NULL V7_TAG_FOREIGN
#define V7_UNDEFINED V7_TAG_UNDEFINED

struct v7_property {
  struct v7_property *next; /* Linkage in struct v7_object::properties */
  unsigned int attributes;
  val_t name;  /* Property name (a string) */
  val_t value; /* Property value */
};

/*
 * An object is an unordered collection of properties.
 * A function stored in a property of an object is called a method.
 * A property has a name, a value, and set of attributes.
 * Attributes are: ReadOnly, DontEnum, DontDelete, Internal.
 *
 * A constructor is a function that creates and initializes objects.
 * Each constructor has an associated prototype object that is used for
 * inheritance and shared properties. When a constructor creates an object,
 * the new object references the constructor’s prototype.
 *
 * Objects could be a "generic objects" which is a collection of properties,
 * or a "typed object" which also hold an internal value like String or Number.
 * Those values are implicit, unnamed properties of the respective types,
 * and can be coerced into primitive types by calling a respective constructor
 * as a function:
 *    var a = new Number(123);
 *    typeof(a) == 'object';
 *    typeof(Number(a)) == 'number';
 */
struct v7_object {
  /* First HIDDEN property in a chain is an internal object value */
  struct v7_property *properties;
  struct v7_object *prototype;
  uint8_t attributes;
#define V7_OBJ_NOT_EXTENSIBLE 1 /* TODO(lsm): store this in LSB */
#define V7_OBJ_DENSE_ARRAY 2    /* TODO(mkm): store in some tag */
};

/*
 * Variables are function-scoped and are hoisted.
 * Lexical scoping & closures: each function has a chain of scopes, defined
 * by the lexicographic order of function definitions.
 * Scope is different from the execution context.
 * Execution context carries "variable object" which is variable/value
 * mapping for all variables defined in a function, and `this` object.
 * If function is not called as a method, then `this` is a global object.
 * Otherwise, `this` is an object that contains called method.
 * New execution context is created each time a function call is performed.
 * Passing arguments through recursion is done using execution context, e.g.
 *
 *    var factorial = function(num) {
 *      return num < 2 ? 1 : num * factorial(num - 1);
 *    };
 *
 * Here, recursion calls the same function `factorial` several times. Execution
 * contexts for each call form a stack. Each context has different variable
 * object, `vars`, with different values of `num`.
 */

struct v7_function {
  /*
   * Functions are objects. This has to be the first field so that function
   * objects can be managed by the GC.
   */
  struct v7_property *properties;
  struct v7_object *scope; /* lexical scope of the closure */
  uintptr_t debug;
  struct ast *ast;         /* AST, used as a byte code for execution */
  unsigned int ast_off;    /* Position of the function node in the AST */
  unsigned int attributes; /* Function attributes */
#define V7_FUNCTION_STRICT 1
};

struct v7_regexp {
  val_t regexp_string;
  struct slre_prog *compiled_regexp;
  long lastIndex;
};

#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

/* TODO(mkm): possibly replace those with macros for inlining */
enum v7_type val_type(struct v7 *v7, val_t);
int v7_is_error(struct v7 *v7, val_t);
V7_PRIVATE val_t v7_pointer_to_value(void *);

V7_PRIVATE struct v7_regexp *v7_to_regexp(struct v7 *, val_t);
val_t v7_object_to_value(struct v7_object *);
val_t v7_function_to_value(struct v7_function *);

struct v7_object *v7_to_object(val_t);
struct v7_function *v7_to_function(val_t);
V7_PRIVATE void *v7_to_pointer(val_t v);

V7_PRIVATE void init_object(struct v7 *v7);
V7_PRIVATE void init_array(struct v7 *v7);
V7_PRIVATE void init_error(struct v7 *v7);
V7_PRIVATE void init_boolean(struct v7 *v7);
V7_PRIVATE void init_math(struct v7 *v7);
V7_PRIVATE void init_string(struct v7 *v7);
V7_PRIVATE void init_regex(struct v7 *v7);
V7_PRIVATE void init_number(struct v7 *v7);
V7_PRIVATE void init_json(struct v7 *v7);
V7_PRIVATE void init_date(struct v7 *v7);
V7_PRIVATE void init_function(struct v7 *v7);
V7_PRIVATE void init_stdlib(struct v7 *v7);

V7_PRIVATE int set_cfunc_prop(struct v7 *, val_t, const char *, v7_cfunction_t);

V7_PRIVATE int set_method(struct v7 *, val_t, const char *, v7_cfunction_t,
                          int);

V7_PRIVATE val_t v_get_prototype(struct v7 *, val_t);
V7_PRIVATE int is_prototype_of(struct v7 *, val_t, val_t);

/* TODO(lsm): NaN payload location depends on endianness, make crossplatform */
#define GET_VAL_NAN_PAYLOAD(v) ((char *) &(v))

V7_PRIVATE val_t create_object(struct v7 *, val_t);
V7_PRIVATE v7_val_t create_function(struct v7 *v7);
V7_PRIVATE v7_val_t v7_create_dense_array(struct v7 *v7);
V7_PRIVATE int v7_stringify_value(struct v7 *, val_t, char *, size_t);
V7_PRIVATE struct v7_property *v7_create_property(struct v7 *);

V7_PRIVATE struct v7_property *v7_get_own_property(struct v7 *, val_t,
                                                   const char *, size_t);
V7_PRIVATE struct v7_property *v7_get_own_property2(struct v7 *, val_t obj,
                                                    const char *name, size_t,
                                                    unsigned int attrs);

/* If `len` is -1/MAXUINT/~0, then `name` must be 0-terminated */
V7_PRIVATE struct v7_property *v7_get_property(struct v7 *, val_t obj,
                                               const char *name, size_t);
V7_PRIVATE v7_val_t v7_get_v(struct v7 *, v7_val_t, v7_val_t);

V7_PRIVATE void v7_invoke_setter(struct v7 *, struct v7_property *, val_t,
                                 val_t);
V7_PRIVATE int v7_set_v(struct v7 *, v7_val_t, v7_val_t, v7_val_t);
V7_PRIVATE int v7_set_property_v(struct v7 *, v7_val_t obj, v7_val_t name,
                                 unsigned int attributes, v7_val_t val);
V7_PRIVATE int v7_set_property(struct v7 *, v7_val_t obj, const char *name,
                               size_t len, unsigned int attributes,
                               v7_val_t val);
V7_PRIVATE struct v7_property *v7_set_prop(struct v7 *v7, val_t obj, val_t name,
                                           unsigned int attributes, val_t val);

/* Return address of property value or NULL if the passed property is NULL */
V7_PRIVATE val_t v7_property_value(struct v7 *, val_t, struct v7_property *);

V7_PRIVATE struct v7_property *v7_next_prop(struct v7 *, val_t,
                                            struct v7_property *);
V7_PRIVATE val_t v7_iter_get_value(struct v7 *, val_t, struct v7_property *);
V7_PRIVATE val_t v7_iter_get_name(struct v7 *, struct v7_property *);
V7_PRIVATE val_t v7_iter_get_index(struct v7 *, struct v7_property *);

/*
 * If `len` is -1/MAXUINT/~0, then `name` must be 0-terminated.
 * Return 0 on success, -1 on error.
 */
V7_PRIVATE int v7_del_property(struct v7 *, val_t, const char *, size_t);

V7_PRIVATE val_t v7_array_get2(struct v7 *, v7_val_t, unsigned long, int *);
V7_PRIVATE long arg_long(struct v7 *v7, val_t args, int n, long default_value);
V7_PRIVATE int to_str(struct v7 *v7, val_t v, char *buf, size_t size,
                      int as_json);
V7_PRIVATE void v7_destroy_property(struct v7_property **p);
V7_PRIVATE val_t i_value_of(struct v7 *v7, val_t v);
V7_PRIVATE val_t _std_eval(struct v7 *v7, val_t args, char before, char after);

/* String API */
V7_PRIVATE int s_cmp(struct v7 *, val_t a, val_t b);
V7_PRIVATE val_t s_concat(struct v7 *, val_t, val_t);
V7_PRIVATE val_t ulong_to_str(struct v7 *, unsigned long);
V7_PRIVATE unsigned long str_to_ulong(struct v7 *, val_t, int *);
V7_PRIVATE unsigned long cstr_to_ulong(const char *, size_t len, int *);
V7_PRIVATE void embed_string(struct mbuf *, size_t, const char *, size_t, int,
                             int);
/* TODO(mkm): rename after regexp merge */
V7_PRIVATE val_t to_string(struct v7 *v7, val_t v);
V7_PRIVATE long to_long(struct v7 *v7, val_t v, long default_value);

V7_PRIVATE val_t Obj_valueOf(struct v7 *, val_t, val_t);
V7_PRIVATE double i_as_num(struct v7 *, val_t);
V7_PRIVATE val_t n_to_str(struct v7 *, val_t, val_t, const char *);

V7_PRIVATE void release_ast(struct v7 *, struct ast *);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* VM_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef COMPILER_H_INCLUDED
#define COMPILER_H_INCLUDED


#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

enum opcode {
  OP_PUSH_ZERO,
  OP_PUSH_ONE,
  OP_PUSH_LIT,

  OP_ADD,
  OP_SUB,
  OP_REM,
  OP_MUL,
  OP_DIV,
  OP_LSHIFT,
  OP_RSHIFT,
  OP_URSHIFT,
  OP_OR,
  OP_XOR,
  OP_AND,

  OP_EQ_EQ,
  OP_EQ,
  OP_NE,
  OP_NE_NE,
  OP_LT,
  OP_LE,
  OP_GT,
  OP_GE,

  OP_GET,
  OP_SET,
  OP_SET_VAR,
  OP_GET_VAR /* takes index of var name */
};

/*
 * Each JS function will have one bcode structure
 * containing the instruction stream and a literal table.
 * Instructions contain references to literals (strings, constants, etc)
 * relative to their
 *
 * TODO(mkm): turn lit into a heap allocated structure,
 * or make the whole bytecode structure a dynamically sized structure
 * and combine the literal table with the bytecode list.
 */
struct bcode {
  uint8_t *ops;   /* pointer to first instruction opcode */
  size_t ops_len; /* length of the instruction stream */
  val_t lit[32];  /* literal table */
  size_t lit_len; /* length of literal table */
};

V7_PRIVATE void eval_bcode(struct v7 *, struct bcode *);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* COMPILER_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef GC_H_INCLUDED
#define GC_H_INCLUDED


/*
 * Disable GC on 32-bit platform for now
 * It does work but it's less stable than the 64-bit GC.
 */
#if ULONG_MAX == 4294967295 && !defined(V7_ENABLE_GC)
#define V7_DISABLE_GC
#endif

#define MARK(p) (((struct gc_cell *) (p))->head.word |= 1)
#define UNMARK(p) (((struct gc_cell *) (p))->head.word &= ~1)
#define MARKED(p) (((struct gc_cell *) (p))->head.word & 1)

/*
 * performs arithmetics on gc_cell pointers as if they were arena->cell_size
 * bytes wide
 */
#define GC_CELL_OP(arena, cell, op, arg) \
  ((struct gc_cell *) (((char *) (cell)) op((arg) * (arena)->cell_size)))

struct gc_tmp_frame {
  struct v7 *v7;
  size_t pos;
};

struct gc_cell {
  union {
    struct gc_cell *link;
    uintptr_t word;
  } head;
};

#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

V7_PRIVATE struct v7_object *new_object(struct v7 *);
V7_PRIVATE struct v7_property *new_property(struct v7 *);
V7_PRIVATE struct v7_function *new_function(struct v7 *);

V7_PRIVATE void gc_mark(struct v7 *, val_t);

V7_PRIVATE void gc_arena_init(struct gc_arena *, size_t, size_t, size_t,
                              const char *);
V7_PRIVATE void gc_arena_grow(struct v7 *, struct gc_arena *, size_t);
V7_PRIVATE void gc_arena_destroy(struct v7 *, struct gc_arena *a);
V7_PRIVATE void gc_sweep(struct v7 *, struct gc_arena *, size_t);
V7_PRIVATE void *gc_alloc_cell(struct v7 *, struct gc_arena *);

V7_PRIVATE struct gc_tmp_frame new_tmp_frame(struct v7 *);
V7_PRIVATE void tmp_frame_cleanup(struct gc_tmp_frame *);
V7_PRIVATE void tmp_stack_push(struct gc_tmp_frame *, val_t *);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* GC_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 *
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <http://cesanta.com/>.
 */

#ifndef SLRE_HEADER_INCLUDED
#define SLRE_HEADER_INCLUDED

/* Return codes for slre_compile() */
enum slre_error {
  SLRE_OK,
  SLRE_INVALID_DEC_DIGIT,
  SLRE_INVALID_HEX_DIGIT,
  SLRE_INVALID_ESC_CHAR,
  SLRE_UNTERM_ESC_SEQ,
  SLRE_SYNTAX_ERROR,
  SLRE_UNMATCH_LBR,
  SLRE_UNMATCH_RBR,
  SLRE_NUM_OVERFLOW,
  SLRE_INF_LOOP_M_EMP_STR,
  SLRE_TOO_MANY_CHARSETS,
  SLRE_INV_CHARSET_RANGE,
  SLRE_CHARSET_TOO_LARGE,
  SLRE_MALFORMED_CHARSET,
  SLRE_INVALID_BACK_REFERENCE,
  SLRE_TOO_MANY_CAPTURES,
  SLRE_INVALID_QUANTIFIER,
  SLRE_BAD_CHAR_AFTER_USD
};

#if V7_ENABLE__RegExp

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Regex flags */
#define SLRE_FLAG_G 1  /* Global - match in the whole string */
#define SLRE_FLAG_I 2  /* Ignore case */
#define SLRE_FLAG_M 4  /* Multiline */
#define SLRE_FLAG_RE 8 /* flag RegExp/String */

/* Describes single capture */
struct slre_cap {
  const char *start; /* points to the beginning of the capture group */
  const char *end;   /* points to the end of the capture group */
};

/* Describes all captures */
#define SLRE_MAX_CAPS 32
struct slre_loot {
  int num_captures;
  struct slre_cap caps[SLRE_MAX_CAPS];
};

/* Opaque structure that holds compiled regular expression */
struct slre_prog;

int slre_compile(const char *regexp, size_t regexp_len, const char *flags,
                 size_t flags_len, struct slre_prog **, int is_regex);
int slre_exec(struct slre_prog *prog, int flag_g, const char *start,
              const char *end, struct slre_loot *loot);
void slre_free(struct slre_prog *prog);

int slre_match(const char *, size_t, const char *, size_t, const char *, size_t,
               struct slre_loot *);
int slre_replace(struct slre_loot *loot, const char *src, size_t src_len,
                 const char *replace, size_t rep_len, struct slre_loot *dst);
int slre_get_flags(struct slre_prog *);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* V7_ENABLE__RegExp */

#endif /* SLRE_HEADER_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#ifndef V7_VARINT_H_INCLUDED
#define V7_VARINT_H_INCLUDED


#if defined(__cplusplus)
extern "C" {
#endif /* __cplusplus */

V7_PRIVATE int encode_varint(size_t len, unsigned char *p);
V7_PRIVATE size_t decode_varint(const unsigned char *p, int *llen);
V7_PRIVATE int calc_llen(size_t len);

#if defined(__cplusplus)
}
#endif /* __cplusplus */

#endif /* V7_VARINT_H_INCLUDED */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */

#include <assert.h>
#include <string.h>

#ifndef MBUF_REALLOC
#define MBUF_REALLOC realloc
#endif

#ifndef MBUF_FREE
#define MBUF_FREE free
#endif

void mbuf_init(struct mbuf *mbuf, size_t initial_size) {
  mbuf->len = mbuf->size = 0;
  mbuf->buf = NULL;
  mbuf_resize(mbuf, initial_size);
}

void mbuf_free(struct mbuf *mbuf) {
  if (mbuf->buf != NULL) {
    MBUF_FREE(mbuf->buf);
    mbuf_init(mbuf, 0);
  }
}

void mbuf_resize(struct mbuf *a, size_t new_size) {
  char *p;
  if ((new_size > a->size || (new_size < a->size && new_size >= a->len)) &&
      (p = (char *) MBUF_REALLOC(a->buf, new_size)) != NULL) {
    a->size = new_size;
    a->buf = p;
  }
}

void mbuf_trim(struct mbuf *mbuf) {
  mbuf_resize(mbuf, mbuf->len);
}

size_t mbuf_insert(struct mbuf *a, size_t off, const void *buf, size_t len) {
  char *p = NULL;

  assert(a != NULL);
  assert(a->len <= a->size);
  assert(off <= a->len);

  /* check overflow */
  if (~(size_t) 0 - (size_t) a->buf < len) return 0;

  if (a->len + len <= a->size) {
    memmove(a->buf + off + len, a->buf + off, a->len - off);
    if (buf != NULL) {
      memcpy(a->buf + off, buf, len);
    }
    a->len += len;
  } else if ((p = (char *) MBUF_REALLOC(
                  a->buf, (a->len + len) * MBUF_SIZE_MULTIPLIER)) != NULL) {
    a->buf = p;
    memmove(a->buf + off + len, a->buf + off, a->len - off);
    if (buf != NULL) {
      memcpy(a->buf + off, buf, len);
    }
    a->len += len;
    a->size = a->len * MBUF_SIZE_MULTIPLIER;
  } else {
    len = 0;
  }

  return len;
}

size_t mbuf_append(struct mbuf *a, const void *buf, size_t len) {
  return mbuf_insert(a, a->len, buf, len);
}

void mbuf_remove(struct mbuf *mb, size_t n) {
  if (n > 0 && n <= mb->len) {
    memmove(mb->buf, mb->buf + n, mb->len - n);
    mb->len -= n;
  }
}
/*
 * The authors of this software are Rob Pike and Ken Thompson.
 *              Copyright (c) 2002 by Lucent Technologies.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR LUCENT TECHNOLOGIES MAKE
 * ANY REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 */
#ifndef NO_LIBC
#include <ctype.h>
#endif
#include <stdarg.h>
#include <string.h>

#if V7_ENABLE__UTF
enum {
  Bit1 = 7,
  Bitx = 6,
  Bit2 = 5,
  Bit3 = 4,
  Bit4 = 3,
  Bit5 = 2,

  T1 = ((1 << (Bit1 + 1)) - 1) ^ 0xFF, /* 0000 0000 */
  Tx = ((1 << (Bitx + 1)) - 1) ^ 0xFF, /* 1000 0000 */
  T2 = ((1 << (Bit2 + 1)) - 1) ^ 0xFF, /* 1100 0000 */
  T3 = ((1 << (Bit3 + 1)) - 1) ^ 0xFF, /* 1110 0000 */
  T4 = ((1 << (Bit4 + 1)) - 1) ^ 0xFF, /* 1111 0000 */
  T5 = ((1 << (Bit5 + 1)) - 1) ^ 0xFF, /* 1111 1000 */

  Rune1 = (1 << (Bit1 + 0 * Bitx)) - 1, /* 0000 0000 0000 0000 0111 1111 */
  Rune2 = (1 << (Bit2 + 1 * Bitx)) - 1, /* 0000 0000 0000 0111 1111 1111 */
  Rune3 = (1 << (Bit3 + 2 * Bitx)) - 1, /* 0000 0000 1111 1111 1111 1111 */
  Rune4 = (1 << (Bit4 + 3 * Bitx)) - 1, /* 0011 1111 1111 1111 1111 1111 */

  Maskx = (1 << Bitx) - 1, /* 0011 1111 */
  Testx = Maskx ^ 0xFF,    /* 1100 0000 */

  Bad = Runeerror
};

int chartorune(Rune *rune, const char *str) {
  int c, c1, c2 /* , c3 */;
  unsigned short l;

  /*
   * one character sequence
   *	00000-0007F => T1
   */
  c = *(uchar *) str;
  if (c < Tx) {
    *rune = c;
    return 1;
  }

  /*
   * two character sequence
   *	0080-07FF => T2 Tx
   */
  c1 = *(uchar *) (str + 1) ^ Tx;
  if (c1 & Testx) goto bad;
  if (c < T3) {
    if (c < T2) goto bad;
    l = ((c << Bitx) | c1) & Rune2;
    if (l <= Rune1) goto bad;
    *rune = l;
    return 2;
  }

  /*
   * three character sequence
   *	0800-FFFF => T3 Tx Tx
   */
  c2 = *(uchar *) (str + 2) ^ Tx;
  if (c2 & Testx) goto bad;
  if (c < T4) {
    l = ((((c << Bitx) | c1) << Bitx) | c2) & Rune3;
    if (l <= Rune2) goto bad;
    *rune = l;
    return 3;
  }

/*
 * four character sequence
 *	10000-10FFFF => T4 Tx Tx Tx
 */
/* if(UTFmax >= 4) {
        c3 = *(uchar*)(str+3) ^ Tx;
        if(c3 & Testx)
                goto bad;
        if(c < T5) {
                l = ((((((c << Bitx) | c1) << Bitx) | c2) << Bitx) | c3) &
Rune4;
                if(l <= Rune3)
                        goto bad;
                if(l > Runemax)
                        goto bad;
                *rune = l;
                return 4;
        }
} */

/*
 * bad decoding
 */
bad:
  *rune = Bad;
  return 1;
}

int runetochar(char *str, Rune *rune) {
  unsigned short c;

  /*
   * one character sequence
   *	00000-0007F => 00-7F
   */
  c = *rune;
  if (c <= Rune1) {
    str[0] = c;
    return 1;
  }

  /*
   * two character sequence
   *	00080-007FF => T2 Tx
   */
  if (c <= Rune2) {
    str[0] = T2 | (c >> 1 * Bitx);
    str[1] = Tx | (c & Maskx);
    return 2;
  }

  /*
   * three character sequence
   *	00800-0FFFF => T3 Tx Tx
   */
  /* if(c > Runemax)
          c = Runeerror; */
  /* if(c <= Rune3) { */
  str[0] = T3 | (c >> 2 * Bitx);
  str[1] = Tx | ((c >> 1 * Bitx) & Maskx);
  str[2] = Tx | (c & Maskx);
  return 3;
  /* } */

  /*
   * four character sequence
   *	010000-1FFFFF => T4 Tx Tx Tx
   */
  /* str[0] = T4 |  (c >> 3*Bitx);
  str[1] = Tx | ((c >> 2*Bitx) & Maskx);
  str[2] = Tx | ((c >> 1*Bitx) & Maskx);
  str[3] = Tx |  (c & Maskx);
  return 4; */
}

int fullrune(char *str, int n) {
  int c;

  if (n <= 0) return 0;
  c = *(uchar *) str;
  if (c < Tx) return 1;
  if (c < T3) return n >= 2;
  if (UTFmax == 3 || c < T4) return n >= 3;
  return n >= 4;
}

int utfnlen(char *s, long m) {
  int c;
  long n;
  Rune rune;
  char *es;

  es = s + m;
  for (n = 0; s < es; n++) {
    c = *(uchar *) s;
    if (c < Runeself) {
      s++;
      continue;
    }
    if (!fullrune(s, es - s)) break;
    s += chartorune(&rune, s);
  }
  return n;
}

char *utfnshift(char *s, long m) {
  int c;
  long n;
  Rune rune;

  for (n = 0; n < m; n++) {
    c = *(uchar *) s;
    if (c < Runeself) {
      s++;
      continue;
    }
    s += chartorune(&rune, s);
  }
  return s;
}

/*
 * The authors of this software are Rob Pike and Ken Thompson.
 *              Copyright (c) 2002 by Lucent Technologies.
 * Permission to use, copy, modify, and distribute this software for any
 * purpose without fee is hereby granted, provided that this entire notice
 * is included in all copies of any software which is or includes a copy
 * or modification of this software and in all copies of the supporting
 * documentation for such software.
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHORS NOR LUCENT TECHNOLOGIES MAKE
 * ANY REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY
 * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
 */
#include <stdarg.h>
#include <string.h>

/*
 * alpha ranges -
 *	only covers ranges not in lower||upper
 */
static Rune __alpha2[] = {
    0x00d8, 0x00f6, /* Ø - ö */
    0x00f8, 0x01f5, /* ø - ǵ */
    0x0250, 0x02a8, /* ɐ - ʨ */
    0x038e, 0x03a1, /* Ύ - Ρ */
    0x03a3, 0x03ce, /* Σ - ώ */
    0x03d0, 0x03d6, /* ϐ - ϖ */
    0x03e2, 0x03f3, /* Ϣ - ϳ */
    0x0490, 0x04c4, /* Ґ - ӄ */
    0x0561, 0x0587, /* ա - և */
    0x05d0, 0x05ea, /* א - ת */
    0x05f0, 0x05f2, /* װ - ײ */
    0x0621, 0x063a, /* ء - غ */
    0x0640, 0x064a, /* ـ - ي */
    0x0671, 0x06b7, /* ٱ - ڷ */
    0x06ba, 0x06be, /* ں - ھ */
    0x06c0, 0x06ce, /* ۀ - ێ */
    0x06d0, 0x06d3, /* ې - ۓ */
    0x0905, 0x0939, /* अ - ह */
    0x0958, 0x0961, /* क़ - ॡ */
    0x0985, 0x098c, /* অ - ঌ */
    0x098f, 0x0990, /* এ - ঐ */
    0x0993, 0x09a8, /* ও - ন */
    0x09aa, 0x09b0, /* প - র */
    0x09b6, 0x09b9, /* শ - হ */
    0x09dc, 0x09dd, /* ড় - ঢ় */
    0x09df, 0x09e1, /* য় - ৡ */
    0x09f0, 0x09f1, /* ৰ - ৱ */
    0x0a05, 0x0a0a, /* ਅ - ਊ */
    0x0a0f, 0x0a10, /* ਏ - ਐ */
    0x0a13, 0x0a28, /* ਓ - ਨ */
    0x0a2a, 0x0a30, /* ਪ - ਰ */
    0x0a32, 0x0a33, /* ਲ - ਲ਼ */
    0x0a35, 0x0a36, /* ਵ - ਸ਼ */
    0x0a38, 0x0a39, /* ਸ - ਹ */
    0x0a59, 0x0a5c, /* ਖ਼ - ੜ */
    0x0a85, 0x0a8b, /* અ - ઋ */
    0x0a8f, 0x0a91, /* એ - ઑ */
    0x0a93, 0x0aa8, /* ઓ - ન */
    0x0aaa, 0x0ab0, /* પ - ર */
    0x0ab2, 0x0ab3, /* લ - ળ */
    0x0ab5, 0x0ab9, /* વ - હ */
    0x0b05, 0x0b0c, /* ଅ - ଌ */
    0x0b0f, 0x0b10, /* ଏ - ଐ */
    0x0b13, 0x0b28, /* ଓ - ନ */
    0x0b2a, 0x0b30, /* ପ - ର */
    0x0b32, 0x0b33, /* ଲ - ଳ */
    0x0b36, 0x0b39, /* ଶ - ହ */
    0x0b5c, 0x0b5d, /* ଡ଼ - ଢ଼ */
    0x0b5f, 0x0b61, /* ୟ - ୡ */
    0x0b85, 0x0b8a, /* அ - ஊ */
    0x0b8e, 0x0b90, /* எ - ஐ */
    0x0b92, 0x0b95, /* ஒ - க */
    0x0b99, 0x0b9a, /* ங - ச */
    0x0b9e, 0x0b9f, /* ஞ - ட */
    0x0ba3, 0x0ba4, /* ண - த */
    0x0ba8, 0x0baa, /* ந - ப */
    0x0bae, 0x0bb5, /* ம - வ */
    0x0bb7, 0x0bb9, /* ஷ - ஹ */
    0x0c05, 0x0c0c, /* అ - ఌ */
    0x0c0e, 0x0c10, /* ఎ - ఐ */
    0x0c12, 0x0c28, /* ఒ - న */
    0x0c2a, 0x0c33, /* ప - ళ */
    0x0c35, 0x0c39, /* వ - హ */
    0x0c60, 0x0c61, /* ౠ - ౡ */
    0x0c85, 0x0c8c, /* ಅ - ಌ */
    0x0c8e, 0x0c90, /* ಎ - ಐ */
    0x0c92, 0x0ca8, /* ಒ - ನ */
    0x0caa, 0x0cb3, /* ಪ - ಳ */
    0x0cb5, 0x0cb9, /* ವ - ಹ */
    0x0ce0, 0x0ce1, /* ೠ - ೡ */
    0x0d05, 0x0d0c, /* അ - ഌ */
    0x0d0e, 0x0d10, /* എ - ഐ */
    0x0d12, 0x0d28, /* ഒ - ന */
    0x0d2a, 0x0d39, /* പ - ഹ */
    0x0d60, 0x0d61, /* ൠ - ൡ */
    0x0e01, 0x0e30, /* ก - ะ */
    0x0e32, 0x0e33, /* า - ำ */
    0x0e40, 0x0e46, /* เ - ๆ */
    0x0e5a, 0x0e5b, /* ๚ - ๛ */
    0x0e81, 0x0e82, /* ກ - ຂ */
    0x0e87, 0x0e88, /* ງ - ຈ */
    0x0e94, 0x0e97, /* ດ - ທ */
    0x0e99, 0x0e9f, /* ນ - ຟ */
    0x0ea1, 0x0ea3, /* ມ - ຣ */
    0x0eaa, 0x0eab, /* ສ - ຫ */
    0x0ead, 0x0eae, /* ອ - ຮ */
    0x0eb2, 0x0eb3, /* າ - ຳ */
    0x0ec0, 0x0ec4, /* ເ - ໄ */
    0x0edc, 0x0edd, /* ໜ - ໝ */
    0x0f18, 0x0f19, /* ༘ - ༙ */
    0x0f40, 0x0f47, /* ཀ - ཇ */
    0x0f49, 0x0f69, /* ཉ - ཀྵ */
    0x10d0, 0x10f6, /* ა - ჶ */
    0x1100, 0x1159, /* ᄀ - ᅙ */
    0x115f, 0x11a2, /* ᅟ - ᆢ */
    0x11a8, 0x11f9, /* ᆨ - ᇹ */
    0x1e00, 0x1e9b, /* Ḁ - ẛ */
    0x1f50, 0x1f57, /* ὐ - ὗ */
    0x1f80, 0x1fb4, /* ᾀ - ᾴ */
    0x1fb6, 0x1fbc, /* ᾶ - ᾼ */
    0x1fc2, 0x1fc4, /* ῂ - ῄ */
    0x1fc6, 0x1fcc, /* ῆ - ῌ */
    0x1fd0, 0x1fd3, /* ῐ - ΐ */
    0x1fd6, 0x1fdb, /* ῖ - Ί */
    0x1fe0, 0x1fec, /* ῠ - Ῥ */
    0x1ff2, 0x1ff4, /* ῲ - ῴ */
    0x1ff6, 0x1ffc, /* ῶ - ῼ */
    0x210a, 0x2113, /* ℊ - ℓ */
    0x2115, 0x211d, /* ℕ - ℝ */
    0x2120, 0x2122, /* ℠ - ™ */
    0x212a, 0x2131, /* K - ℱ */
    0x2133, 0x2138, /* ℳ - ℸ */
    0x3041, 0x3094, /* ぁ - ゔ */
    0x30a1, 0x30fa, /* ァ - ヺ */
    0x3105, 0x312c, /* ㄅ - ㄬ */
    0x3131, 0x318e, /* ㄱ - ㆎ */
    0x3192, 0x319f, /* ㆒ - ㆟ */
    0x3260, 0x327b, /* ㉠ - ㉻ */
    0x328a, 0x32b0, /* ㊊ - ㊰ */
    0x32d0, 0x32fe, /* ㋐ - ㋾ */
    0x3300, 0x3357, /* ㌀ - ㍗ */
    0x3371, 0x3376, /* ㍱ - ㍶ */
    0x337b, 0x3394, /* ㍻ - ㎔ */
    0x3399, 0x339e, /* ㎙ - ㎞ */
    0x33a9, 0x33ad, /* ㎩ - ㎭ */
    0x33b0, 0x33c1, /* ㎰ - ㏁ */
    0x33c3, 0x33c5, /* ㏃ - ㏅ */
    0x33c7, 0x33d7, /* ㏇ - ㏗ */
    0x33d9, 0x33dd, /* ㏙ - ㏝ */
    0x4e00, 0x9fff, /* 一 - 鿿 */
    0xac00, 0xd7a3, /* 가 - 힣 */
    0xf900, 0xfb06, /* 豈 - ﬆ */
    0xfb13, 0xfb17, /* ﬓ - ﬗ */
    0xfb1f, 0xfb28, /* ײַ - ﬨ */
    0xfb2a, 0xfb36, /* שׁ - זּ */
    0xfb38, 0xfb3c, /* טּ - לּ */
    0xfb40, 0xfb41, /* נּ - סּ */
    0xfb43, 0xfb44, /* ףּ - פּ */
    0xfb46, 0xfbb1, /* צּ - ﮱ */
    0xfbd3, 0xfd3d, /* ﯓ - ﴽ */
    0xfd50, 0xfd8f, /* ﵐ - ﶏ */
    0xfd92, 0xfdc7, /* ﶒ - ﷇ */
    0xfdf0, 0xfdf9, /* ﷰ - ﷹ */
    0xfe70, 0xfe72, /* ﹰ - ﹲ */
    0xfe76, 0xfefc, /* ﹶ - ﻼ */
    0xff66, 0xff6f, /* ｦ - ｯ */
    0xff71, 0xff9d, /* ｱ - ﾝ */
    0xffa0, 0xffbe, /* ﾠ - ﾾ */
    0xffc2, 0xffc7, /* ￂ - ￇ */
    0xffca, 0xffcf, /* ￊ - ￏ */
    0xffd2, 0xffd7, /* ￒ - ￗ */
    0xffda, 0xffdc, /* ￚ - ￜ */
};

/*
 * alpha singlets -
 *	only covers ranges not in lower||upper
 */
static Rune __alpha1[] = {
    0x00aa, /* ª */
    0x00b5, /* µ */
    0x00ba, /* º */
    0x03da, /* Ϛ */
    0x03dc, /* Ϝ */
    0x03de, /* Ϟ */
    0x03e0, /* Ϡ */
    0x06d5, /* ە */
    0x09b2, /* ল */
    0x0a5e, /* ਫ਼ */
    0x0a8d, /* ઍ */
    0x0ae0, /* ૠ */
    0x0b9c, /* ஜ */
    0x0cde, /* ೞ */
    0x0e4f, /* ๏ */
    0x0e84, /* ຄ */
    0x0e8a, /* ຊ */
    0x0e8d, /* ຍ */
    0x0ea5, /* ລ */
    0x0ea7, /* ວ */
    0x0eb0, /* ະ */
    0x0ebd, /* ຽ */
    0x1fbe, /* ι */
    0x207f, /* ⁿ */
    0x20a8, /* ₨ */
    0x2102, /* ℂ */
    0x2107, /* ℇ */
    0x2124, /* ℤ */
    0x2126, /* Ω */
    0x2128, /* ℨ */
    0xfb3e, /* מּ */
    0xfe74, /* ﹴ */
};

/*
 * space ranges
 */
static Rune __space2[] = {
    0x0009, 0x000a, /* tab and newline */
    0x0020, 0x0020, /* space */
    0x00a0, 0x00a0, /*   */
    0x2000, 0x200b, /*   - ​ */
    0x2028, 0x2029, /*   -   */
    0x3000, 0x3000, /* 　 */
    0xfeff, 0xfeff, /* ﻿ */
};

/*
 * lower case ranges
 *	3rd col is conversion excess 500
 */
static Rune __toupper2[] = {
    0x0061, 0x007a, 468, /* a-z A-Z */
    0x00e0, 0x00f6, 468, /* à-ö À-Ö */
    0x00f8, 0x00fe, 468, /* ø-þ Ø-Þ */
    0x0256, 0x0257, 295, /* ɖ-ɗ Ɖ-Ɗ */
    0x0258, 0x0259, 298, /* ɘ-ə Ǝ-Ə */
    0x028a, 0x028b, 283, /* ʊ-ʋ Ʊ-Ʋ */
    0x03ad, 0x03af, 463, /* έ-ί Έ-Ί */
    0x03b1, 0x03c1, 468, /* α-ρ Α-Ρ */
    0x03c3, 0x03cb, 468, /* σ-ϋ Σ-Ϋ */
    0x03cd, 0x03ce, 437, /* ύ-ώ Ύ-Ώ */
    0x0430, 0x044f, 468, /* а-я А-Я */
    0x0451, 0x045c, 420, /* ё-ќ Ё-Ќ */
    0x045e, 0x045f, 420, /* ў-џ Ў-Џ */
    0x0561, 0x0586, 452, /* ա-ֆ Ա-Ֆ */
    0x1f00, 0x1f07, 508, /* ἀ-ἇ Ἀ-Ἇ */
    0x1f10, 0x1f15, 508, /* ἐ-ἕ Ἐ-Ἕ */
    0x1f20, 0x1f27, 508, /* ἠ-ἧ Ἠ-Ἧ */
    0x1f30, 0x1f37, 508, /* ἰ-ἷ Ἰ-Ἷ */
    0x1f40, 0x1f45, 508, /* ὀ-ὅ Ὀ-Ὅ */
    0x1f60, 0x1f67, 508, /* ὠ-ὧ Ὠ-Ὧ */
    0x1f70, 0x1f71, 574, /* ὰ-ά Ὰ-Ά */
    0x1f72, 0x1f75, 586, /* ὲ-ή Ὲ-Ή */
    0x1f76, 0x1f77, 600, /* ὶ-ί Ὶ-Ί */
    0x1f78, 0x1f79, 628, /* ὸ-ό Ὸ-Ό */
    0x1f7a, 0x1f7b, 612, /* ὺ-ύ Ὺ-Ύ */
    0x1f7c, 0x1f7d, 626, /* ὼ-ώ Ὼ-Ώ */
    0x1f80, 0x1f87, 508, /* ᾀ-ᾇ ᾈ-ᾏ */
    0x1f90, 0x1f97, 508, /* ᾐ-ᾗ ᾘ-ᾟ */
    0x1fa0, 0x1fa7, 508, /* ᾠ-ᾧ ᾨ-ᾯ */
    0x1fb0, 0x1fb1, 508, /* ᾰ-ᾱ Ᾰ-Ᾱ */
    0x1fd0, 0x1fd1, 508, /* ῐ-ῑ Ῐ-Ῑ */
    0x1fe0, 0x1fe1, 508, /* ῠ-ῡ Ῠ-Ῡ */
    0x2170, 0x217f, 484, /* ⅰ-ⅿ Ⅰ-Ⅿ */
    0x24d0, 0x24e9, 474, /* ⓐ-ⓩ Ⓐ-Ⓩ */
    0xff41, 0xff5a, 468, /* ａ-ｚ Ａ-Ｚ */
};

/*
 * lower case singlets
 *	2nd col is conversion excess 500
 */
static Rune __toupper1[] = {
    0x00ff, 621, /* ÿ Ÿ */
    0x0101, 499, /* ā Ā */
    0x0103, 499, /* ă Ă */
    0x0105, 499, /* ą Ą */
    0x0107, 499, /* ć Ć */
    0x0109, 499, /* ĉ Ĉ */
    0x010b, 499, /* ċ Ċ */
    0x010d, 499, /* č Č */
    0x010f, 499, /* ď Ď */
    0x0111, 499, /* đ Đ */
    0x0113, 499, /* ē Ē */
    0x0115, 499, /* ĕ Ĕ */
    0x0117, 499, /* ė Ė */
    0x0119, 499, /* ę Ę */
    0x011b, 499, /* ě Ě */
    0x011d, 499, /* ĝ Ĝ */
    0x011f, 499, /* ğ Ğ */
    0x0121, 499, /* ġ Ġ */
    0x0123, 499, /* ģ Ģ */
    0x0125, 499, /* ĥ Ĥ */
    0x0127, 499, /* ħ Ħ */
    0x0129, 499, /* ĩ Ĩ */
    0x012b, 499, /* ī Ī */
    0x012d, 499, /* ĭ Ĭ */
    0x012f, 499, /* į Į */
    0x0131, 268, /* ı I */
    0x0133, 499, /* ĳ Ĳ */
    0x0135, 499, /* ĵ Ĵ */
    0x0137, 499, /* ķ Ķ */
    0x013a, 499, /* ĺ Ĺ */
    0x013c, 499, /* ļ Ļ */
    0x013e, 499, /* ľ Ľ */
    0x0140, 499, /* ŀ Ŀ */
    0x0142, 499, /* ł Ł */
    0x0144, 499, /* ń Ń */
    0x0146, 499, /* ņ Ņ */
    0x0148, 499, /* ň Ň */
    0x014b, 499, /* ŋ Ŋ */
    0x014d, 499, /* ō Ō */
    0x014f, 499, /* ŏ Ŏ */
    0x0151, 499, /* ő Ő */
    0x0153, 499, /* œ Œ */
    0x0155, 499, /* ŕ Ŕ */
    0x0157, 499, /* ŗ Ŗ */
    0x0159, 499, /* ř Ř */
    0x015b, 499, /* ś Ś */
    0x015d, 499, /* ŝ Ŝ */
    0x015f, 499, /* ş Ş */
    0x0161, 499, /* š Š */
    0x0163, 499, /* ţ Ţ */
    0x0165, 499, /* ť Ť */
    0x0167, 499, /* ŧ Ŧ */
    0x0169, 499, /* ũ Ũ */
    0x016b, 499, /* ū Ū */
    0x016d, 499, /* ŭ Ŭ */
    0x016f, 499, /* ů Ů */
    0x0171, 499, /* ű Ű */
    0x0173, 499, /* ų Ų */
    0x0175, 499, /* ŵ Ŵ */
    0x0177, 499, /* ŷ Ŷ */
    0x017a, 499, /* ź Ź */
    0x017c, 499, /* ż Ż */
    0x017e, 499, /* ž Ž */
    0x017f, 200, /* ſ S */
    0x0183, 499, /* ƃ Ƃ */
    0x0185, 499, /* ƅ Ƅ */
    0x0188, 499, /* ƈ Ƈ */
    0x018c, 499, /* ƌ Ƌ */
    0x0192, 499, /* ƒ Ƒ */
    0x0199, 499, /* ƙ Ƙ */
    0x01a1, 499, /* ơ Ơ */
    0x01a3, 499, /* ƣ Ƣ */
    0x01a5, 499, /* ƥ Ƥ */
    0x01a8, 499, /* ƨ Ƨ */
    0x01ad, 499, /* ƭ Ƭ */
    0x01b0, 499, /* ư Ư */
    0x01b4, 499, /* ƴ Ƴ */
    0x01b6, 499, /* ƶ Ƶ */
    0x01b9, 499, /* ƹ Ƹ */
    0x01bd, 499, /* ƽ Ƽ */
    0x01c5, 499, /* ǅ Ǆ */
    0x01c6, 498, /* ǆ Ǆ */
    0x01c8, 499, /* ǈ Ǉ */
    0x01c9, 498, /* ǉ Ǉ */
    0x01cb, 499, /* ǋ Ǌ */
    0x01cc, 498, /* ǌ Ǌ */
    0x01ce, 499, /* ǎ Ǎ */
    0x01d0, 499, /* ǐ Ǐ */
    0x01d2, 499, /* ǒ Ǒ */
    0x01d4, 499, /* ǔ Ǔ */
    0x01d6, 499, /* ǖ Ǖ */
    0x01d8, 499, /* ǘ Ǘ */
    0x01da, 499, /* ǚ Ǚ */
    0x01dc, 499, /* ǜ Ǜ */
    0x01df, 499, /* ǟ Ǟ */
    0x01e1, 499, /* ǡ Ǡ */
    0x01e3, 499, /* ǣ Ǣ */
    0x01e5, 499, /* ǥ Ǥ */
    0x01e7, 499, /* ǧ Ǧ */
    0x01e9, 499, /* ǩ Ǩ */
    0x01eb, 499, /* ǫ Ǫ */
    0x01ed, 499, /* ǭ Ǭ */
    0x01ef, 499, /* ǯ Ǯ */
    0x01f2, 499, /* ǲ Ǳ */
    0x01f3, 498, /* ǳ Ǳ */
    0x01f5, 499, /* ǵ Ǵ */
    0x01fb, 499, /* ǻ Ǻ */
    0x01fd, 499, /* ǽ Ǽ */
    0x01ff, 499, /* ǿ Ǿ */
    0x0201, 499, /* ȁ Ȁ */
    0x0203, 499, /* ȃ Ȃ */
    0x0205, 499, /* ȅ Ȅ */
    0x0207, 499, /* ȇ Ȇ */
    0x0209, 499, /* ȉ Ȉ */
    0x020b, 499, /* ȋ Ȋ */
    0x020d, 499, /* ȍ Ȍ */
    0x020f, 499, /* ȏ Ȏ */
    0x0211, 499, /* ȑ Ȑ */
    0x0213, 499, /* ȓ Ȓ */
    0x0215, 499, /* ȕ Ȕ */
    0x0217, 499, /* ȗ Ȗ */
    0x0253, 290, /* ɓ Ɓ */
    0x0254, 294, /* ɔ Ɔ */
    0x025b, 297, /* ɛ Ɛ */
    0x0260, 295, /* ɠ Ɠ */
    0x0263, 293, /* ɣ Ɣ */
    0x0268, 291, /* ɨ Ɨ */
    0x0269, 289, /* ɩ Ɩ */
    0x026f, 289, /* ɯ Ɯ */
    0x0272, 287, /* ɲ Ɲ */
    0x0283, 282, /* ʃ Ʃ */
    0x0288, 282, /* ʈ Ʈ */
    0x0292, 281, /* ʒ Ʒ */
    0x03ac, 462, /* ά Ά */
    0x03cc, 436, /* ό Ό */
    0x03d0, 438, /* ϐ Β */
    0x03d1, 443, /* ϑ Θ */
    0x03d5, 453, /* ϕ Φ */
    0x03d6, 446, /* ϖ Π */
    0x03e3, 499, /* ϣ Ϣ */
    0x03e5, 499, /* ϥ Ϥ */
    0x03e7, 499, /* ϧ Ϧ */
    0x03e9, 499, /* ϩ Ϩ */
    0x03eb, 499, /* ϫ Ϫ */
    0x03ed, 499, /* ϭ Ϭ */
    0x03ef, 499, /* ϯ Ϯ */
    0x03f0, 414, /* ϰ Κ */
    0x03f1, 420, /* ϱ Ρ */
    0x0461, 499, /* ѡ Ѡ */
    0x0463, 499, /* ѣ Ѣ */
    0x0465, 499, /* ѥ Ѥ */
    0x0467, 499, /* ѧ Ѧ */
    0x0469, 499, /* ѩ Ѩ */
    0x046b, 499, /* ѫ Ѫ */
    0x046d, 499, /* ѭ Ѭ */
    0x046f, 499, /* ѯ Ѯ */
    0x0471, 499, /* ѱ Ѱ */
    0x0473, 499, /* ѳ Ѳ */
    0x0475, 499, /* ѵ Ѵ */
    0x0477, 499, /* ѷ Ѷ */
    0x0479, 499, /* ѹ Ѹ */
    0x047b, 499, /* ѻ Ѻ */
    0x047d, 499, /* ѽ Ѽ */
    0x047f, 499, /* ѿ Ѿ */
    0x0481, 499, /* ҁ Ҁ */
    0x0491, 499, /* ґ Ґ */
    0x0493, 499, /* ғ Ғ */
    0x0495, 499, /* ҕ Ҕ */
    0x0497, 499, /* җ Җ */
    0x0499, 499, /* ҙ Ҙ */
    0x049b, 499, /* қ Қ */
    0x049d, 499, /* ҝ Ҝ */
    0x049f, 499, /* ҟ Ҟ */
    0x04a1, 499, /* ҡ Ҡ */
    0x04a3, 499, /* ң Ң */
    0x04a5, 499, /* ҥ Ҥ */
    0x04a7, 499, /* ҧ Ҧ */
    0x04a9, 499, /* ҩ Ҩ */
    0x04ab, 499, /* ҫ Ҫ */
    0x04ad, 499, /* ҭ Ҭ */
    0x04af, 499, /* ү Ү */
    0x04b1, 499, /* ұ Ұ */
    0x04b3, 499, /* ҳ Ҳ */
    0x04b5, 499, /* ҵ Ҵ */
    0x04b7, 499, /* ҷ Ҷ */
    0x04b9, 499, /* ҹ Ҹ */
    0x04bb, 499, /* һ Һ */
    0x04bd, 499, /* ҽ Ҽ */
    0x04bf, 499, /* ҿ Ҿ */
    0x04c2, 499, /* ӂ Ӂ */
    0x04c4, 499, /* ӄ Ӄ */
    0x04c8, 499, /* ӈ Ӈ */
    0x04cc, 499, /* ӌ Ӌ */
    0x04d1, 499, /* ӑ Ӑ */
    0x04d3, 499, /* ӓ Ӓ */
    0x04d5, 499, /* ӕ Ӕ */
    0x04d7, 499, /* ӗ Ӗ */
    0x04d9, 499, /* ә Ә */
    0x04db, 499, /* ӛ Ӛ */
    0x04dd, 499, /* ӝ Ӝ */
    0x04df, 499, /* ӟ Ӟ */
    0x04e1, 499, /* ӡ Ӡ */
    0x04e3, 499, /* ӣ Ӣ */
    0x04e5, 499, /* ӥ Ӥ */
    0x04e7, 499, /* ӧ Ӧ */
    0x04e9, 499, /* ө Ө */
    0x04eb, 499, /* ӫ Ӫ */
    0x04ef, 499, /* ӯ Ӯ */
    0x04f1, 499, /* ӱ Ӱ */
    0x04f3, 499, /* ӳ Ӳ */
    0x04f5, 499, /* ӵ Ӵ */
    0x04f9, 499, /* ӹ Ӹ */
    0x1e01, 499, /* ḁ Ḁ */
    0x1e03, 499, /* ḃ Ḃ */
    0x1e05, 499, /* ḅ Ḅ */
    0x1e07, 499, /* ḇ Ḇ */
    0x1e09, 499, /* ḉ Ḉ */
    0x1e0b, 499, /* ḋ Ḋ */
    0x1e0d, 499, /* ḍ Ḍ */
    0x1e0f, 499, /* ḏ Ḏ */
    0x1e11, 499, /* ḑ Ḑ */
    0x1e13, 499, /* ḓ Ḓ */
    0x1e15, 499, /* ḕ Ḕ */
    0x1e17, 499, /* ḗ Ḗ */
    0x1e19, 499, /* ḙ Ḙ */
    0x1e1b, 499, /* ḛ Ḛ */
    0x1e1d, 499, /* ḝ Ḝ */
    0x1e1f, 499, /* ḟ Ḟ */
    0x1e21, 499, /* ḡ Ḡ */
    0x1e23, 499, /* ḣ Ḣ */
    0x1e25, 499, /* ḥ Ḥ */
    0x1e27, 499, /* ḧ Ḧ */
    0x1e29, 499, /* ḩ Ḩ */
    0x1e2b, 499, /* ḫ Ḫ */
    0x1e2d, 499, /* ḭ Ḭ */
    0x1e2f, 499, /* ḯ Ḯ */
    0x1e31, 499, /* ḱ Ḱ */
    0x1e33, 499, /* ḳ Ḳ */
    0x1e35, 499, /* ḵ Ḵ */
    0x1e37, 499, /* ḷ Ḷ */
    0x1e39, 499, /* ḹ Ḹ */
    0x1e3b, 499, /* ḻ Ḻ */
    0x1e3d, 499, /* ḽ Ḽ */
    0x1e3f, 499, /* ḿ Ḿ */
    0x1e41, 499, /* ṁ Ṁ */
    0x1e43, 499, /* ṃ Ṃ */
    0x1e45, 499, /* ṅ Ṅ */
    0x1e47, 499, /* ṇ Ṇ */
    0x1e49, 499, /* ṉ Ṉ */
    0x1e4b, 499, /* ṋ Ṋ */
    0x1e4d, 499, /* ṍ Ṍ */
    0x1e4f, 499, /* ṏ Ṏ */
    0x1e51, 499, /* ṑ Ṑ */
    0x1e53, 499, /* ṓ Ṓ */
    0x1e55, 499, /* ṕ Ṕ */
    0x1e57, 499, /* ṗ Ṗ */
    0x1e59, 499, /* ṙ Ṙ */
    0x1e5b, 499, /* ṛ Ṛ */
    0x1e5d, 499, /* ṝ Ṝ */
    0x1e5f, 499, /* ṟ Ṟ */
    0x1e61, 499, /* ṡ Ṡ */
    0x1e63, 499, /* ṣ Ṣ */
    0x1e65, 499, /* ṥ Ṥ */
    0x1e67, 499, /* ṧ Ṧ */
    0x1e69, 499, /* ṩ Ṩ */
    0x1e6b, 499, /* ṫ Ṫ */
    0x1e6d, 499, /* ṭ Ṭ */
    0x1e6f, 499, /* ṯ Ṯ */
    0x1e71, 499, /* ṱ Ṱ */
    0x1e73, 499, /* ṳ Ṳ */
    0x1e75, 499, /* ṵ Ṵ */
    0x1e77, 499, /* ṷ Ṷ */
    0x1e79, 499, /* ṹ Ṹ */
    0x1e7b, 499, /* ṻ Ṻ */
    0x1e7d, 499, /* ṽ Ṽ */
    0x1e7f, 499, /* ṿ Ṿ */
    0x1e81, 499, /* ẁ Ẁ */
    0x1e83, 499, /* ẃ Ẃ */
    0x1e85, 499, /* ẅ Ẅ */
    0x1e87, 499, /* ẇ Ẇ */
    0x1e89, 499, /* ẉ Ẉ */
    0x1e8b, 499, /* ẋ Ẋ */
    0x1e8d, 499, /* ẍ Ẍ */
    0x1e8f, 499, /* ẏ Ẏ */
    0x1e91, 499, /* ẑ Ẑ */
    0x1e93, 499, /* ẓ Ẓ */
    0x1e95, 499, /* ẕ Ẕ */
    0x1ea1, 499, /* ạ Ạ */
    0x1ea3, 499, /* ả Ả */
    0x1ea5, 499, /* ấ Ấ */
    0x1ea7, 499, /* ầ Ầ */
    0x1ea9, 499, /* ẩ Ẩ */
    0x1eab, 499, /* ẫ Ẫ */
    0x1ead, 499, /* ậ Ậ */
    0x1eaf, 499, /* ắ Ắ */
    0x1eb1, 499, /* ằ Ằ */
    0x1eb3, 499, /* ẳ Ẳ */
    0x1eb5, 499, /* ẵ Ẵ */
    0x1eb7, 499, /* ặ Ặ */
    0x1eb9, 499, /* ẹ Ẹ */
    0x1ebb, 499, /* ẻ Ẻ */
    0x1ebd, 499, /* ẽ Ẽ */
    0x1ebf, 499, /* ế Ế */
    0x1ec1, 499, /* ề Ề */
    0x1ec3, 499, /* ể Ể */
    0x1ec5, 499, /* ễ Ễ */
    0x1ec7, 499, /* ệ Ệ */
    0x1ec9, 499, /* ỉ Ỉ */
    0x1ecb, 499, /* ị Ị */
    0x1ecd, 499, /* ọ Ọ */
    0x1ecf, 499, /* ỏ Ỏ */
    0x1ed1, 499, /* ố Ố */
    0x1ed3, 499, /* ồ Ồ */
    0x1ed5, 499, /* ổ Ổ */
    0x1ed7, 499, /* ỗ Ỗ */
    0x1ed9, 499, /* ộ Ộ */
    0x1edb, 499, /* ớ Ớ */
    0x1edd, 499, /* ờ Ờ */
    0x1edf, 499, /* ở Ở */
    0x1ee1, 499, /* ỡ Ỡ */
    0x1ee3, 499, /* ợ Ợ */
    0x1ee5, 499, /* ụ Ụ */
    0x1ee7, 499, /* ủ Ủ */
    0x1ee9, 499, /* ứ Ứ */
    0x1eeb, 499, /* ừ Ừ */
    0x1eed, 499, /* ử Ử */
    0x1eef, 499, /* ữ Ữ */
    0x1ef1, 499, /* ự Ự */
    0x1ef3, 499, /* ỳ Ỳ */
    0x1ef5, 499, /* ỵ Ỵ */
    0x1ef7, 499, /* ỷ Ỷ */
    0x1ef9, 499, /* ỹ Ỹ */
    0x1f51, 508, /* ὑ Ὑ */
    0x1f53, 508, /* ὓ Ὓ */
    0x1f55, 508, /* ὕ Ὕ */
    0x1f57, 508, /* ὗ Ὗ */
    0x1fb3, 509, /* ᾳ ᾼ */
    0x1fc3, 509, /* ῃ ῌ */
    0x1fe5, 507, /* ῥ Ῥ */
    0x1ff3, 509, /* ῳ ῼ */
};

/*
 * upper case ranges
 *	3rd col is conversion excess 500
 */
static Rune __tolower2[] = {
    0x0041, 0x005a, 532, /* A-Z a-z */
    0x00c0, 0x00d6, 532, /* À-Ö à-ö */
    0x00d8, 0x00de, 532, /* Ø-Þ ø-þ */
    0x0189, 0x018a, 705, /* Ɖ-Ɗ ɖ-ɗ */
    0x018e, 0x018f, 702, /* Ǝ-Ə ɘ-ə */
    0x01b1, 0x01b2, 717, /* Ʊ-Ʋ ʊ-ʋ */
    0x0388, 0x038a, 537, /* Έ-Ί έ-ί */
    0x038e, 0x038f, 563, /* Ύ-Ώ ύ-ώ */
    0x0391, 0x03a1, 532, /* Α-Ρ α-ρ */
    0x03a3, 0x03ab, 532, /* Σ-Ϋ σ-ϋ */
    0x0401, 0x040c, 580, /* Ё-Ќ ё-ќ */
    0x040e, 0x040f, 580, /* Ў-Џ ў-џ */
    0x0410, 0x042f, 532, /* А-Я а-я */
    0x0531, 0x0556, 548, /* Ա-Ֆ ա-ֆ */
    0x10a0, 0x10c5, 548, /* Ⴀ-Ⴥ ა-ჵ */
    0x1f08, 0x1f0f, 492, /* Ἀ-Ἇ ἀ-ἇ */
    0x1f18, 0x1f1d, 492, /* Ἐ-Ἕ ἐ-ἕ */
    0x1f28, 0x1f2f, 492, /* Ἠ-Ἧ ἠ-ἧ */
    0x1f38, 0x1f3f, 492, /* Ἰ-Ἷ ἰ-ἷ */
    0x1f48, 0x1f4d, 492, /* Ὀ-Ὅ ὀ-ὅ */
    0x1f68, 0x1f6f, 492, /* Ὠ-Ὧ ὠ-ὧ */
    0x1f88, 0x1f8f, 492, /* ᾈ-ᾏ ᾀ-ᾇ */
    0x1f98, 0x1f9f, 492, /* ᾘ-ᾟ ᾐ-ᾗ */
    0x1fa8, 0x1faf, 492, /* ᾨ-ᾯ ᾠ-ᾧ */
    0x1fb8, 0x1fb9, 492, /* Ᾰ-Ᾱ ᾰ-ᾱ */
    0x1fba, 0x1fbb, 426, /* Ὰ-Ά ὰ-ά */
    0x1fc8, 0x1fcb, 414, /* Ὲ-Ή ὲ-ή */
    0x1fd8, 0x1fd9, 492, /* Ῐ-Ῑ ῐ-ῑ */
    0x1fda, 0x1fdb, 400, /* Ὶ-Ί ὶ-ί */
    0x1fe8, 0x1fe9, 492, /* Ῠ-Ῡ ῠ-ῡ */
    0x1fea, 0x1feb, 388, /* Ὺ-Ύ ὺ-ύ */
    0x1ff8, 0x1ff9, 372, /* Ὸ-Ό ὸ-ό */
    0x1ffa, 0x1ffb, 374, /* Ὼ-Ώ ὼ-ώ */
    0x2160, 0x216f, 516, /* Ⅰ-Ⅿ ⅰ-ⅿ */
    0x24b6, 0x24cf, 526, /* Ⓐ-Ⓩ ⓐ-ⓩ */
    0xff21, 0xff3a, 532, /* Ａ-Ｚ ａ-ｚ */
};

/*
 * upper case singlets
 *	2nd col is conversion excess 500
 */
static Rune __tolower1[] = {
    0x0100, 501, /* Ā ā */
    0x0102, 501, /* Ă ă */
    0x0104, 501, /* Ą ą */
    0x0106, 501, /* Ć ć */
    0x0108, 501, /* Ĉ ĉ */
    0x010a, 501, /* Ċ ċ */
    0x010c, 501, /* Č č */
    0x010e, 501, /* Ď ď */
    0x0110, 501, /* Đ đ */
    0x0112, 501, /* Ē ē */
    0x0114, 501, /* Ĕ ĕ */
    0x0116, 501, /* Ė ė */
    0x0118, 501, /* Ę ę */
    0x011a, 501, /* Ě ě */
    0x011c, 501, /* Ĝ ĝ */
    0x011e, 501, /* Ğ ğ */
    0x0120, 501, /* Ġ ġ */
    0x0122, 501, /* Ģ ģ */
    0x0124, 501, /* Ĥ ĥ */
    0x0126, 501, /* Ħ ħ */
    0x0128, 501, /* Ĩ ĩ */
    0x012a, 501, /* Ī ī */
    0x012c, 501, /* Ĭ ĭ */
    0x012e, 501, /* Į į */
    0x0130, 301, /* İ i */
    0x0132, 501, /* Ĳ ĳ */
    0x0134, 501, /* Ĵ ĵ */
    0x0136, 501, /* Ķ ķ */
    0x0139, 501, /* Ĺ ĺ */
    0x013b, 501, /* Ļ ļ */
    0x013d, 501, /* Ľ ľ */
    0x013f, 501, /* Ŀ ŀ */
    0x0141, 501, /* Ł ł */
    0x0143, 501, /* Ń ń */
    0x0145, 501, /* Ņ ņ */
    0x0147, 501, /* Ň ň */
    0x014a, 501, /* Ŋ ŋ */
    0x014c, 501, /* Ō ō */
    0x014e, 501, /* Ŏ ŏ */
    0x0150, 501, /* Ő ő */
    0x0152, 501, /* Œ œ */
    0x0154, 501, /* Ŕ ŕ */
    0x0156, 501, /* Ŗ ŗ */
    0x0158, 501, /* Ř ř */
    0x015a, 501, /* Ś ś */
    0x015c, 501, /* Ŝ ŝ */
    0x015e, 501, /* Ş ş */
    0x0160, 501, /* Š š */
    0x0162, 501, /* Ţ ţ */
    0x0164, 501, /* Ť ť */
    0x0166, 501, /* Ŧ ŧ */
    0x0168, 501, /* Ũ ũ */
    0x016a, 501, /* Ū ū */
    0x016c, 501, /* Ŭ ŭ */
    0x016e, 501, /* Ů ů */
    0x0170, 501, /* Ű ű */
    0x0172, 501, /* Ų ų */
    0x0174, 501, /* Ŵ ŵ */
    0x0176, 501, /* Ŷ ŷ */
    0x0178, 379, /* Ÿ ÿ */
    0x0179, 501, /* Ź ź */
    0x017b, 501, /* Ż ż */
    0x017d, 501, /* Ž ž */
    0x0181, 710, /* Ɓ ɓ */
    0x0182, 501, /* Ƃ ƃ */
    0x0184, 501, /* Ƅ ƅ */
    0x0186, 706, /* Ɔ ɔ */
    0x0187, 501, /* Ƈ ƈ */
    0x018b, 501, /* Ƌ ƌ */
    0x0190, 703, /* Ɛ ɛ */
    0x0191, 501, /* Ƒ ƒ */
    0x0193, 705, /* Ɠ ɠ */
    0x0194, 707, /* Ɣ ɣ */
    0x0196, 711, /* Ɩ ɩ */
    0x0197, 709, /* Ɨ ɨ */
    0x0198, 501, /* Ƙ ƙ */
    0x019c, 711, /* Ɯ ɯ */
    0x019d, 713, /* Ɲ ɲ */
    0x01a0, 501, /* Ơ ơ */
    0x01a2, 501, /* Ƣ ƣ */
    0x01a4, 501, /* Ƥ ƥ */
    0x01a7, 501, /* Ƨ ƨ */
    0x01a9, 718, /* Ʃ ʃ */
    0x01ac, 501, /* Ƭ ƭ */
    0x01ae, 718, /* Ʈ ʈ */
    0x01af, 501, /* Ư ư */
    0x01b3, 501, /* Ƴ ƴ */
    0x01b5, 501, /* Ƶ ƶ */
    0x01b7, 719, /* Ʒ ʒ */
    0x01b8, 501, /* Ƹ ƹ */
    0x01bc, 501, /* Ƽ ƽ */
    0x01c4, 502, /* Ǆ ǆ */
    0x01c5, 501, /* ǅ ǆ */
    0x01c7, 502, /* Ǉ ǉ */
    0x01c8, 501, /* ǈ ǉ */
    0x01ca, 502, /* Ǌ ǌ */
    0x01cb, 501, /* ǋ ǌ */
    0x01cd, 501, /* Ǎ ǎ */
    0x01cf, 501, /* Ǐ ǐ */
    0x01d1, 501, /* Ǒ ǒ */
    0x01d3, 501, /* Ǔ ǔ */
    0x01d5, 501, /* Ǖ ǖ */
    0x01d7, 501, /* Ǘ ǘ */
    0x01d9, 501, /* Ǚ ǚ */
    0x01db, 501, /* Ǜ ǜ */
    0x01de, 501, /* Ǟ ǟ */
    0x01e0, 501, /* Ǡ ǡ */
    0x01e2, 501, /* Ǣ ǣ */
    0x01e4, 501, /* Ǥ ǥ */
    0x01e6, 501, /* Ǧ ǧ */
    0x01e8, 501, /* Ǩ ǩ */
    0x01ea, 501, /* Ǫ ǫ */
    0x01ec, 501, /* Ǭ ǭ */
    0x01ee, 501, /* Ǯ ǯ */
    0x01f1, 502, /* Ǳ ǳ */
    0x01f2, 501, /* ǲ ǳ */
    0x01f4, 501, /* Ǵ ǵ */
    0x01fa, 501, /* Ǻ ǻ */
    0x01fc, 501, /* Ǽ ǽ */
    0x01fe, 501, /* Ǿ ǿ */
    0x0200, 501, /* Ȁ ȁ */
    0x0202, 501, /* Ȃ ȃ */
    0x0204, 501, /* Ȅ ȅ */
    0x0206, 501, /* Ȇ ȇ */
    0x0208, 501, /* Ȉ ȉ */
    0x020a, 501, /* Ȋ ȋ */
    0x020c, 501, /* Ȍ ȍ */
    0x020e, 501, /* Ȏ ȏ */
    0x0210, 501, /* Ȑ ȑ */
    0x0212, 501, /* Ȓ ȓ */
    0x0214, 501, /* Ȕ ȕ */
    0x0216, 501, /* Ȗ ȗ */
    0x0386, 538, /* Ά ά */
    0x038c, 564, /* Ό ό */
    0x03e2, 501, /* Ϣ ϣ */
    0x03e4, 501, /* Ϥ ϥ */
    0x03e6, 501, /* Ϧ ϧ */
    0x03e8, 501, /* Ϩ ϩ */
    0x03ea, 501, /* Ϫ ϫ */
    0x03ec, 501, /* Ϭ ϭ */
    0x03ee, 501, /* Ϯ ϯ */
    0x0460, 501, /* Ѡ ѡ */
    0x0462, 501, /* Ѣ ѣ */
    0x0464, 501, /* Ѥ ѥ */
    0x0466, 501, /* Ѧ ѧ */
    0x0468, 501, /* Ѩ ѩ */
    0x046a, 501, /* Ѫ ѫ */
    0x046c, 501, /* Ѭ ѭ */
    0x046e, 501, /* Ѯ ѯ */
    0x0470, 501, /* Ѱ ѱ */
    0x0472, 501, /* Ѳ ѳ */
    0x0474, 501, /* Ѵ ѵ */
    0x0476, 501, /* Ѷ ѷ */
    0x0478, 501, /* Ѹ ѹ */
    0x047a, 501, /* Ѻ ѻ */
    0x047c, 501, /* Ѽ ѽ */
    0x047e, 501, /* Ѿ ѿ */
    0x0480, 501, /* Ҁ ҁ */
    0x0490, 501, /* Ґ ґ */
    0x0492, 501, /* Ғ ғ */
    0x0494, 501, /* Ҕ ҕ */
    0x0496, 501, /* Җ җ */
    0x0498, 501, /* Ҙ ҙ */
    0x049a, 501, /* Қ қ */
    0x049c, 501, /* Ҝ ҝ */
    0x049e, 501, /* Ҟ ҟ */
    0x04a0, 501, /* Ҡ ҡ */
    0x04a2, 501, /* Ң ң */
    0x04a4, 501, /* Ҥ ҥ */
    0x04a6, 501, /* Ҧ ҧ */
    0x04a8, 501, /* Ҩ ҩ */
    0x04aa, 501, /* Ҫ ҫ */
    0x04ac, 501, /* Ҭ ҭ */
    0x04ae, 501, /* Ү ү */
    0x04b0, 501, /* Ұ ұ */
    0x04b2, 501, /* Ҳ ҳ */
    0x04b4, 501, /* Ҵ ҵ */
    0x04b6, 501, /* Ҷ ҷ */
    0x04b8, 501, /* Ҹ ҹ */
    0x04ba, 501, /* Һ һ */
    0x04bc, 501, /* Ҽ ҽ */
    0x04be, 501, /* Ҿ ҿ */
    0x04c1, 501, /* Ӂ ӂ */
    0x04c3, 501, /* Ӄ ӄ */
    0x04c7, 501, /* Ӈ ӈ */
    0x04cb, 501, /* Ӌ ӌ */
    0x04d0, 501, /* Ӑ ӑ */
    0x04d2, 501, /* Ӓ ӓ */
    0x04d4, 501, /* Ӕ ӕ */
    0x04d6, 501, /* Ӗ ӗ */
    0x04d8, 501, /* Ә ә */
    0x04da, 501, /* Ӛ ӛ */
    0x04dc, 501, /* Ӝ ӝ */
    0x04de, 501, /* Ӟ ӟ */
    0x04e0, 501, /* Ӡ ӡ */
    0x04e2, 501, /* Ӣ ӣ */
    0x04e4, 501, /* Ӥ ӥ */
    0x04e6, 501, /* Ӧ ӧ */
    0x04e8, 501, /* Ө ө */
    0x04ea, 501, /* Ӫ ӫ */
    0x04ee, 501, /* Ӯ ӯ */
    0x04f0, 501, /* Ӱ ӱ */
    0x04f2, 501, /* Ӳ ӳ */
    0x04f4, 501, /* Ӵ ӵ */
    0x04f8, 501, /* Ӹ ӹ */
    0x1e00, 501, /* Ḁ ḁ */
    0x1e02, 501, /* Ḃ ḃ */
    0x1e04, 501, /* Ḅ ḅ */
    0x1e06, 501, /* Ḇ ḇ */
    0x1e08, 501, /* Ḉ ḉ */
    0x1e0a, 501, /* Ḋ ḋ */
    0x1e0c, 501, /* Ḍ ḍ */
    0x1e0e, 501, /* Ḏ ḏ */
    0x1e10, 501, /* Ḑ ḑ */
    0x1e12, 501, /* Ḓ ḓ */
    0x1e14, 501, /* Ḕ ḕ */
    0x1e16, 501, /* Ḗ ḗ */
    0x1e18, 501, /* Ḙ ḙ */
    0x1e1a, 501, /* Ḛ ḛ */
    0x1e1c, 501, /* Ḝ ḝ */
    0x1e1e, 501, /* Ḟ ḟ */
    0x1e20, 501, /* Ḡ ḡ */
    0x1e22, 501, /* Ḣ ḣ */
    0x1e24, 501, /* Ḥ ḥ */
    0x1e26, 501, /* Ḧ ḧ */
    0x1e28, 501, /* Ḩ ḩ */
    0x1e2a, 501, /* Ḫ ḫ */
    0x1e2c, 501, /* Ḭ ḭ */
    0x1e2e, 501, /* Ḯ ḯ */
    0x1e30, 501, /* Ḱ ḱ */
    0x1e32, 501, /* Ḳ ḳ */
    0x1e34, 501, /* Ḵ ḵ */
    0x1e36, 501, /* Ḷ ḷ */
    0x1e38, 501, /* Ḹ ḹ */
    0x1e3a, 501, /* Ḻ ḻ */
    0x1e3c, 501, /* Ḽ ḽ */
    0x1e3e, 501, /* Ḿ ḿ */
    0x1e40, 501, /* Ṁ ṁ */
    0x1e42, 501, /* Ṃ ṃ */
    0x1e44, 501, /* Ṅ ṅ */
    0x1e46, 501, /* Ṇ ṇ */
    0x1e48, 501, /* Ṉ ṉ */
    0x1e4a, 501, /* Ṋ ṋ */
    0x1e4c, 501, /* Ṍ ṍ */
    0x1e4e, 501, /* Ṏ ṏ */
    0x1e50, 501, /* Ṑ ṑ */
    0x1e52, 501, /* Ṓ ṓ */
    0x1e54, 501, /* Ṕ ṕ */
    0x1e56, 501, /* Ṗ ṗ */
    0x1e58, 501, /* Ṙ ṙ */
    0x1e5a, 501, /* Ṛ ṛ */
    0x1e5c, 501, /* Ṝ ṝ */
    0x1e5e, 501, /* Ṟ ṟ */
    0x1e60, 501, /* Ṡ ṡ */
    0x1e62, 501, /* Ṣ ṣ */
    0x1e64, 501, /* Ṥ ṥ */
    0x1e66, 501, /* Ṧ ṧ */
    0x1e68, 501, /* Ṩ ṩ */
    0x1e6a, 501, /* Ṫ ṫ */
    0x1e6c, 501, /* Ṭ ṭ */
    0x1e6e, 501, /* Ṯ ṯ */
    0x1e70, 501, /* Ṱ ṱ */
    0x1e72, 501, /* Ṳ ṳ */
    0x1e74, 501, /* Ṵ ṵ */
    0x1e76, 501, /* Ṷ ṷ */
    0x1e78, 501, /* Ṹ ṹ */
    0x1e7a, 501, /* Ṻ ṻ */
    0x1e7c, 501, /* Ṽ ṽ */
    0x1e7e, 501, /* Ṿ ṿ */
    0x1e80, 501, /* Ẁ ẁ */
    0x1e82, 501, /* Ẃ ẃ */
    0x1e84, 501, /* Ẅ ẅ */
    0x1e86, 501, /* Ẇ ẇ */
    0x1e88, 501, /* Ẉ ẉ */
    0x1e8a, 501, /* Ẋ ẋ */
    0x1e8c, 501, /* Ẍ ẍ */
    0x1e8e, 501, /* Ẏ ẏ */
    0x1e90, 501, /* Ẑ ẑ */
    0x1e92, 501, /* Ẓ ẓ */
    0x1e94, 501, /* Ẕ ẕ */
    0x1ea0, 501, /* Ạ ạ */
    0x1ea2, 501, /* Ả ả */
    0x1ea4, 501, /* Ấ ấ */
    0x1ea6, 501, /* Ầ ầ */
    0x1ea8, 501, /* Ẩ ẩ */
    0x1eaa, 501, /* Ẫ ẫ */
    0x1eac, 501, /* Ậ ậ */
    0x1eae, 501, /* Ắ ắ */
    0x1eb0, 501, /* Ằ ằ */
    0x1eb2, 501, /* Ẳ ẳ */
    0x1eb4, 501, /* Ẵ ẵ */
    0x1eb6, 501, /* Ặ ặ */
    0x1eb8, 501, /* Ẹ ẹ */
    0x1eba, 501, /* Ẻ ẻ */
    0x1ebc, 501, /* Ẽ ẽ */
    0x1ebe, 501, /* Ế ế */
    0x1ec0, 501, /* Ề ề */
    0x1ec2, 501, /* Ể ể */
    0x1ec4, 501, /* Ễ ễ */
    0x1ec6, 501, /* Ệ ệ */
    0x1ec8, 501, /* Ỉ ỉ */
    0x1eca, 501, /* Ị ị */
    0x1ecc, 501, /* Ọ ọ */
    0x1ece, 501, /* Ỏ ỏ */
    0x1ed0, 501, /* Ố ố */
    0x1ed2, 501, /* Ồ ồ */
    0x1ed4, 501, /* Ổ ổ */
    0x1ed6, 501, /* Ỗ ỗ */
    0x1ed8, 501, /* Ộ ộ */
    0x1eda, 501, /* Ớ ớ */
    0x1edc, 501, /* Ờ ờ */
    0x1ede, 501, /* Ở ở */
    0x1ee0, 501, /* Ỡ ỡ */
    0x1ee2, 501, /* Ợ ợ */
    0x1ee4, 501, /* Ụ ụ */
    0x1ee6, 501, /* Ủ ủ */
    0x1ee8, 501, /* Ứ ứ */
    0x1eea, 501, /* Ừ ừ */
    0x1eec, 501, /* Ử ử */
    0x1eee, 501, /* Ữ ữ */
    0x1ef0, 501, /* Ự ự */
    0x1ef2, 501, /* Ỳ ỳ */
    0x1ef4, 501, /* Ỵ ỵ */
    0x1ef6, 501, /* Ỷ ỷ */
    0x1ef8, 501, /* Ỹ ỹ */
    0x1f59, 492, /* Ὑ ὑ */
    0x1f5b, 492, /* Ὓ ὓ */
    0x1f5d, 492, /* Ὕ ὕ */
    0x1f5f, 492, /* Ὗ ὗ */
    0x1fbc, 491, /* ᾼ ᾳ */
    0x1fcc, 491, /* ῌ ῃ */
    0x1fec, 493, /* Ῥ ῥ */
    0x1ffc, 491, /* ῼ ῳ */
};

static Rune *rune_bsearch(Rune c, Rune *t, int n, int ne) {
  Rune *p;
  int m;

  while (n > 1) {
    m = n / 2;
    p = t + m * ne;
    if (c >= p[0]) {
      t = p;
      n = n - m;
    } else
      n = m;
  }
  if (n && c >= t[0]) return t;
  return 0;
}

Rune tolowerrune(Rune c) {
  Rune *p;

  p = rune_bsearch(c, __tolower2, nelem(__tolower2) / 3, 3);
  if (p && c >= p[0] && c <= p[1]) return c + p[2] - 500;
  p = rune_bsearch(c, __tolower1, nelem(__tolower1) / 2, 2);
  if (p && c == p[0]) return c + p[1] - 500;
  return c;
}

Rune toupperrune(Rune c) {
  Rune *p;

  p = rune_bsearch(c, __toupper2, nelem(__toupper2) / 3, 3);
  if (p && c >= p[0] && c <= p[1]) return c + p[2] - 500;
  p = rune_bsearch(c, __toupper1, nelem(__toupper1) / 2, 2);
  if (p && c == p[0]) return c + p[1] - 500;
  return c;
}

int islowerrune(Rune c) {
  Rune *p;

  p = rune_bsearch(c, __toupper2, nelem(__toupper2) / 3, 3);
  if (p && c >= p[0] && c <= p[1]) return 1;
  p = rune_bsearch(c, __toupper1, nelem(__toupper1) / 2, 2);
  if (p && c == p[0]) return 1;
  return 0;
}

int isupperrune(Rune c) {
  Rune *p;

  p = rune_bsearch(c, __tolower2, nelem(__tolower2) / 3, 3);
  if (p && c >= p[0] && c <= p[1]) return 1;
  p = rune_bsearch(c, __tolower1, nelem(__tolower1) / 2, 2);
  if (p && c == p[0]) return 1;
  return 0;
}

int isdigitrune(Rune c) {
  return c >= '0' && c <= '9';
}

int isnewline(Rune c) {
  return c == 0xA || c == 0xD || c == 0x2028 || c == 0x2029;
}

int iswordchar(Rune c) {
  return c == '_' || isdigitrune(c) || (c >= 'a' && c <= 'z') ||
         (c >= 'A' && c <= 'Z');
}

int isalpharune(Rune c) {
  Rune *p;

  if (isupperrune(c) || islowerrune(c)) return 1;
  p = rune_bsearch(c, __alpha2, nelem(__alpha2) / 2, 2);
  if (p && c >= p[0] && c <= p[1]) return 1;
  p = rune_bsearch(c, __alpha1, nelem(__alpha1), 1);
  if (p && c == p[0]) return 1;
  return 0;
}

int isspacerune(Rune c) {
  Rune *p;

  p = rune_bsearch(c, __space2, nelem(__space2) / 2, 2);
  if (p && c >= p[0] && c <= p[1]) return 1;
  return 0;
}

#else /* V7_ENABLE__UTF */

int chartorune(Rune *rune, const char *str) {
  *rune = *(uchar *) str;
  return 1;
}

int fullrune(char *str UNUSED, int n) {
  return (n <= 0) ? 0 : 1;
}

int isdigitrune(Rune c) {
  return isdigit(c);
}

int isnewline(Rune c) {
  return c == 0xA || c == 0xD || c == 0x2028 || c == 0x2029;
}

int iswordchar(Rune c) {
  return c == '_' || isdigitrune(c) || (c >= 'a' && c <= 'z') ||
         (c >= 'A' && c <= 'Z');
}

int isalpharune(Rune c) {
  return isalpha(c);
}
int islowerrune(Rune c) {
  return islower(c);
}
int isspacerune(Rune c) {
  return isspace(c);
}
int isupperrune(Rune c) {
  return isupper(c);
}

int runetochar(char *str, Rune *rune) {
  str[0] = (char) *rune;
  return 1;
}

Rune tolowerrune(Rune c) {
  return tolower(c);
}
Rune toupperrune(Rune c) {
  return toupper(c);
}
int utfnlen(char *s, long m) { /* Could use strnlen but it's from POSIX 2008. */
  (void) s;
  return m;
}

char *utfnshift(char *s, long m) {
  return s + m;
}

#endif /* V7_ENABLE__UTF */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


void cs_base64_encode(const unsigned char *src, int src_len, char *dst) {
  static const char *b64 =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  int i, j, a, b, c;

  for (i = j = 0; i < src_len; i += 3) {
    a = src[i];
    b = i + 1 >= src_len ? 0 : src[i + 1];
    c = i + 2 >= src_len ? 0 : src[i + 2];

    dst[j++] = b64[a >> 2];
    dst[j++] = b64[((a & 3) << 4) | (b >> 4)];
    if (i + 1 < src_len) {
      dst[j++] = b64[(b & 15) << 2 | (c >> 6)];
    }
    if (i + 2 < src_len) {
      dst[j++] = b64[c & 63];
    }
  }
  while (j % 4 != 0) {
    dst[j++] = '=';
  }
  dst[j++] = '\0';
}

/* Convert one byte of encoded base64 input stream to 6-bit chunk */
static unsigned char from_b64(unsigned char ch) {
  /* Inverse lookup map */
  static const unsigned char tab[128] = {
      255, 255, 255, 255,
      255, 255, 255, 255, /*  0 */
      255, 255, 255, 255,
      255, 255, 255, 255, /*  8 */
      255, 255, 255, 255,
      255, 255, 255, 255, /*  16 */
      255, 255, 255, 255,
      255, 255, 255, 255, /*  24 */
      255, 255, 255, 255,
      255, 255, 255, 255, /*  32 */
      255, 255, 255, 62,
      255, 255, 255, 63, /*  40 */
      52,  53,  54,  55,
      56,  57,  58,  59, /*  48 */
      60,  61,  255, 255,
      255, 200, 255, 255, /*  56   '=' is 200, on index 61 */
      255, 0,   1,   2,
      3,   4,   5,   6, /*  64 */
      7,   8,   9,   10,
      11,  12,  13,  14, /*  72 */
      15,  16,  17,  18,
      19,  20,  21,  22, /*  80 */
      23,  24,  25,  255,
      255, 255, 255, 255, /*  88 */
      255, 26,  27,  28,
      29,  30,  31,  32, /*  96 */
      33,  34,  35,  36,
      37,  38,  39,  40, /*  104 */
      41,  42,  43,  44,
      45,  46,  47,  48, /*  112 */
      49,  50,  51,  255,
      255, 255, 255, 255, /*  120 */
  };
  return tab[ch & 127];
}

int cs_base64_decode(const unsigned char *s, int len, char *dst) {
  unsigned char a, b, c, d;
  int orig_len = len;
  while (len >= 4 && (a = from_b64(s[0])) != 255 &&
         (b = from_b64(s[1])) != 255 && (c = from_b64(s[2])) != 255 &&
         (d = from_b64(s[3])) != 255) {
    s += 4;
    len -= 4;
    if (a == 200 || b == 200) break; /* '=' can't be there */
    *dst++ = a << 2 | b >> 4;
    if (c == 200) break;
    *dst++ = b << 4 | c >> 2;
    if (d == 200) break;
    *dst++ = c << 6 | d;
  }
  *dst = 0;
  return orig_len - len;
}
/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

#ifndef DISABLE_MD5


static void byteReverse(unsigned char *buf, unsigned longs) {
/* Forrest: MD5 expect LITTLE_ENDIAN, swap if BIG_ENDIAN */
#if BYTE_ORDER == BIG_ENDIAN
  do {
    uint32_t t = (uint32_t)((unsigned) buf[3] << 8 | buf[2]) << 16 |
                 ((unsigned) buf[1] << 8 | buf[0]);
    *(uint32_t *) buf = t;
    buf += 4;
  } while (--longs);
#else
  (void) buf;
  (void) longs;
#endif
}

#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

#define MD5STEP(f, w, x, y, z, data, s) \
  (w += f(x, y, z) + data, w = w << s | w >> (32 - s), w += x)

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void MD5_Init(MD5_CTX *ctx) {
  ctx->buf[0] = 0x67452301;
  ctx->buf[1] = 0xefcdab89;
  ctx->buf[2] = 0x98badcfe;
  ctx->buf[3] = 0x10325476;

  ctx->bits[0] = 0;
  ctx->bits[1] = 0;
}

static void MD5Transform(uint32_t buf[4], uint32_t const in[16]) {
  register uint32_t a, b, c, d;

  a = buf[0];
  b = buf[1];
  c = buf[2];
  d = buf[3];

  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}

void MD5_Update(MD5_CTX *ctx, const unsigned char *buf, size_t len) {
  uint32_t t;

  t = ctx->bits[0];
  if ((ctx->bits[0] = t + ((uint32_t) len << 3)) < t) ctx->bits[1]++;
  ctx->bits[1] += (uint32_t) len >> 29;

  t = (t >> 3) & 0x3f;

  if (t) {
    unsigned char *p = (unsigned char *) ctx->in + t;

    t = 64 - t;
    if (len < t) {
      memcpy(p, buf, len);
      return;
    }
    memcpy(p, buf, t);
    byteReverse(ctx->in, 16);
    MD5Transform(ctx->buf, (uint32_t *) ctx->in);
    buf += t;
    len -= t;
  }

  while (len >= 64) {
    memcpy(ctx->in, buf, 64);
    byteReverse(ctx->in, 16);
    MD5Transform(ctx->buf, (uint32_t *) ctx->in);
    buf += 64;
    len -= 64;
  }

  memcpy(ctx->in, buf, len);
}

void MD5_Final(unsigned char digest[16], MD5_CTX *ctx) {
  unsigned count;
  unsigned char *p;
  uint32_t *a;

  count = (ctx->bits[0] >> 3) & 0x3F;

  p = ctx->in + count;
  *p++ = 0x80;
  count = 64 - 1 - count;
  if (count < 8) {
    memset(p, 0, count);
    byteReverse(ctx->in, 16);
    MD5Transform(ctx->buf, (uint32_t *) ctx->in);
    memset(ctx->in, 0, 56);
  } else {
    memset(p, 0, count - 8);
  }
  byteReverse(ctx->in, 14);

  a = (uint32_t *) ctx->in;
  a[14] = ctx->bits[0];
  a[15] = ctx->bits[1];

  MD5Transform(ctx->buf, (uint32_t *) ctx->in);
  byteReverse((unsigned char *) ctx->buf, 4);
  memcpy(digest, ctx->buf, 16);
  memset((char *) ctx, 0, sizeof(*ctx));
}
#endif
/* Copyright(c) By Steve Reid <steve@edmweb.com> */
/* 100% Public Domain */

#ifndef DISABLE_SHA1


#define SHA1HANDSOFF
#if defined(__sun)
#endif

union char64long16 {
  unsigned char c[64];
  uint32_t l[16];
};

#define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))

static uint32_t blk0(union char64long16 *block, int i) {
/* Forrest: SHA expect BIG_ENDIAN, swap if LITTLE_ENDIAN */
#if BYTE_ORDER == LITTLE_ENDIAN
  block->l[i] =
      (rol(block->l[i], 24) & 0xFF00FF00) | (rol(block->l[i], 8) & 0x00FF00FF);
#endif
  return block->l[i];
}

/* Avoid redefine warning (ARM /usr/include/sys/ucontext.h define R0~R4) */
#undef blk
#undef R0
#undef R1
#undef R2
#undef R3
#undef R4

#define blk(i)                                                               \
  (block->l[i & 15] = rol(block->l[(i + 13) & 15] ^ block->l[(i + 8) & 15] ^ \
                              block->l[(i + 2) & 15] ^ block->l[i & 15],     \
                          1))
#define R0(v, w, x, y, z, i)                                          \
  z += ((w & (x ^ y)) ^ y) + blk0(block, i) + 0x5A827999 + rol(v, 5); \
  w = rol(w, 30);
#define R1(v, w, x, y, z, i)                                  \
  z += ((w & (x ^ y)) ^ y) + blk(i) + 0x5A827999 + rol(v, 5); \
  w = rol(w, 30);
#define R2(v, w, x, y, z, i)                          \
  z += (w ^ x ^ y) + blk(i) + 0x6ED9EBA1 + rol(v, 5); \
  w = rol(w, 30);
#define R3(v, w, x, y, z, i)                                        \
  z += (((w | x) & y) | (w & x)) + blk(i) + 0x8F1BBCDC + rol(v, 5); \
  w = rol(w, 30);
#define R4(v, w, x, y, z, i)                          \
  z += (w ^ x ^ y) + blk(i) + 0xCA62C1D6 + rol(v, 5); \
  w = rol(w, 30);

void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]) {
  uint32_t a, b, c, d, e;
  union char64long16 block[1];

  memcpy(block, buffer, 64);
  a = state[0];
  b = state[1];
  c = state[2];
  d = state[3];
  e = state[4];
  R0(a, b, c, d, e, 0);
  R0(e, a, b, c, d, 1);
  R0(d, e, a, b, c, 2);
  R0(c, d, e, a, b, 3);
  R0(b, c, d, e, a, 4);
  R0(a, b, c, d, e, 5);
  R0(e, a, b, c, d, 6);
  R0(d, e, a, b, c, 7);
  R0(c, d, e, a, b, 8);
  R0(b, c, d, e, a, 9);
  R0(a, b, c, d, e, 10);
  R0(e, a, b, c, d, 11);
  R0(d, e, a, b, c, 12);
  R0(c, d, e, a, b, 13);
  R0(b, c, d, e, a, 14);
  R0(a, b, c, d, e, 15);
  R1(e, a, b, c, d, 16);
  R1(d, e, a, b, c, 17);
  R1(c, d, e, a, b, 18);
  R1(b, c, d, e, a, 19);
  R2(a, b, c, d, e, 20);
  R2(e, a, b, c, d, 21);
  R2(d, e, a, b, c, 22);
  R2(c, d, e, a, b, 23);
  R2(b, c, d, e, a, 24);
  R2(a, b, c, d, e, 25);
  R2(e, a, b, c, d, 26);
  R2(d, e, a, b, c, 27);
  R2(c, d, e, a, b, 28);
  R2(b, c, d, e, a, 29);
  R2(a, b, c, d, e, 30);
  R2(e, a, b, c, d, 31);
  R2(d, e, a, b, c, 32);
  R2(c, d, e, a, b, 33);
  R2(b, c, d, e, a, 34);
  R2(a, b, c, d, e, 35);
  R2(e, a, b, c, d, 36);
  R2(d, e, a, b, c, 37);
  R2(c, d, e, a, b, 38);
  R2(b, c, d, e, a, 39);
  R3(a, b, c, d, e, 40);
  R3(e, a, b, c, d, 41);
  R3(d, e, a, b, c, 42);
  R3(c, d, e, a, b, 43);
  R3(b, c, d, e, a, 44);
  R3(a, b, c, d, e, 45);
  R3(e, a, b, c, d, 46);
  R3(d, e, a, b, c, 47);
  R3(c, d, e, a, b, 48);
  R3(b, c, d, e, a, 49);
  R3(a, b, c, d, e, 50);
  R3(e, a, b, c, d, 51);
  R3(d, e, a, b, c, 52);
  R3(c, d, e, a, b, 53);
  R3(b, c, d, e, a, 54);
  R3(a, b, c, d, e, 55);
  R3(e, a, b, c, d, 56);
  R3(d, e, a, b, c, 57);
  R3(c, d, e, a, b, 58);
  R3(b, c, d, e, a, 59);
  R4(a, b, c, d, e, 60);
  R4(e, a, b, c, d, 61);
  R4(d, e, a, b, c, 62);
  R4(c, d, e, a, b, 63);
  R4(b, c, d, e, a, 64);
  R4(a, b, c, d, e, 65);
  R4(e, a, b, c, d, 66);
  R4(d, e, a, b, c, 67);
  R4(c, d, e, a, b, 68);
  R4(b, c, d, e, a, 69);
  R4(a, b, c, d, e, 70);
  R4(e, a, b, c, d, 71);
  R4(d, e, a, b, c, 72);
  R4(c, d, e, a, b, 73);
  R4(b, c, d, e, a, 74);
  R4(a, b, c, d, e, 75);
  R4(e, a, b, c, d, 76);
  R4(d, e, a, b, c, 77);
  R4(c, d, e, a, b, 78);
  R4(b, c, d, e, a, 79);
  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  state[4] += e;
  /* Erase working structures. The order of operations is important,
   * used to ensure that compiler doesn't optimize those out. */
  memset(block, 0, sizeof(block));
  a = b = c = d = e = 0;
  (void) a;
  (void) b;
  (void) c;
  (void) d;
  (void) e;
}

void SHA1Init(SHA1_CTX *context) {
  context->state[0] = 0x67452301;
  context->state[1] = 0xEFCDAB89;
  context->state[2] = 0x98BADCFE;
  context->state[3] = 0x10325476;
  context->state[4] = 0xC3D2E1F0;
  context->count[0] = context->count[1] = 0;
}

void SHA1Update(SHA1_CTX *context, const unsigned char *data, uint32_t len) {
  uint32_t i, j;

  j = context->count[0];
  if ((context->count[0] += len << 3) < j) context->count[1]++;
  context->count[1] += (len >> 29);
  j = (j >> 3) & 63;
  if ((j + len) > 63) {
    memcpy(&context->buffer[j], data, (i = 64 - j));
    SHA1Transform(context->state, context->buffer);
    for (; i + 63 < len; i += 64) {
      SHA1Transform(context->state, &data[i]);
    }
    j = 0;
  } else
    i = 0;
  memcpy(&context->buffer[j], &data[i], len - i);
}

void SHA1Final(unsigned char digest[20], SHA1_CTX *context) {
  unsigned i;
  unsigned char finalcount[8], c;

  for (i = 0; i < 8; i++) {
    finalcount[i] = (unsigned char) ((context->count[(i >= 4 ? 0 : 1)] >>
                                      ((3 - (i & 3)) * 8)) &
                                     255);
  }
  c = 0200;
  SHA1Update(context, &c, 1);
  while ((context->count[0] & 504) != 448) {
    c = 0000;
    SHA1Update(context, &c, 1);
  }
  SHA1Update(context, finalcount, 8);
  for (i = 0; i < 20; i++) {
    digest[i] =
        (unsigned char) ((context->state[i >> 2] >> ((3 - (i & 3)) * 8)) & 255);
  }
  memset(context, '\0', sizeof(*context));
  memset(&finalcount, '\0', sizeof(finalcount));
}

void hmac_sha1(const unsigned char *key, size_t keylen,
               const unsigned char *data, size_t datalen,
               unsigned char out[20]) {
  SHA1_CTX ctx;
  unsigned char buf1[64], buf2[64], tmp_key[20], i;

  if (keylen > sizeof(buf1)) {
    SHA1Init(&ctx);
    SHA1Update(&ctx, key, keylen);
    SHA1Final(tmp_key, &ctx);
    key = tmp_key;
    keylen = sizeof(tmp_key);
  }

  memset(buf1, 0, sizeof(buf1));
  memset(buf2, 0, sizeof(buf2));
  memcpy(buf1, key, keylen);
  memcpy(buf2, key, keylen);

  for (i = 0; i < sizeof(buf1); i++) {
    buf1[i] ^= 0x36;
    buf2[i] ^= 0x5c;
  }

  SHA1Init(&ctx);
  SHA1Update(&ctx, buf1, sizeof(buf1));
  SHA1Update(&ctx, data, datalen);
  SHA1Final(out, &ctx);

  SHA1Init(&ctx);
  SHA1Update(&ctx, buf2, sizeof(buf2));
  SHA1Update(&ctx, out, 20);
  SHA1Final(out, &ctx);
}
#endif
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */


#define C_SNPRINTF_APPEND_CHAR(ch)       \
  do {                                   \
    if (i < (int) buf_size) buf[i] = ch; \
    i++;                                 \
  } while (0)

#define C_SNPRINTF_FLAG_ZERO 1

#ifdef C_DISABLE_BUILTIN_SNPRINTF
int c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {
  return vsnprintf(buf, buf_size, fmt, ap);
}
#else
static int c_itoa(char *buf, size_t buf_size, int64_t num, int base, int flags,
                  int field_width) {
  char tmp[40];
  int i = 0, k = 0, neg = 0;

  if (num < 0) {
    neg++;
    num = -num;
  }

  /* Print into temporary buffer - in reverse order */
  do {
    int rem = num % base;
    if (rem < 10) {
      tmp[k++] = '0' + rem;
    } else {
      tmp[k++] = 'a' + (rem - 10);
    }
    num /= base;
  } while (num > 0);

  /* Zero padding */
  if (flags && C_SNPRINTF_FLAG_ZERO) {
    while (k < field_width && k < (int) sizeof(tmp) - 1) {
      tmp[k++] = '0';
    }
  }

  /* And sign */
  if (neg) {
    tmp[k++] = '-';
  }

  /* Now output */
  while (--k >= 0) {
    C_SNPRINTF_APPEND_CHAR(tmp[k]);
  }

  return i;
}

int c_vsnprintf(char *buf, size_t buf_size, const char *fmt, va_list ap) {
  int ch, i = 0, len_mod, flags, precision, field_width;

  while ((ch = *fmt++) != '\0') {
    if (ch != '%') {
      C_SNPRINTF_APPEND_CHAR(ch);
    } else {
      /*
       * Conversion specification:
       *   zero or more flags (one of: # 0 - <space> + ')
       *   an optional minimum  field  width (digits)
       *   an  optional precision (. followed by digits, or *)
       *   an optional length modifier (one of: hh h l ll L q j z t)
       *   conversion specifier (one of: d i o u x X e E f F g G a A c s p n)
       */
      flags = field_width = precision = len_mod = 0;

      /* Flags. only zero-pad flag is supported. */
      if (*fmt == '0') {
        flags |= C_SNPRINTF_FLAG_ZERO;
      }

      /* Field width */
      while (*fmt >= '0' && *fmt <= '9') {
        field_width *= 10;
        field_width += *fmt++ - '0';
      }

      /* Precision */
      if (*fmt == '.') {
        fmt++;
        if (*fmt == '*') {
          precision = va_arg(ap, int);
          fmt++;
        } else {
          while (*fmt >= '0' && *fmt <= '9') {
            precision *= 10;
            precision += *fmt++ - '0';
          }
        }
      }

      /* Length modifier */
      switch (*fmt) {
        case 'h':
        case 'l':
        case 'L':
        case 'I':
        case 'q':
        case 'j':
        case 'z':
        case 't':
          len_mod = *fmt++;
          if (*fmt == 'h') {
            len_mod = 'H';
            fmt++;
          }
          if (*fmt == 'l') {
            len_mod = 'q';
            fmt++;
          }
          break;
      }

      ch = *fmt++;
      if (ch == 's') {
        const char *s = va_arg(ap, const char *); /* Always fetch parameter */
        int j;
        /* Ignore negative and 0 precisions */
        for (j = 0; (precision <= 0 || j < precision) && s[j] != '\0'; j++) {
          C_SNPRINTF_APPEND_CHAR(s[j]);
        }
      } else if (ch == 'c') {
        ch = va_arg(ap, int); /* Always fetch parameter */
        C_SNPRINTF_APPEND_CHAR(ch);
      } else if (ch == 'd' && len_mod == 0) {
        i += c_itoa(buf + i, buf_size - i, va_arg(ap, int), 10, flags,
                    field_width);
      } else if (ch == 'd' && len_mod == 'l') {
        i += c_itoa(buf + i, buf_size - i, va_arg(ap, long), 10, flags,
                    field_width);
      } else if ((ch == 'x' || ch == 'u') && len_mod == 0) {
        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned),
                    ch == 'x' ? 16 : 10, flags, field_width);
      } else if ((ch == 'x' || ch == 'u') && len_mod == 'l') {
        i += c_itoa(buf + i, buf_size - i, va_arg(ap, unsigned long),
                    ch == 'x' ? 16 : 10, flags, field_width);
      } else if (ch == 'p') {
        unsigned long num = (unsigned long) va_arg(ap, void *);
        C_SNPRINTF_APPEND_CHAR('0');
        C_SNPRINTF_APPEND_CHAR('x');
        i += c_itoa(buf + i, buf_size - i, num, 16, flags, 0);
      } else {
#ifndef NO_LIBC
        /*
         * TODO(lsm): abort is not nice in a library, remove it
         * Also, ESP8266 SDK doesn't have it
         */
        abort();
#endif
      }
    }
  }

  /* Zero-terminate the result */
  if (buf_size > 0) {
    buf[i < (int) buf_size ? i : (int) buf_size - 1] = '\0';
  }

  return i;
}
#endif

int c_snprintf(char *buf, size_t buf_size, const char *fmt, ...) {
  int result;
  va_list ap;
  va_start(ap, fmt);
  result = c_vsnprintf(buf, buf_size, fmt, ap);
  va_end(ap);
  return result;
}

#ifdef _WIN32
void to_wchar(const char *path, wchar_t *wbuf, size_t wbuf_len) {
  char buf[MAX_PATH * 2], buf2[MAX_PATH * 2], *p;

  strncpy(buf, path, sizeof(buf));
  buf[sizeof(buf) - 1] = '\0';

  /* Trim trailing slashes. Leave backslash for paths like "X:\" */
  p = buf + strlen(buf) - 1;
  while (p > buf && p[-1] != ':' && (p[0] == '\\' || p[0] == '/')) *p-- = '\0';

  /*
   * Convert to Unicode and back. If doubly-converted string does not
   * match the original, something is fishy, reject.
   */
  memset(wbuf, 0, wbuf_len * sizeof(wchar_t));
  MultiByteToWideChar(CP_UTF8, 0, buf, -1, wbuf, (int) wbuf_len);
  WideCharToMultiByte(CP_UTF8, 0, wbuf, (int) wbuf_len, buf2, sizeof(buf2),
                      NULL, NULL);
  if (strcmp(buf, buf2) != 0) {
    wbuf[0] = L'\0';
  }
}
#endif /* _WIN32 */
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */


/*
 * This file contains POSIX opendir/closedir/readdir API implementation
 * for systems which do not natively support it (e.g. Windows).
 */

#ifndef NS_FREE
#define NS_FREE free
#endif

#ifndef NS_MALLOC
#define NS_MALLOC malloc
#endif

#ifdef _WIN32
DIR *opendir(const char *name) {
  DIR *dir = NULL;
  wchar_t wpath[MAX_PATH];
  DWORD attrs;

  if (name == NULL) {
    SetLastError(ERROR_BAD_ARGUMENTS);
  } else if ((dir = (DIR *) NS_MALLOC(sizeof(*dir))) == NULL) {
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
  } else {
    to_wchar(name, wpath, ARRAY_SIZE(wpath));
    attrs = GetFileAttributesW(wpath);
    if (attrs != 0xFFFFFFFF && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {
      (void) wcscat(wpath, L"\\*");
      dir->handle = FindFirstFileW(wpath, &dir->info);
      dir->result.d_name[0] = '\0';
    } else {
      NS_FREE(dir);
      dir = NULL;
    }
  }

  return dir;
}

int closedir(DIR *dir) {
  int result = 0;

  if (dir != NULL) {
    if (dir->handle != INVALID_HANDLE_VALUE)
      result = FindClose(dir->handle) ? 0 : -1;
    NS_FREE(dir);
  } else {
    result = -1;
    SetLastError(ERROR_BAD_ARGUMENTS);
  }

  return result;
}

struct dirent *readdir(DIR *dir) {
  struct dirent *result = 0;

  if (dir) {
    if (dir->handle != INVALID_HANDLE_VALUE) {
      result = &dir->result;
      (void) WideCharToMultiByte(CP_UTF8, 0, dir->info.cFileName, -1,
                                 result->d_name, sizeof(result->d_name), NULL,
                                 NULL);

      if (!FindNextFileW(dir->handle, &dir->info)) {
        (void) FindClose(dir->handle);
        dir->handle = INVALID_HANDLE_VALUE;
      }

    } else {
      SetLastError(ERROR_FILE_NOT_FOUND);
    }
  } else {
    SetLastError(ERROR_BAD_ARGUMENTS);
  }

  return result;
}
#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#if defined(V7_ENABLE_FILE) && !defined(V7_NO_FS)

#ifdef V7_ENABLE_SPIFFS
#include <spiffs.h>

typedef struct {
  spiffs_DIR dh;
  struct spiffs_dirent de;
} DIR;

DIR *opendir(const char *dir_name) {
  DIR *dir = NULL;
  extern spiffs fs;

  if (dir_name != NULL && (dir = (DIR *) malloc(sizeof(*dir))) != NULL &&
      SPIFFS_opendir(&fs, (char *) dir_name, &dir->dh) == NULL) {
    free(dir);
    dir = NULL;
  }

  return dir;
}

int closedir(DIR *dir) {
  if (dir != NULL) {
    SPIFFS_closedir(&dir->dh);
    free(dir);
  }
  return 0;
}

#define d_name name
#define dirent spiffs_dirent

struct dirent *readdir(DIR *dir) {
  return SPIFFS_readdir(&dir->dh, &dir->de);
}
#endif

static v7_val_t s_file_proto;
static const char s_fd_prop[] = "__fd";

#ifndef NO_LIBC
static c_file_t v7_val_to_file(v7_val_t val) {
  return (c_file_t) v7_to_foreign(val);
}

static v7_val_t v7_file_to_val(c_file_t file) {
  return v7_create_foreign(file);
}

static int v7_is_file_type(v7_val_t val) {
  return v7_is_foreign(val);
}
#else
c_file_t v7_val_to_file(v7_val_t val);
v7_val_t v7_file_to_val(c_file_t file);
int v7_is_file_type(v7_val_t val);
#endif

static v7_val_t File_eval(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t res = v7_create_undefined();

  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t n;
    const char *s = v7_to_string(v7, &arg0, &n);
    if (v7_exec_file(v7, &res, s) != V7_OK) {
      v7_throw_value(v7, res);
    }
  }

  return res;
}

static v7_val_t f_read(struct v7 *v7, v7_val_t this_obj, v7_val_t a, int all) {
  v7_val_t arg0 = v7_get(v7, this_obj, s_fd_prop, sizeof(s_fd_prop) - 1);
  (void) a;
  if (v7_is_file_type(arg0)) {
    struct mbuf m;
    char buf[BUFSIZ];
    int n;
    c_file_t fp = v7_val_to_file(arg0);

    /* Read file contents into mbuf */
    mbuf_init(&m, 0);
    while ((n = c_fread(buf, 1, sizeof(buf), fp)) > 0) {
      mbuf_append(&m, buf, n);
      if (!all) {
        break;
      }
    }

    /* Proactively close the file on EOF or read error */
    if (n <= 0) {
      c_fclose(fp);
    }

    if (m.len > 0) {
      v7_val_t res = v7_create_string(v7, m.buf, m.len, 1);
      mbuf_free(&m);
      return res;
    }
  }
  return v7_create_string(v7, "", 0, 1);
}

static v7_val_t File_readAll(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  return f_read(v7, this_obj, args, 1);
}

static v7_val_t File_read(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  return f_read(v7, this_obj, args, 0);
}

static v7_val_t File_write(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_get(v7, this_obj, s_fd_prop, sizeof(s_fd_prop) - 1);
  v7_val_t arg1 = v7_array_get(v7, args, 0);
  size_t n, sent = 0, len = 0;

  if (v7_is_file_type(arg0) && v7_is_string(arg1)) {
    const char *s = v7_to_string(v7, &arg1, &len);
    c_file_t fp = v7_val_to_file(arg0);
    while (sent < len && (n = c_fwrite(s + sent, 1, len - sent, fp)) > 0) {
      sent += n;
    }
  }

  return v7_create_number(sent);
}

static v7_val_t File_close(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t prop = v7_get(v7, this_obj, s_fd_prop, sizeof(s_fd_prop) - 1);
  int res = -1;
  (void) args;
  if (v7_is_file_type(prop)) {
    res = c_fclose(v7_val_to_file(prop));
  }
  return v7_create_number(res);
}

static v7_val_t File_open(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t arg1 = v7_array_get(v7, args, 1);
  c_file_t fp = INVALID_FILE;

  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t n1, n2;
    const char *s1 = v7_to_string(v7, &arg0, &n1);
    const char *s2 = "rb"; /* Open files in read mode by default */
    if (v7_is_string(arg1)) {
      s2 = v7_to_string(v7, &arg1, &n2);
    }
    fp = c_fopen(s1, s2);
    if (fp != INVALID_FILE) {
      v7_val_t obj = v7_create_object(v7);
      v7_set_proto(obj, s_file_proto);
      v7_set(v7, obj, s_fd_prop, sizeof(s_fd_prop) - 1, V7_PROPERTY_DONT_ENUM,
             v7_file_to_val(fp));
      return obj;
    }
  }

  return v7_create_null();
}

static v7_val_t File_rename(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t arg1 = v7_array_get(v7, args, 1);
  int res = -1;

  (void) this_obj;
  if (v7_is_string(arg0) && v7_is_string(arg1)) {
    size_t n1, n2;
    const char *from = v7_to_string(v7, &arg0, &n1);
    const char *to = v7_to_string(v7, &arg1, &n2);
    res = c_rename(from, to);
  }

  return v7_create_number(res == 0 ? 0 : errno);
}

static v7_val_t File_remove(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  int res = -1;
  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t n;
    const char *path = v7_to_string(v7, &arg0, &n);
    res = c_remove(path);
  }
  return v7_create_number(res == 0 ? 0 : errno);
}

static v7_val_t File_list(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t result = v7_create_undefined();

  (void) this_obj;

  if (v7_is_string(arg0)) {
    size_t n;
    const char *path = v7_to_string(v7, &arg0, &n);
    struct dirent *dp;
    DIR *dirp;

    if ((dirp = (opendir(path))) != NULL) {
      result = v7_create_array(v7);
      while ((dp = readdir(dirp)) != NULL) {
        /* Do not show current and parent dirs */
        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0) {
          continue;
        }
        /* Add file name to the list */
        v7_array_push(v7, result,
                      v7_create_string(v7, dp->d_name, strlen(dp->d_name), 1));
      }
      closedir(dirp);
    }
  }

  return result;
}

void init_file(struct v7 *v7) {
  v7_val_t file_obj = v7_create_object(v7);
  v7_set(v7, v7_get_global_object(v7), "File", 4, 0, file_obj);
  s_file_proto = v7_create_object(v7);
  v7_set(v7, file_obj, "prototype", 9, 0, s_file_proto);

  v7_set_method(v7, file_obj, "eval", File_eval);
  v7_set_method(v7, file_obj, "remove", File_remove);
  v7_set_method(v7, file_obj, "rename", File_rename);
  v7_set_method(v7, file_obj, "open", File_open);
  v7_set_method(v7, file_obj, "list", File_list);

  v7_set_method(v7, s_file_proto, "close", File_close);
  v7_set_method(v7, s_file_proto, "read", File_read);
  v7_set_method(v7, s_file_proto, "readAll", File_readAll);
  v7_set_method(v7, s_file_proto, "write", File_write);
}
#else
void init_file(struct v7 *v7) {
  (void) v7;
}
#endif
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */


#ifdef V7_ENABLE_SOCKET

#ifdef __WATCOM__
#define SOMAXCONN 128
#endif

#ifndef RECV_BUF_SIZE
#define RECV_BUF_SIZE 1024
#endif

static v7_val_t s_sock_proto;
static const char s_sock_prop[] = "__sock";

static uint32_t s_resolve(struct v7 *v7, v7_val_t ip_address) {
  size_t n;
  const char *s = v7_to_string(v7, &ip_address, &n);
  struct hostent *he = gethostbyname(s);
  return he == NULL ? 0 : *(uint32_t *) he->h_addr_list[0];
}

static v7_val_t s_fd_to_sock_obj(struct v7 *v7, sock_t fd) {
  v7_val_t obj = v7_create_object(v7);
  v7_set_proto(obj, s_sock_proto);
  v7_set(v7, obj, s_sock_prop, sizeof(s_sock_prop) - 1, V7_PROPERTY_DONT_ENUM,
         v7_create_number(fd));
  return obj;
}

/* Socket.connect(host, port [, is_udp]) -> socket_object */
static v7_val_t Socket_connect(struct v7 *v7, v7_val_t t, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t arg1 = v7_array_get(v7, args, 1);
  v7_val_t arg2 = v7_array_get(v7, args, 2);

  (void) t;
  if (v7_is_number(arg1) && v7_is_string(arg0)) {
    struct sockaddr_in sin;
    sock_t sock =
        socket(AF_INET, v7_is_true(v7, arg2) ? SOCK_DGRAM : SOCK_STREAM, 0);
    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = s_resolve(v7, arg0);
    sin.sin_port = htons((uint16_t) v7_to_number(arg1));
    if (connect(sock, (struct sockaddr *) &sin, sizeof(sin)) != 0) {
      closesocket(sock);
    } else {
      return s_fd_to_sock_obj(v7, sock);
    }
  }

  return v7_create_null();
}

/* Socket.listen(port [, ip_address [,is_udp]]) -> sock */
static v7_val_t Socket_listen(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t arg1 = v7_array_get(v7, args, 1);
  v7_val_t arg2 = v7_array_get(v7, args, 2);

  (void) this_obj;
  if (v7_is_number(arg0)) {
    struct sockaddr_in sin;
    int on = 1;
    sock_t sock =
        socket(AF_INET, v7_is_true(v7, arg2) ? SOCK_DGRAM : SOCK_STREAM, 0);
    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_port = htons((uint16_t) v7_to_number(arg0));
    if (v7_is_string(arg1)) {
      sin.sin_addr.s_addr = s_resolve(v7, arg1);
    }

#if defined(_WIN32) && defined(SO_EXCLUSIVEADDRUSE)
    /* "Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE" http://goo.gl/RmrFTm */
    setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (void *) &on, sizeof(on));
#endif

#if !defined(_WIN32) || defined(SO_EXCLUSIVEADDRUSE)
    /*
     * SO_RESUSEADDR is not enabled on Windows because the semantics of
     * SO_REUSEADDR on UNIX and Windows is different. On Windows,
     * SO_REUSEADDR allows to bind a socket to a port without error even if
     * the port is already open by another program. This is not the behavior
     * SO_REUSEADDR was designed for, and leads to hard-to-track failure
     * scenarios. Therefore, SO_REUSEADDR was disabled on Windows unless
     * SO_EXCLUSIVEADDRUSE is supported and set on a socket.
     */
    setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &on, sizeof(on));
#endif

    if (bind(sock, (struct sockaddr *) &sin, sizeof(sin)) == 0) {
      listen(sock, SOMAXCONN);
      return s_fd_to_sock_obj(v7, sock);
    } else {
      closesocket(sock);
    }
  }

  return v7_create_null();
}

static v7_val_t Socket_accept(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t prop = v7_get(v7, this_obj, s_sock_prop, sizeof(s_sock_prop) - 1);
  (void) args;
  if (v7_is_number(prop)) {
    struct sockaddr_in sin;
    socklen_t len = sizeof(sin);
    sock_t sock = (sock_t) v7_to_number(prop);
    sock_t fd = accept(sock, (struct sockaddr *) &sin, &len);
    if (fd != INVALID_SOCKET) {
      return s_fd_to_sock_obj(v7, fd);
    }
  }
  return v7_create_null();
}

/* sock.close() -> errno */
static v7_val_t Socket_close(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t prop = v7_get(v7, this_obj, s_sock_prop, sizeof(s_sock_prop) - 1);
  (void) args;
  return v7_create_number(closesocket((sock_t) v7_to_number(prop)));
}

/* sock.recv() -> string */
static v7_val_t s_recv(struct v7 *v7, v7_val_t this_obj, v7_val_t a, int all) {
  v7_val_t prop = v7_get(v7, this_obj, s_sock_prop, sizeof(s_sock_prop) - 1);
  (void) a;
  if (v7_is_number(prop)) {
    char buf[RECV_BUF_SIZE];
    sock_t sock = (sock_t) v7_to_number(prop);
    struct mbuf m;
    int n;

    mbuf_init(&m, 0);
    while ((n = recv(sock, buf, sizeof(buf), 0)) > 0) {
      mbuf_append(&m, buf, n);
      if (!all) {
        break;
      }
    }

    if (n <= 0) {
      closesocket(sock);
      v7_set(v7, this_obj, s_sock_prop, sizeof(s_sock_prop) - 1,
             V7_PROPERTY_DONT_ENUM, v7_create_number(INVALID_SOCKET));
    }

    if (m.len > 0) {
      v7_val_t res = v7_create_string(v7, m.buf, m.len, 1);
      mbuf_free(&m);
      return res;
    }
  }

  return v7_create_null();
}

static v7_val_t Socket_recvAll(struct v7 *v7, v7_val_t t, v7_val_t args) {
  return s_recv(v7, t, args, 1);
}

static v7_val_t Socket_recv(struct v7 *v7, v7_val_t t, v7_val_t args) {
  return s_recv(v7, t, args, 0);
}

static v7_val_t Socket_send(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t prop = v7_get(v7, this_obj, s_sock_prop, sizeof(s_sock_prop) - 1);
  size_t len, sent = 0;

  if (v7_is_number(prop) && v7_is_string(arg0)) {
    const char *s = v7_to_string(v7, &arg0, &len);
    sock_t sock = (sock_t) v7_to_number(prop);
    int n;

    while (sent < len && (n = send(sock, s + sent, len - sent, 0)) > 0) {
      sent += n;
    }
  }

  return v7_create_number(sent);
}

void init_socket(struct v7 *v7) {
  v7_val_t socket_obj = v7_create_object(v7);

  v7_set(v7, v7_get_global_object(v7), "Socket", 6, 0, socket_obj);
  s_sock_proto = v7_create_object(v7);
  v7_set(v7, socket_obj, "prototype", 9, 0, s_sock_proto);

  v7_set_method(v7, socket_obj, "connect", Socket_connect);
  v7_set_method(v7, socket_obj, "listen", Socket_listen);

  v7_set_method(v7, s_sock_proto, "accept", Socket_accept);
  v7_set_method(v7, s_sock_proto, "send", Socket_send);
  v7_set_method(v7, s_sock_proto, "recv", Socket_recv);
  v7_set_method(v7, s_sock_proto, "recvAll", Socket_recvAll);
  v7_set_method(v7, s_sock_proto, "close", Socket_close);

#ifdef _WIN32
  {
    WSADATA data;
    WSAStartup(MAKEWORD(2, 2), &data);
    /* TODO(alashkin): add WSACleanup call */
  }
#else
  signal(SIGPIPE, SIG_IGN);
#endif
}
#else
void init_socket(struct v7 *v7) {
  (void) v7;
}
#endif
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */

#include <stdlib.h>
#include <string.h>


#ifdef V7_ENABLE_CRYPTO

typedef void (*b64_func_t)(const unsigned char *, int, char *);

static v7_val_t b64_transform(struct v7 *v7, v7_val_t this_obj, v7_val_t args,
                              b64_func_t func, double mult) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);
  v7_val_t res = v7_create_undefined();

  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t n;
    const char *s = v7_to_string(v7, &arg0, &n);
    char *buf = (char *) malloc(n * mult + 4);
    if (buf != NULL) {
      func((const unsigned char *) s, (int) n, buf);
      res = v7_create_string(v7, buf, strlen(buf), 1);
      free(buf);
    }
  }

  return res;
}

static v7_val_t Crypto_base64_decode(struct v7 *v7, v7_val_t this_obj,
                                     v7_val_t args) {
  return b64_transform(v7, this_obj, args, (b64_func_t) cs_base64_decode, 0.75);
}

static v7_val_t Crypto_base64_encode(struct v7 *v7, v7_val_t this_obj,
                                     v7_val_t args) {
  return b64_transform(v7, this_obj, args, cs_base64_encode, 1.5);
}

static void v7_md5(const char *data, size_t len, char buf[16]) {
  MD5_CTX ctx;
  MD5_Init(&ctx);
  MD5_Update(&ctx, (unsigned char *) data, len);
  MD5_Final((unsigned char *) buf, &ctx);
}

static void v7_sha1(const char *data, size_t len, char buf[20]) {
  SHA1_CTX ctx;
  SHA1Init(&ctx);
  SHA1Update(&ctx, (unsigned char *) data, len);
  SHA1Final((unsigned char *) buf, &ctx);
}

static void bin2str(char *to, const unsigned char *p, size_t len) {
  static const char *hex = "0123456789abcdef";

  for (; len--; p++) {
    *to++ = hex[p[0] >> 4];
    *to++ = hex[p[0] & 0x0f];
  }
}

static v7_val_t Crypto_md5(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);

  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t len;
    const char *data = v7_to_string(v7, &arg0, &len);
    char buf[16];
    v7_md5(data, len, buf);
    return v7_create_string(v7, buf, sizeof(buf), 1);
  }
  return v7_create_null();
}

static v7_val_t Crypto_md5_hex(struct v7 *v7, v7_val_t this_obj,
                               v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);

  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t len;
    const char *data = v7_to_string(v7, &arg0, &len);
    char hash[16], buf[sizeof(hash) * 2];
    v7_md5(data, len, hash);
    bin2str(buf, (unsigned char *) hash, sizeof(hash));
    return v7_create_string(v7, buf, sizeof(buf), 1);
  }
  return v7_create_null();
}

static v7_val_t Crypto_sha1(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);

  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t len;
    const char *data = v7_to_string(v7, &arg0, &len);
    char buf[20];
    v7_sha1(data, len, buf);
    return v7_create_string(v7, buf, sizeof(buf), 1);
  }
  return v7_create_null();
}

static v7_val_t Crypto_sha1_hex(struct v7 *v7, v7_val_t this_obj,
                                v7_val_t args) {
  v7_val_t arg0 = v7_array_get(v7, args, 0);

  (void) this_obj;
  if (v7_is_string(arg0)) {
    size_t len;
    const char *data = v7_to_string(v7, &arg0, &len);
    char hash[20], buf[sizeof(hash) * 2];
    v7_sha1(data, len, hash);
    bin2str(buf, (unsigned char *) hash, sizeof(hash));
    return v7_create_string(v7, buf, sizeof(buf), 1);
  }
  return v7_create_null();
}
#endif

void init_crypto(struct v7 *v7) {
#ifdef V7_ENABLE_CRYPTO
  v7_val_t obj = v7_create_object(v7);
  v7_set(v7, v7_get_global_object(v7), "Crypto", 6, 0, obj);
  v7_set_method(v7, obj, "md5", Crypto_md5);
  v7_set_method(v7, obj, "md5_hex", Crypto_md5_hex);
  v7_set_method(v7, obj, "sha1", Crypto_sha1);
  v7_set_method(v7, obj, "sha1_hex", Crypto_sha1_hex);
  v7_set_method(v7, obj, "base64_encode", Crypto_base64_encode);
  v7_set_method(v7, obj, "base64_decode", Crypto_base64_decode);
#else
  (void) v7;
#endif
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


/*
 * Strings in AST are encoded as tuples (length, string).
 * Length is variable-length: if high bit is set in a byte, next byte is used.
 * Maximum string length with such encoding is 2 ^ (7 * 4) == 256 MiB,
 * assuming that sizeof(size_t) == 4.
 * Small string length (less then 128 bytes) is encoded in 1 byte.
 */
V7_PRIVATE size_t decode_varint(const unsigned char *p, int *llen) {
  size_t i = 0, string_len = 0;

  do {
    /*
     * Each byte of varint contains 7 bits, in little endian order.
     * MSB is a continuation bit: it tells whether next byte is used.
     */
    string_len |= (p[i] & 0x7f) << (7 * i);
    /*
     * First we increment i, then check whether it is within boundary and
     * whether decoded byte had continuation bit set.
     */
  } while (++i < sizeof(size_t) && (p[i - 1] & 0x80));
  *llen = i;

  return string_len;
}

/* Return number of bytes to store length */
V7_PRIVATE int calc_llen(size_t len) {
  int n = 0;

  do {
    n++;
  } while (len >>= 7);

  assert(n <= (int) sizeof(len));

  return n;
}

V7_PRIVATE int encode_varint(size_t len, unsigned char *p) {
  int i, llen = calc_llen(len);

  for (i = 0; i < llen; i++) {
    p[i] = (len & 0x7f) | (i < llen - 1 ? 0x80 : 0);
    len >>= 7;
  }

  return llen;
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


/*
 * NOTE(lsm): Must be in the same order as enum for keywords. See comment
 * for function get_tok() for rationale for that.
 */
static const struct v7_vec s_keywords[] = {
    V7_VEC("break"),      V7_VEC("case"),     V7_VEC("catch"),
    V7_VEC("continue"),   V7_VEC("debugger"), V7_VEC("default"),
    V7_VEC("delete"),     V7_VEC("do"),       V7_VEC("else"),
    V7_VEC("false"),      V7_VEC("finally"),  V7_VEC("for"),
    V7_VEC("function"),   V7_VEC("if"),       V7_VEC("in"),
    V7_VEC("instanceof"), V7_VEC("new"),      V7_VEC("null"),
    V7_VEC("return"),     V7_VEC("switch"),   V7_VEC("this"),
    V7_VEC("throw"),      V7_VEC("true"),     V7_VEC("try"),
    V7_VEC("typeof"),     V7_VEC("var"),      V7_VEC("void"),
    V7_VEC("while"),      V7_VEC("with")};

V7_PRIVATE int is_reserved_word_token(enum v7_tok tok) {
  return tok >= TOK_BREAK && tok <= TOK_WITH;
}

/*
 * Move ptr to the next token, skipping comments and whitespaces.
 * Return number of new line characters detected.
 */
V7_PRIVATE int skip_to_next_tok(const char **ptr) {
  const char *s = *ptr, *p = NULL;
  int num_lines = 0;

  while (s != p && *s != '\0' && (isspace((unsigned char) *s) || *s == '/')) {
    p = s;
    while (*s != '\0' && isspace((unsigned char) *s)) {
      if (*s == '\n') num_lines++;
      s++;
    }
    if (s[0] == '/' && s[1] == '/') {
      s += 2;
      while (s[0] != '\0' && s[0] != '\n') s++;
    }
    if (s[0] == '/' && s[1] == '*') {
      s += 2;
      while (s[0] != '\0' && !(s[-1] == '/' && s[-2] == '*')) {
        if (s[0] == '\n') num_lines++;
        s++;
      }
    }
  }
  *ptr = s;

  return num_lines;
}

/* Advance `s` pointer to the end of identifier  */
static void ident(const char **s) {
  const unsigned char *p = (unsigned char *) *s;
  int n;
  Rune r;

  while (p[0] != '\0') {
    if (p[0] == '$' || p[0] == '_' || isalnum(p[0])) {
      /* $, _, or any alphanumeric are valid identifier characters */
      p++;
    } else if (p[0] == '\\' && p[1] == 'u' && isxdigit(p[2]) &&
               isxdigit(p[3]) && isxdigit(p[4]) && isxdigit(p[5])) {
      /* Unicode escape, \uXXXX . Could be used like "var \u0078 = 1;" */
      p += 6;
    } else if ((n = chartorune(&r, (char *) p)) > 1 && isalpharune(r)) {
      /* Unicode alphanumeric character */
      p += n;
    } else {
      break;
    }
  }

  *s = (char *) p;
}

static enum v7_tok kw(const char *s, int len, int ntoks, enum v7_tok tok) {
  int i;

  for (i = 0; i < ntoks; i++) {
    if (s_keywords[(tok - TOK_BREAK) + i].len == len &&
        memcmp(s_keywords[(tok - TOK_BREAK) + i].p + 1, s + 1, len - 1) == 0)
      break;
  }

  return i == ntoks ? TOK_IDENTIFIER : (enum v7_tok)(tok + i);
}

static enum v7_tok punct1(const char **s, int ch1, enum v7_tok tok1,
                          enum v7_tok tok2) {
  (*s)++;
  if (s[0][0] == ch1) {
    (*s)++;
    return tok1;
  } else {
    return tok2;
  }
}

static enum v7_tok punct2(const char **s, int ch1, enum v7_tok tok1, int ch2,
                          enum v7_tok tok2, enum v7_tok tok3) {
  if (s[0][1] == ch1 && s[0][2] == ch2) {
    (*s) += 3;
    return tok2;
  }

  return punct1(s, ch1, tok1, tok3);
}

static enum v7_tok punct3(const char **s, int ch1, enum v7_tok tok1, int ch2,
                          enum v7_tok tok2, enum v7_tok tok3) {
  (*s)++;
  if (s[0][0] == ch1) {
    (*s)++;
    return tok1;
  } else if (s[0][0] == ch2) {
    (*s)++;
    return tok2;
  } else {
    return tok3;
  }
}

static void parse_number(const char *s, const char **end, double *num) {
  *num = strtod(s, (char **) end);
}

static enum v7_tok parse_str_literal(const char **p) {
  const char *s = *p;
  int quote = *s++;

  /* Scan string literal, handle escape sequences */
  for (; *s != quote && *s != '\0'; s++) {
    if (*s == '\\') {
      switch (s[1]) {
        case 'b':
        case 'f':
        case 'n':
        case 'r':
        case 't':
        case 'v':
        case '\\':
          s++;
          break;
        default:
          if (s[1] == quote) s++;
          break;
      }
    }
  }

  if (*s == quote) {
    s++;
    *p = s;
    return TOK_STRING_LITERAL;
  } else {
    return TOK_END_OF_INPUT;
  }
}

/*
 * This function is the heart of the tokenizer.
 * Organized as a giant switch statement.
 *
 * Switch statement is by the first character of the input stream. If first
 * character begins with a letter, it could be either keyword or identifier.
 * get_tok() calls ident() which shifts `s` pointer to the end of the word.
 * Now, tokenizer knows that the word begins at `p` and ends at `s`.
 * It calls function kw() to scan over the keywords that start with `p[0]`
 * letter. Therefore, keyword tokens and keyword strings must be in the
 * same order, to let kw() function work properly.
 * If kw() finds a keyword match, it returns keyword token.
 * Otherwise, it returns TOK_IDENTIFIER.
 * NOTE(lsm): `prev_tok` is a previously parsed token. It is needed for
 * correctly parsing regex literals.
 */
V7_PRIVATE enum v7_tok get_tok(const char **s, double *n,
                               enum v7_tok prev_tok) {
  const char *p = *s;

  switch (*p) {
    /* Letters */
    case 'a':
      ident(s);
      return TOK_IDENTIFIER;
    case 'b':
      ident(s);
      return kw(p, *s - p, 1, TOK_BREAK);
    case 'c':
      ident(s);
      return kw(p, *s - p, 3, TOK_CASE);
    case 'd':
      ident(s);
      return kw(p, *s - p, 4, TOK_DEBUGGER);
    case 'e':
      ident(s);
      return kw(p, *s - p, 1, TOK_ELSE);
    case 'f':
      ident(s);
      return kw(p, *s - p, 4, TOK_FALSE);
    case 'g':
    case 'h':
      ident(s);
      return TOK_IDENTIFIER;
    case 'i':
      ident(s);
      return kw(p, *s - p, 3, TOK_IF);
    case 'j':
    case 'k':
    case 'l':
    case 'm':
      ident(s);
      return TOK_IDENTIFIER;
    case 'n':
      ident(s);
      return kw(p, *s - p, 2, TOK_NEW);
    case 'o':
    case 'p':
    case 'q':
      ident(s);
      return TOK_IDENTIFIER;
    case 'r':
      ident(s);
      return kw(p, *s - p, 1, TOK_RETURN);
    case 's':
      ident(s);
      return kw(p, *s - p, 1, TOK_SWITCH);
    case 't':
      ident(s);
      return kw(p, *s - p, 5, TOK_THIS);
    case 'u':
      ident(s);
      return TOK_IDENTIFIER;
    case 'v':
      ident(s);
      return kw(p, *s - p, 2, TOK_VAR);
    case 'w':
      ident(s);
      return kw(p, *s - p, 2, TOK_WHILE);
    case 'x':
    case 'y':
    case 'z':
      ident(s);
      return TOK_IDENTIFIER;

    case '_':
    case '$':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '\\': /* Identifier may start with unicode escape sequence */
      ident(s);
      return TOK_IDENTIFIER;

    /* Numbers */
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      parse_number(p, s, n);
      return TOK_NUMBER;

    /* String literals */
    case '\'':
    case '"':
      return parse_str_literal(s);

    /* Punctuators */
    case '=':
      return punct2(s, '=', TOK_EQ, '=', TOK_EQ_EQ, TOK_ASSIGN);
    case '!':
      return punct2(s, '=', TOK_NE, '=', TOK_NE_NE, TOK_NOT);

    case '%':
      return punct1(s, '=', TOK_REM_ASSIGN, TOK_REM);
    case '*':
      return punct1(s, '=', TOK_MUL_ASSIGN, TOK_MUL);
    case '/':
      /*
       * TOK_DIV, TOK_DIV_ASSIGN, and TOK_REGEX_LITERAL start with `/` char.
       * Division can happen after an expression.
       * In expressions like this:
       *            a /= b; c /= d;
       * things between slashes is NOT a regex literal.
       * The switch below catches all cases where division happens.
       */
      switch (prev_tok) {
        case TOK_CLOSE_CURLY:
        case TOK_CLOSE_PAREN:
        case TOK_CLOSE_BRACKET:
        case TOK_IDENTIFIER:
        case TOK_NUMBER:
          return punct1(s, '=', TOK_DIV_ASSIGN, TOK_DIV);
          break;
        default:
          /* Not a division - this is a regex. Scan until closing slash */
          for (p++; *p != '\0' && *p != '\n'; p++) {
            if (*p == '\\') {
              /* Skip escape sequence */
              p++;
            } else if (*p == '/') {
              /* This is a closing slash */
              p++;
              /* Skip regex flags */
              while (*p == 'g' || *p == 'i' || *p == 'm') {
                p++;
              }
              *s = p;
              return TOK_REGEX_LITERAL;
            }
          }
          break;
      }
      return punct1(s, '=', TOK_DIV_ASSIGN, TOK_DIV);
    case '^':
      return punct1(s, '=', TOK_XOR_ASSIGN, TOK_XOR);

    case '+':
      return punct3(s, '+', TOK_PLUS_PLUS, '=', TOK_PLUS_ASSIGN, TOK_PLUS);
    case '-':
      return punct3(s, '-', TOK_MINUS_MINUS, '=', TOK_MINUS_ASSIGN, TOK_MINUS);
    case '&':
      return punct3(s, '&', TOK_LOGICAL_AND, '=', TOK_AND_ASSIGN, TOK_AND);
    case '|':
      return punct3(s, '|', TOK_LOGICAL_OR, '=', TOK_OR_ASSIGN, TOK_OR);

    case '<':
      if (s[0][1] == '=') {
        (*s) += 2;
        return TOK_LE;
      }
      return punct2(s, '<', TOK_LSHIFT, '=', TOK_LSHIFT_ASSIGN, TOK_LT);
    case '>':
      if (s[0][1] == '=') {
        (*s) += 2;
        return TOK_GE;
      }
      if (s[0][1] == '>' && s[0][2] == '>' && s[0][3] == '=') {
        (*s) += 4;
        return TOK_URSHIFT_ASSIGN;
      }
      if (s[0][1] == '>' && s[0][2] == '>') {
        (*s) += 3;
        return TOK_URSHIFT;
      }
      return punct2(s, '>', TOK_RSHIFT, '=', TOK_RSHIFT_ASSIGN, TOK_GT);

    case '{':
      (*s)++;
      return TOK_OPEN_CURLY;
    case '}':
      (*s)++;
      return TOK_CLOSE_CURLY;
    case '(':
      (*s)++;
      return TOK_OPEN_PAREN;
    case ')':
      (*s)++;
      return TOK_CLOSE_PAREN;
    case '[':
      (*s)++;
      return TOK_OPEN_BRACKET;
    case ']':
      (*s)++;
      return TOK_CLOSE_BRACKET;
    case '.':
      switch (*(*s + 1)) {
        /* Numbers */
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          parse_number(p, s, n);
          return TOK_NUMBER;
      }
      (*s)++;
      return TOK_DOT;
    case ';':
      (*s)++;
      return TOK_SEMICOLON;
    case ':':
      (*s)++;
      return TOK_COLON;
    case '?':
      (*s)++;
      return TOK_QUESTION;
    case '~':
      (*s)++;
      return TOK_TILDA;
    case ',':
      (*s)++;
      return TOK_COMMA;

    default: {
      /* Handle unicode variables */
      Rune r;
      int n;

      if ((n = chartorune(&r, *s)) > 1 && isalpharune(r)) {
        ident(s);
        return TOK_IDENTIFIER;
      }
      return TOK_END_OF_INPUT;
    }
  }
}

#ifdef TEST_RUN
int main(void) {
  const char *src =
      "for (var fo++ = -1; /= <= 1.17; x<<) { == <<=, 'x')} "
      "Infinity %=x<<=2";
  enum v7_tok tok;
  double num;
  const char *p = src;

  skip_to_next_tok(&src);
  while ((tok = get_tok(&src, &num)) != TOK_END_OF_INPUT) {
    printf("%d [%.*s]\n", tok, (int) (src - p), p);
    skip_to_next_tok(&src);
    p = src;
  }
  printf("%d [%.*s]\n", tok, (int) (src - p), p);

  return 0;
}
#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


typedef unsigned short ast_skip_t;

#ifndef V7_DISABLE_AST_TAG_NAMES
#define AST_ENTRY(a, b, c, d, e) \
  { (a), (b), (c), (d), (e) }
#else
#define AST_ENTRY(a, b, c, d, e) \
  { (b), (c), (d), (e) }
#endif

/*
 * The structure of AST nodes cannot be described in portable ANSI C,
 * since they are variable length and packed (unaligned).
 *
 * Here each node's body is described with a pseudo-C structure notation.
 * The pseudo type `child` represents a variable length byte sequence
 * representing a fully serialized child node.
 *
 * `child body[]` represents a sequence of such subtrees.
 *
 * Pseudo-labels, such as `end:` represent the targets of skip fields
 * with the same name (e.g. `ast_skip_t end`).
 *
 * Skips allow skipping a subtree or sequence of subtrees.
 *
 * Sequences of subtrees (i.e. `child []`) have to be terminated by a skip:
 * they don't have a termination tag; all nodes whose position is before the
 * skip are part of the sequence.
 *
 * Skips are encoded as network-byte-order 16-bit offsets counted from the
 * first byte of the node body (i.e. not counting the tag itself).
 * This currently limits the the maximum size of a function body to 64k.
 *
 * Notes:
 *
 * - Some nodes contain skips just for performance or because it simplifies
 * the implementation of the interpreter. For example, technically, the FOR
 * node doesn't need the `body` skip in order to be correctly traversed.
 * However, being able to quickly skip the `iter` expression is useful
 * also because it allows the interpreter to avoid traversing the expression
 * subtree without evaluating it, just in order to find the next subtree.
 *
 * - The name `skip` was chosen because `offset` was too overloaded in general
 * and label` is part of our domain model (i.e. JS has a label AST node type).
 *
 */
const struct ast_node_def ast_node_defs[] = {
    AST_ENTRY("NOP", 0, 0, 0, 0), /* struct {} */

    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t first_var;
     *   child body[];
     * end:
     * }
     */
    AST_ENTRY("SCRIPT", 0, 0, 2, 0),
    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t next;
     *   child decls[];
     * end:
     * }
     */
    AST_ENTRY("VAR", 0, 0, 2, 0),
    /*
     * struct {
     *   varint len;
     *   char name[len];
     *   child expr;
     * }
     */
    AST_ENTRY("VAR_DECL", 1, 1, 0, 1),
    /*
     * struct {
     *   varint len;
     *   char name[len];
     *   child expr;
     * }
     */
    AST_ENTRY("FUNC_DECL", 1, 1, 0, 1),
    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t end_true;
     *   child cond;
     *   child iftrue[];
     * end_true:
     *   child iffalse[];
     * end:
     * }
     */
    AST_ENTRY("IF", 0, 0, 2, 1),
    /*
     * TODO(mkm) distinguish function expressions
     * from function statements.
     * Function statements behave like vars and need a
     * next field for hoisting.
     * We can also ignore the name for function expressions
     * if it's only needed for debugging.
     *
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t first_var;
     *   ast_skip_t body;
     *   child name;
     *   child params[];
     * body:
     *   child body[];
     * end:
     * }
     */
    AST_ENTRY("FUNC", 0, 0, 3, 1),
    AST_ENTRY("ASSIGN", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("REM_ASSIGN", 0, 0, 0, 2),     /* struct { child left, right; } */
    AST_ENTRY("MUL_ASSIGN", 0, 0, 0, 2),     /* struct { child left, right; } */
    AST_ENTRY("DIV_ASSIGN", 0, 0, 0, 2),     /* struct { child left, right; } */
    AST_ENTRY("XOR_ASSIGN", 0, 0, 0, 2),     /* struct { child left, right; } */
    AST_ENTRY("PLUS_ASSIGN", 0, 0, 0, 2),    /* struct { child left, right; } */
    AST_ENTRY("MINUS_ASSIGN", 0, 0, 0, 2),   /* struct { child left, right; } */
    AST_ENTRY("OR_ASSIGN", 0, 0, 0, 2),      /* struct { child left, right; } */
    AST_ENTRY("AND_ASSIGN", 0, 0, 0, 2),     /* struct { child left, right; } */
    AST_ENTRY("LSHIFT_ASSIGN", 0, 0, 0, 2),  /* struct { child left, right; } */
    AST_ENTRY("RSHIFT_ASSIGN", 0, 0, 0, 2),  /* struct { child left, right; } */
    AST_ENTRY("URSHIFT_ASSIGN", 0, 0, 0, 2), /* struct { child left, right; } */
    AST_ENTRY("NUM", 1, 1, 0, 0),    /* struct { varint len, char s[len]; } */
    AST_ENTRY("IDENT", 1, 1, 0, 0),  /* struct { varint len, char s[len]; } */
    AST_ENTRY("STRING", 1, 1, 0, 0), /* struct { varint len, char s[len]; } */
    AST_ENTRY("REGEX", 1, 1, 0, 0),  /* struct { varint len, char s[len]; } */
    AST_ENTRY("LABEL", 1, 1, 0, 0),  /* struct { varint len, char s[len]; } */

    /*
     * struct {
     *   ast_skip_t end;
     *   child body[];
     * end:
     * }
     */
    AST_ENTRY("SEQ", 0, 0, 1, 0),
    /*
     * struct {
     *   ast_skip_t end;
     *   child cond;
     *   child body[];
     * end:
     * }
     */
    AST_ENTRY("WHILE", 0, 0, 1, 1),
    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t cond;
     *   child body[];
     * cond:
     *   child cond;
     * end:
     * }
     */
    AST_ENTRY("DOWHILE", 0, 0, 2, 0),
    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t body;
     *   child init;
     *   child cond;
     *   child iter;
     * body:
     *   child body[];
     * end:
     * }
     */
    AST_ENTRY("FOR", 0, 0, 2, 3),
    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t dummy; // allows to quickly promote a for to a for in
     *   child var;
     *   child expr;
     *   child dummy;
     *   child body[];
     * end:
     * }
     */
    AST_ENTRY("FOR_IN", 0, 0, 2, 3),
    AST_ENTRY("COND", 0, 0, 0, 3), /* struct { child cond, iftrue, iffalse; } */
    AST_ENTRY("DEBUGGER", 0, 0, 0, 0), /* struct {} */
    AST_ENTRY("BREAK", 0, 0, 0, 0),    /* struct {} */

    /*
     * struct {
     *   child label; // TODO(mkm): inline
     * }
     */
    AST_ENTRY("LAB_BREAK", 0, 0, 0, 1),
    AST_ENTRY("CONTINUE", 0, 0, 0, 0), /* struct {} */

    /*
     * struct {
     *   child label; // TODO(mkm): inline
     * }
     */
    AST_ENTRY("LAB_CONTINUE", 0, 0, 0, 1),
    AST_ENTRY("RETURN", 0, 0, 0, 0),     /* struct {} */
    AST_ENTRY("VAL_RETURN", 0, 0, 0, 1), /* struct { child expr; } */
    AST_ENTRY("THROW", 0, 0, 0, 1),      /* struct { child expr; } */

    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t catch;
     *   ast_skip_t finally;
     *   child try[];
     * catch:
     *   child var; // TODO(mkm): inline
     *   child catch[];
     * finally:
     *   child finally[];
     * end:
     * }
     */
    AST_ENTRY("TRY", 0, 0, 3, 1),
    /*
     * struct {
     *   ast_skip_t end;
     *   ast_skip_t def;
     *   child expr;
     *   child cases[];
     * def:
     *   child default?; // optional
     * end:
     * }
     */
    AST_ENTRY("SWITCH", 0, 0, 2, 1),
    /*
     * struct {
     *   ast_skip_t end;
     *   child val;
     *   child stmts[];
     * end:
     * }
     */
    AST_ENTRY("CASE", 0, 0, 1, 1),
    /*
     * struct {
     *   ast_skip_t end;
     *   child stmts[];
     * end:
     * }
     */
    AST_ENTRY("DEFAULT", 0, 0, 1, 0),
    /*
     * struct {
     *   ast_skip_t end;
     *   child expr;
     *   child body[];
     * end:
     * }
     */
    AST_ENTRY("WITH", 0, 0, 1, 1),
    AST_ENTRY("LOG_OR", 0, 0, 0, 2),      /* struct { child left, right; } */
    AST_ENTRY("LOG_AND", 0, 0, 0, 2),     /* struct { child left, right; } */
    AST_ENTRY("OR", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("XOR", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("AND", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("EQ", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("EQ_EQ", 0, 0, 0, 2),       /* struct { child left, right; } */
    AST_ENTRY("NE", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("NE_NE", 0, 0, 0, 2),       /* struct { child left, right; } */
    AST_ENTRY("LE", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("LT", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("GE", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("GT", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("IN", 0, 0, 0, 2),          /* struct { child left, right; } */
    AST_ENTRY("INSTANCEOF", 0, 0, 0, 2),  /* struct { child left, right; } */
    AST_ENTRY("LSHIFT", 0, 0, 0, 2),      /* struct { child left, right; } */
    AST_ENTRY("RSHIFT", 0, 0, 0, 2),      /* struct { child left, right; } */
    AST_ENTRY("URSHIFT", 0, 0, 0, 2),     /* struct { child left, right; } */
    AST_ENTRY("ADD", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("SUB", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("REM", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("MUL", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("DIV", 0, 0, 0, 2),         /* struct { child left, right; } */
    AST_ENTRY("POS", 0, 0, 0, 1),         /* struct { child expr; } */
    AST_ENTRY("NEG", 0, 0, 0, 1),         /* struct { child expr; } */
    AST_ENTRY("NOT", 0, 0, 0, 1),         /* struct { child expr; } */
    AST_ENTRY("LOGICAL_NOT", 0, 0, 0, 1), /* struct { child expr; } */
    AST_ENTRY("VOID", 0, 0, 0, 1),        /* struct { child expr; } */
    AST_ENTRY("DELETE", 0, 0, 0, 1),      /* struct { child expr; } */
    AST_ENTRY("TYPEOF", 0, 0, 0, 1),      /* struct { child expr; } */
    AST_ENTRY("PREINC", 0, 0, 0, 1),      /* struct { child expr; } */
    AST_ENTRY("PREDEC", 0, 0, 0, 1),      /* struct { child expr; } */
    AST_ENTRY("POSTINC", 0, 0, 0, 1),     /* struct { child expr; } */
    AST_ENTRY("POSTDEC", 0, 0, 0, 1),     /* struct { child expr; } */

    /*
     * struct {
     *   varint len;
     *   char ident[len];
     *   child expr;
     * }
     */
    AST_ENTRY("MEMBER", 1, 1, 0, 1),
    /*
     * struct {
     *   child expr;
     *   child index;
     * }
     */
    AST_ENTRY("INDEX", 0, 0, 0, 2),
    /*
     * struct {
     *   ast_skip_t end;
     *   child expr;
     *   child args[];
     * end:
     * }
     */
    AST_ENTRY("CALL", 0, 0, 1, 1),
    /*
     * struct {
     *   ast_skip_t end;
     *   child expr;
     *   child args[];
     * end:
     * }
     */
    AST_ENTRY("NEW", 0, 0, 1, 1),
    /*
     * struct {
     *   ast_skip_t end;
     *   child elements[];
     * end:
     * }
     */
    AST_ENTRY("ARRAY", 0, 0, 1, 0),
    /*
     * struct {
     *   ast_skip_t end;
     *   child props[];
     * end:
     * }
     */
    AST_ENTRY("OBJECT", 0, 0, 1, 0),
    /*
     * struct {
     *   varint len;
     *   char name[len];
     *   child expr;
     * }
     */
    AST_ENTRY("PROP", 1, 1, 0, 1),
    /*
     * struct {
     *   child func;
     * }
     */
    AST_ENTRY("GETTER", 0, 0, 0, 1),
    /*
     * struct {
     *   child func;
     * end:
     * }
     */
    AST_ENTRY("SETTER", 0, 0, 0, 1),
    AST_ENTRY("THIS", 0, 0, 0, 0),       /* struct {} */
    AST_ENTRY("TRUE", 0, 0, 0, 0),       /* struct {} */
    AST_ENTRY("FALSE", 0, 0, 0, 0),      /* struct {} */
    AST_ENTRY("NULL", 0, 0, 0, 0),       /* struct {} */
    AST_ENTRY("UNDEF", 0, 0, 0, 0),      /* struct {} */
    AST_ENTRY("USE_STRICT", 0, 0, 0, 0), /* struct {} */
};

V7_STATIC_ASSERT(AST_MAX_TAG < 256, ast_tag_should_fit_in_char);
V7_STATIC_ASSERT(AST_MAX_TAG == ARRAY_SIZE(ast_node_defs), bad_node_defs);

/*
 * Begins an AST node by appending a tag to the AST.
 *
 * It also allocates space for the fixed_size payload and the space for
 * the skips.
 *
 * The caller is responsible for appending children.
 *
 * Returns the offset of the node payload (one byte after the tag).
 * This offset can be passed to `ast_set_skip`.
 */
V7_PRIVATE ast_off_t ast_add_node(struct ast *a, enum ast_tag tag) {
  ast_off_t start = a->mbuf.len;
  uint8_t t = (uint8_t) tag;
  const struct ast_node_def *d = &ast_node_defs[tag];

  assert(tag < AST_MAX_TAG);
  mbuf_append(&a->mbuf, (char *) &t, sizeof(t));
  mbuf_append(&a->mbuf, NULL, sizeof(ast_skip_t) * d->num_skips);
  return start + 1;
}

V7_PRIVATE ast_off_t
ast_insert_node(struct ast *a, ast_off_t start, enum ast_tag tag) {
  uint8_t t = (uint8_t) tag;
  const struct ast_node_def *d = &ast_node_defs[tag];

  assert(tag < AST_MAX_TAG);

  mbuf_insert(&a->mbuf, start, NULL, sizeof(ast_skip_t) * d->num_skips);
  mbuf_insert(&a->mbuf, start, (char *) &t, sizeof(t));

  if (d->num_skips) {
    ast_set_skip(a, start + 1, AST_END_SKIP);
  }

  return start + 1;
}

V7_STATIC_ASSERT(sizeof(ast_skip_t) == 2, ast_skip_t_len_should_be_2);

/*
 * Patches a given skip slot for an already emitted node with the
 * current write cursor position (e.g. AST length).
 *
 * This is intended to be invoked when a node with a variable number
 * of child subtrees is closed, or when the consumers need a shortcut
 * to the next sibling.
 *
 * Each node type has a different number and semantic for skips,
 * all of them defined in the `ast_which_skip` enum.
 * All nodes having a variable number of child subtrees must define
 * at least the `AST_END_SKIP` skip, which effectively skips a node
 * boundary.
 *
 * Every tree reader can assume this and safely skip unknown nodes.
 */
V7_PRIVATE ast_off_t
ast_set_skip(struct ast *a, ast_off_t start, enum ast_which_skip skip) {
  return ast_modify_skip(a, start, a->mbuf.len, skip);
}

/*
 * Patches a given skip slot for an already emitted node with the value
 * (stored as delta relative to the `start` node) of the `where` argument.
 */
V7_PRIVATE ast_off_t ast_modify_skip(struct ast *a, ast_off_t start,
                                     ast_off_t where,
                                     enum ast_which_skip skip) {
  uint8_t *p = (uint8_t *) a->mbuf.buf + start + skip * sizeof(ast_skip_t);
  uint16_t delta = where - start;
  enum ast_tag tag = (enum ast_tag)(uint8_t) * (a->mbuf.buf + start - 1);
  const struct ast_node_def *def = &ast_node_defs[tag];

  /* assertion, to be optimizable out */
  assert((int) skip < def->num_skips);

  p[0] = delta >> 8;
  p[1] = delta & 0xff;
  return where;
}

V7_PRIVATE ast_off_t
ast_get_skip(struct ast *a, ast_off_t pos, enum ast_which_skip skip) {
  uint8_t *p;
  assert(pos + skip * sizeof(ast_skip_t) < a->mbuf.len);

  p = (uint8_t *) a->mbuf.buf + pos + skip * sizeof(ast_skip_t);
  return pos + (p[1] | p[0] << 8);
}

V7_PRIVATE enum ast_tag ast_fetch_tag(struct ast *a, ast_off_t *pos) {
  assert(*pos < a->mbuf.len);
  return (enum ast_tag)(uint8_t) * (a->mbuf.buf + (*pos)++);
}

/*
 * Assumes a cursor positioned right after a tag.
 *
 * TODO(mkm): add doc, find better name.
 */
V7_PRIVATE void ast_move_to_children(struct ast *a, ast_off_t *pos) {
  enum ast_tag tag = (enum ast_tag)(uint8_t) * (a->mbuf.buf + *pos - 1);
  const struct ast_node_def *def = &ast_node_defs[tag];
  assert(*pos - 1 < a->mbuf.len);
  if (def->has_varint) {
    int llen;
    size_t slen = decode_varint((unsigned char *) a->mbuf.buf + *pos, &llen);
    *pos += llen;
    if (def->has_inlined) {
      *pos += slen;
    }
  }

  *pos += def->num_skips * sizeof(ast_skip_t);
}

/* Helper to add a node with inlined data. */
V7_PRIVATE void ast_add_inlined_node(struct ast *a, enum ast_tag tag,
                                     const char *name, size_t len) {
  assert(ast_node_defs[tag].has_inlined);
  embed_string(&a->mbuf, ast_add_node(a, tag), name, len, 0, 1);
}

/* Helper to add a node with inlined data. */
V7_PRIVATE void ast_insert_inlined_node(struct ast *a, ast_off_t start,
                                        enum ast_tag tag, const char *name,
                                        size_t len) {
  assert(ast_node_defs[tag].has_inlined);
  embed_string(&a->mbuf, ast_insert_node(a, start, tag), name, len, 0, 1);
}

V7_PRIVATE char *ast_get_inlined_data(struct ast *a, ast_off_t pos, size_t *n) {
  int llen;
  assert(pos < a->mbuf.len);
  *n = decode_varint((unsigned char *) a->mbuf.buf + pos, &llen);
  return a->mbuf.buf + pos + llen;
}

V7_PRIVATE void ast_get_num(struct ast *a, ast_off_t pos, double *val) {
  char tmp;
  char *str;
  size_t str_len;
  str = ast_get_inlined_data(a, pos, &str_len);
  tmp = str[str_len];
  str[str_len] = '\0';
  *val = strtod(str, NULL);
  str[str_len] = tmp;
}

#ifndef NO_LIBC
static void comment_at_depth(FILE *fp, const char *fmt, int depth, ...) {
  int i;
  STATIC char buf[256];
  va_list ap;
  va_start(ap, depth);

  c_vsnprintf(buf, sizeof(buf), fmt, ap);

  for (i = 0; i < depth; i++) {
    fprintf(fp, "  ");
  }
  fprintf(fp, "/* [%s] */\n", buf);
}
#endif

V7_PRIVATE void ast_skip_tree(struct ast *a, ast_off_t *pos) {
  enum ast_tag tag = ast_fetch_tag(a, pos);
  const struct ast_node_def *def = &ast_node_defs[tag];
  ast_off_t skips = *pos;
  int i;
  ast_move_to_children(a, pos);

  for (i = 0; i < def->num_subtrees; i++) {
    ast_skip_tree(a, pos);
  }

  if (ast_node_defs[tag].num_skips) {
    ast_off_t end = ast_get_skip(a, skips, AST_END_SKIP);

    while (*pos < end) {
      ast_skip_tree(a, pos);
    }
  }
}

#ifndef NO_LIBC
static void ast_dump_tree(FILE *fp, struct ast *a, ast_off_t *pos, int depth) {
  enum ast_tag tag = ast_fetch_tag(a, pos);
  const struct ast_node_def *def = &ast_node_defs[tag];
  ast_off_t skips = *pos;
  size_t slen;
  int i, llen;

  for (i = 0; i < depth; i++) {
    fprintf(fp, "  ");
  }

#ifndef V7_DISABLE_AST_TAG_NAMES
  fprintf(fp, "%s", def->name);
#else
  fprintf(fp, "TAG_%d", tag);
#endif

  if (def->has_inlined) {
    slen = decode_varint((unsigned char *) a->mbuf.buf + *pos, &llen);
    fprintf(fp, " %.*s\n", (int) slen, a->mbuf.buf + *pos + llen);
  } else {
    fprintf(fp, "\n");
  }

  ast_move_to_children(a, pos);

  for (i = 0; i < def->num_subtrees; i++) {
    ast_dump_tree(fp, a, pos, depth + 1);
  }

  if (ast_node_defs[tag].num_skips) {
    /*
     * first skip always encodes end of the last children sequence.
     * so unless we care how the subtree sequences are grouped together
     * (and we currently don't) we can just read until the end of that skip.
     */
    ast_off_t end = ast_get_skip(a, skips, AST_END_SKIP);

    comment_at_depth(fp, "...", depth + 1);
    while (*pos < end) {
      int s;
      for (s = ast_node_defs[tag].num_skips - 1; s > 0; s--) {
        if (*pos == ast_get_skip(a, skips, (enum ast_which_skip) s)) {
          comment_at_depth(fp, "%d ->", depth + 1, s);
          break;
        }
      }
      ast_dump_tree(fp, a, pos, depth + 1);
    }
  }
}
#endif

V7_PRIVATE void ast_init(struct ast *ast, size_t len) {
  mbuf_init(&ast->mbuf, len);
  ast->refcnt = 0;
}

V7_PRIVATE void ast_optimize(struct ast *ast) {
  /*
   * leave one trailing byte so that literals can be
   * null terminated on the fly.
   */
  mbuf_resize(&ast->mbuf, ast->mbuf.len + 1);
}

V7_PRIVATE void ast_free(struct ast *ast) {
  mbuf_free(&ast->mbuf);
}

#ifndef NO_LIBC
/*
 * Generate Abstract Syntax Tree (AST) for the given JavaScript source code.
 * If `binary` is 0, then generated AST is in text format, otherwise it is
 * in the binary format. Binary AST is self-sufficient and can be executed
 * by V7 with no extra input.
 * `fp` must be an opened writable file stream to write compiled AST to.
 */
void v7_compile(const char *code, int binary, FILE *fp) {
  struct ast ast;
  struct v7 *v7 = v7_create();
  ast_off_t pos = 0;

  ast_init(&ast, 0);
  if (parse(v7, &ast, code, 1) != V7_OK) {
    fprintf(stderr, "%s\n", "parse error");
  } else if (binary) {
    fwrite(ast.mbuf.buf, ast.mbuf.len, 1, fp);
  } else {
    ast_dump_tree(fp, &ast, &pos, 0);
  }
  ast_free(&ast);
  v7_destroy(v7);
}
#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#ifdef HAS_V7_INFINITY
double _v7_infinity;
#endif

#ifdef HAS_V7_NAN
double _v7_nan;
#endif

#ifdef NO_LIBC
void fprint_str(FILE *fp, const char *str);
#endif

enum v7_type val_type(struct v7 *v7, val_t v) {
  int tag;
  if (v7_is_number(v)) {
    return V7_TYPE_NUMBER;
  }
  tag = (v & V7_TAG_MASK) >> 48;
  switch (tag) {
    case V7_TAG_FOREIGN >> 48:
      if (v7_is_null(v)) {
        return V7_TYPE_NULL;
      }
      return V7_TYPE_FOREIGN;
    case V7_TAG_UNDEFINED >> 48:
      return V7_TYPE_UNDEFINED;
    case V7_TAG_OBJECT >> 48:
      if (v7_to_object(v)->prototype == v7_to_object(v7->array_prototype)) {
        return V7_TYPE_ARRAY_OBJECT;
      } else if (v7_to_object(v)->prototype ==
                 v7_to_object(v7->boolean_prototype)) {
        return V7_TYPE_BOOLEAN_OBJECT;
      } else if (v7_to_object(v)->prototype ==
                 v7_to_object(v7->string_prototype)) {
        return V7_TYPE_STRING_OBJECT;
      } else if (v7_to_object(v)->prototype ==
                 v7_to_object(v7->number_prototype)) {
        return V7_TYPE_NUMBER_OBJECT;
      } else if (v7_to_object(v)->prototype ==
                 v7_to_object(v7->function_prototype)) {
        return V7_TYPE_CFUNCTION_OBJECT;
      } else if (v7_to_object(v)->prototype ==
                 v7_to_object(v7->date_prototype)) {
        return V7_TYPE_DATE_OBJECT;
      } else {
        return V7_TYPE_GENERIC_OBJECT;
      }
    case V7_TAG_STRING_I >> 48:
    case V7_TAG_STRING_O >> 48:
    case V7_TAG_STRING_F >> 48:
    case V7_TAG_STRING_5 >> 48:
      return V7_TYPE_STRING;
    case V7_TAG_BOOLEAN >> 48:
      return V7_TYPE_BOOLEAN;
    case V7_TAG_FUNCTION >> 48:
      return V7_TYPE_FUNCTION_OBJECT;
    case V7_TAG_CFUNCTION >> 48:
      return V7_TYPE_CFUNCTION;
    case V7_TAG_REGEXP >> 48:
      return V7_TYPE_REGEXP_OBJECT;
    default:
      /* TODO(mkm): or should we crash? */
      return V7_TYPE_UNDEFINED;
  }
}

int v7_is_number(val_t v) {
  return v == V7_TAG_NAN || !isnan(v7_to_number(v));
}

int v7_is_object(val_t v) {
  return (v & V7_TAG_MASK) == V7_TAG_OBJECT ||
         (v & V7_TAG_MASK) == V7_TAG_FUNCTION;
}

int v7_is_function(val_t v) {
  return (v & V7_TAG_MASK) == V7_TAG_FUNCTION;
}

int v7_is_string(val_t v) {
  uint64_t t = v & V7_TAG_MASK;
  return t == V7_TAG_STRING_I || t == V7_TAG_STRING_F || t == V7_TAG_STRING_O ||
         t == V7_TAG_STRING_5;
}

int v7_is_primitive_string(val_t v) {
  uint64_t t = v & V7_TAG_MASK;
  return t == V7_TAG_STRING_I || t == V7_TAG_STRING_F || t == V7_TAG_STRING_O ||
         t == V7_TAG_STRING_5;
}

int v7_is_boolean(val_t v) {
  return (v & V7_TAG_MASK) == V7_TAG_BOOLEAN;
}

int v7_is_regexp(struct v7 *v7, val_t v) {
  struct v7_property *p;
  if (!v7_is_object(v)) return 0;
  p = v7_get_own_property2(v7, v, "", 0, V7_PROPERTY_HIDDEN);
  if (p == NULL) return 0;
  return (p->value & V7_TAG_MASK) == V7_TAG_REGEXP;
}

int v7_is_foreign(val_t v) {
  return (v & V7_TAG_MASK) == V7_TAG_FOREIGN;
}

int v7_is_array(struct v7 *v7, val_t v) {
  return v7_is_object(v) && is_prototype_of(v7, v, v7->array_prototype);
}

V7_PRIVATE struct v7_regexp *v7_to_regexp(struct v7 *v7, val_t v) {
  struct v7_property *p;
  int is = v7_is_regexp(v7, v);
  assert(is == 1);
  p = v7_get_own_property2(v7, v, "", 0, V7_PROPERTY_HIDDEN);
  assert(p != NULL);
  return (struct v7_regexp *) v7_to_pointer(p->value);
}

int v7_is_null(val_t v) {
  return v == V7_NULL;
}

int v7_is_undefined(val_t v) {
  return v == V7_UNDEFINED;
}

int v7_is_cfunction(val_t v) {
  return (v & V7_TAG_MASK) == V7_TAG_CFUNCTION;
}

/* A convenience function to check exec result */
int v7_is_error(struct v7 *v7, val_t v) {
  return is_prototype_of(v7, v, v7->error_prototype);
}

V7_PRIVATE val_t v7_pointer_to_value(void *p) {
  return ((uint64_t)(uintptr_t) p) & ~V7_TAG_MASK;
}

V7_PRIVATE void *v7_to_pointer(val_t v) {
  return (void *) (uintptr_t)(v & 0xFFFFFFFFFFFFUL);
}

v7_cfunction_t v7_to_cfunction(val_t v) {
  /* Implementation is identical to v7_to_pointer but is separate since
   * object pointers are not directly convertible to function pointers
   * according to ISO C and generates a warning in -Wpedantic mode. */
  return (v7_cfunction_t)(uintptr_t)(v & 0xFFFFFFFFFFFFUL);
}

val_t v7_object_to_value(struct v7_object *o) {
  if (o == NULL) {
    return V7_NULL;
  }
  return v7_pointer_to_value(o) | V7_TAG_OBJECT;
}

struct v7_object *v7_to_object(val_t v) {
  return (struct v7_object *) v7_to_pointer(v);
}

val_t v7_function_to_value(struct v7_function *o) {
  return v7_pointer_to_value(o) | V7_TAG_FUNCTION;
}

struct v7_function *v7_to_function(val_t v) {
  return (struct v7_function *) v7_to_pointer(v);
}

v7_val_t v7_create_cfunction(v7_cfunction_t f) {
  union {
    void *p;
    v7_cfunction_t f;
  } u;
  u.f = f;
  return v7_pointer_to_value(u.p) | V7_TAG_CFUNCTION;
}

void *v7_to_foreign(val_t v) {
  return v7_to_pointer(v);
}

v7_val_t v7_create_boolean(int v) {
  return (!!v) | V7_TAG_BOOLEAN;
}

int v7_to_boolean(val_t v) {
  return v & 1;
}

v7_val_t v7_create_number(double v) {
  val_t res;
  /* not every NaN is a JS NaN */
  if (isnan(v)) {
    res = V7_TAG_NAN;
  } else {
    union {
      double d;
      val_t r;
    } u;
    u.d = v;
    res = u.r;
  }
  return res;
}

double v7_to_number(val_t v) {
  union {
    double d;
    val_t v;
  } u;
  u.v = v;
  return u.d;
}

V7_PRIVATE val_t v_get_prototype(struct v7 *v7, val_t obj) {
  if (v7_is_function(obj)) {
    return v7->function_prototype;
  }
  return v7_object_to_value(v7_to_object(obj)->prototype);
}

V7_PRIVATE val_t create_object(struct v7 *v7, val_t prototype) {
  struct v7_object *o = new_object(v7);
  if (o == NULL) {
    return V7_NULL;
  }
  (void) v7;
  o->properties = NULL;
  o->prototype = v7_to_object(prototype);
  return v7_object_to_value(o);
}

v7_val_t v7_create_object(struct v7 *v7) {
  return create_object(v7, v7->object_prototype);
}

v7_val_t v7_create_null(void) {
  return V7_NULL;
}

v7_val_t v7_create_undefined(void) {
  return V7_UNDEFINED;
}

v7_val_t v7_create_array(struct v7 *v7) {
  val_t a = create_object(v7, v7->array_prototype);
#if 0
  v7_set_property(v7, a, "", 0, V7_PROPERTY_HIDDEN, V7_NULL);
#endif
  return a;
}

/*
 * Dense arrays are backed by mbuf. Currently the array can only grow by
 * appending (i.e. setting an element whose index == array.length)
 *
 * TODO(mkm): automatically promote dense arrays to normal objects
 *            when they are used as sparse arrays or to store arbitrary keys
 *            (perhaps a hybrid approach)
 * TODO(mkm): small sparsness doesn't have to promote the array,
 *            we can just fill empty slots with a tag. In JS missing array
 *            indices are subtly different from indices with an undefined value
 *            (key iteration).
 * TODO(mkm): change the interpreter so it can set elements in dense arrays
 */
V7_PRIVATE val_t v7_create_dense_array(struct v7 *v7) {
  val_t a = v7_create_array(v7);
  v7_set_property(v7, a, "", 0, V7_PROPERTY_HIDDEN, V7_NULL);
  v7_to_object(a)->attributes |= V7_OBJ_DENSE_ARRAY;
  return a;
}

#if V7_ENABLE__RegExp
v7_val_t v7_create_regexp(struct v7 *v7, const char *re, size_t re_len,
                          const char *flags, size_t flags_len) {
  struct slre_prog *p = NULL;
  struct v7_regexp *rp;

  if (slre_compile(re, re_len, flags, flags_len, &p, 1) != SLRE_OK ||
      p == NULL) {
    throw_exception(v7, TYPE_ERROR, "Invalid regex");
    return V7_UNDEFINED;
  } else {
    val_t obj = create_object(v7, v7->regexp_prototype);
    rp = (struct v7_regexp *) malloc(sizeof(*rp));
    rp->regexp_string = v7_create_string(v7, re, re_len, 1);
    rp->compiled_regexp = p;
    rp->lastIndex = 0;

    v7_set_property(v7, obj, "", 0, V7_PROPERTY_HIDDEN,
                    v7_pointer_to_value(rp) | V7_TAG_REGEXP);
    return obj;
  }
}
#endif /* V7_ENABLE__RegExp */

v7_val_t v7_create_foreign(void *p) {
  return v7_pointer_to_value(p) | V7_TAG_FOREIGN;
}

v7_val_t create_function(struct v7 *v7) {
  struct v7_function *f = new_function(v7);
  val_t proto = v7_create_undefined(), fval = v7_function_to_value(f);
  struct gc_tmp_frame tf = new_tmp_frame(v7);
  if (f == NULL) {
    fval = v7_create_null();
    goto cleanup;
  }
  tmp_stack_push(&tf, &proto);
  tmp_stack_push(&tf, &fval);

  f->properties = NULL;
  f->scope = NULL;
  f->attributes = 0;
  /* TODO(mkm): lazily create these properties on first access */
  proto = v7_create_object(v7);
#ifndef V7_DISABLE_PREDEFINED_STRINGS
  v7_set_property_v(v7, proto,
                    v7->predefined_strings[PREDEFINED_STR_CONSTRUCTOR],
                    V7_PROPERTY_DONT_ENUM, fval);
  v7_set_property_v(v7, fval, v7->predefined_strings[PREDEFINED_STR_PROTOTYPE],
                    V7_PROPERTY_DONT_ENUM | V7_PROPERTY_DONT_DELETE, proto);
#else
  v7_set_property(v7, proto, "constructor", 11, V7_PROPERTY_DONT_ENUM, fval);
  v7_set_property(v7, fval, "prototype", 9,
                  V7_PROPERTY_DONT_ENUM | V7_PROPERTY_DONT_DELETE, proto);
#endif

cleanup:
  tmp_frame_cleanup(&tf);
  return fval;
}

/* like c_snprintf but returns `size` if write is truncated */
static int v_sprintf_s(char *buf, size_t size, const char *fmt, ...) {
  size_t n;
  va_list ap;
  va_start(ap, fmt);
  n = c_vsnprintf(buf, size, fmt, ap);
  if (n > size) {
    return size;
  }
  return n;
}

#define BUF_LEFT(size, used) (((size_t)(used) < (size)) ? ((size) - (used)) : 0)

#ifdef V7_TEMP_OFF
int double_to_str(char *buf, size_t buf_size, double val, int prec);
#endif

V7_PRIVATE int to_str(struct v7 *v7, val_t v, char *buf, size_t size,
                      int as_json) {
  char *vp;
  double num;
  for (vp = v7->json_visited_stack.buf;
       vp < v7->json_visited_stack.buf + v7->json_visited_stack.len;
       vp += sizeof(val_t)) {
    if (*(val_t *) vp == v) {
      strncpy(buf, "[Circular]", size);
      return 10;
    }
  }

  switch (val_type(v7, v)) {
    case V7_TYPE_NULL:
      strncpy(buf, "null", size);
      return 4;
    case V7_TYPE_UNDEFINED:
      strncpy(buf, "undefined", size);
      return 9;
    case V7_TYPE_BOOLEAN:
      if (v7_to_boolean(v)) {
        strncpy(buf, "true", size);
        return 4;
      } else {
        strncpy(buf, "false", size);
        return 5;
      }
    case V7_TYPE_NUMBER:
      if (v == V7_TAG_NAN) {
        return c_snprintf(buf, size, "NaN");
      }
      num = v7_to_number(v);
      if (isinf(num)) {
        return c_snprintf(buf, size, "%sInfinity", num < 0.0 ? "-" : "");
      }
      {
/*
 * ESP8266's sprintf doesn't support double & float.
 * TODO(alashkin): fix this
 */
#ifndef V7_TEMP_OFF
        const char *fmt = num > 1e10 ? "%.21g" : "%.10g";
        return snprintf(buf, size, fmt, num);
#else
        const int prec = num > 1e10 ? 21 : 10;
        return double_to_str(buf, size, num, prec);
#endif
      }
    case V7_TYPE_STRING: {
      size_t n;
      const char *str = v7_to_string(v7, &v, &n);
      if (as_json) {
        return c_snprintf(buf, size, "\"%.*s\"", (int) n, str);
      } else {
        return c_snprintf(buf, size, "%.*s", (int) n, str);
      }
    }
#if V7_ENABLE__RegExp
    case V7_TYPE_REGEXP_OBJECT: {
      size_t n1, n2 = 0;
      char s2[3] = {0};
      struct v7_regexp *rp = (struct v7_regexp *) v7_to_pointer(v);
      const char *s1 = v7_to_string(v7, &rp->regexp_string, &n1);
      int flags = slre_get_flags(rp->compiled_regexp);
      if (flags & SLRE_FLAG_G) s2[n2++] = 'g';
      if (flags & SLRE_FLAG_I) s2[n2++] = 'i';
      if (flags & SLRE_FLAG_M) s2[n2++] = 'm';
      return c_snprintf(buf, size, "/%.*s/%.*s", (int) n1, s1, (int) n2, s2);
    }
#endif
    case V7_TYPE_CFUNCTION:
#ifdef V7_UNIT_TEST
      return c_snprintf(buf, size, "cfunc_xxxxxx");
#else
      return c_snprintf(buf, size, "cfunc_%p", v7_to_pointer(v));
#endif
    case V7_TYPE_CFUNCTION_OBJECT:
      v = i_value_of(v7, v);
      return c_snprintf(buf, size, "Function cfunc_%p", v7_to_pointer(v));
    case V7_TYPE_GENERIC_OBJECT:
    case V7_TYPE_BOOLEAN_OBJECT:
    case V7_TYPE_STRING_OBJECT:
    case V7_TYPE_NUMBER_OBJECT:
    case V7_TYPE_DATE_OBJECT:
    case V7_TYPE_ERROR_OBJECT: {
      /* TODO(imax): make it return the desired size of the buffer */
      char *b = buf;
      struct v7_property *p;
      mbuf_append(&v7->json_visited_stack, (char *) &v, sizeof(v));
      b += c_snprintf(b, BUF_LEFT(size, b - buf), "{");
      for (p = v7_to_object(v)->properties; p; p = p->next) {
        size_t n;
        const char *s;
        if (p->attributes & (V7_PROPERTY_HIDDEN | V7_PROPERTY_DONT_ENUM)) {
          continue;
        }
        s = v7_to_string(v7, &p->name, &n);
        b += c_snprintf(b, BUF_LEFT(size, b - buf), "\"%.*s\":", (int) n, s);
        b += to_str(v7, p->value, b, BUF_LEFT(size, b - buf), 1);
        if (p->next) {
          b += c_snprintf(b, BUF_LEFT(size, b - buf), ",");
        }
      }
      b += c_snprintf(b, BUF_LEFT(size, b - buf), "}");
      v7->json_visited_stack.len -= sizeof(v);
      return b - buf;
    }
    case V7_TYPE_ARRAY_OBJECT: {
      val_t el;
      int has;
      char *b = buf;
      size_t i, len = v7_array_length(v7, v);
      mbuf_append(&v7->json_visited_stack, (char *) &v, sizeof(v));
      if (as_json) {
        b += c_snprintf(b, BUF_LEFT(size, b - buf), "[");
      }
      for (i = 0; i < len; i++) {
        el = v7_array_get2(v7, v, i, &has);
        if (has) {
          b += to_str(v7, el, b, BUF_LEFT(size, b - buf), 1);
        }
        if (i != len - 1) {
          b += c_snprintf(b, BUF_LEFT(size, b - buf), ",");
        }
      }
      if (as_json) {
        b += c_snprintf(b, BUF_LEFT(size, b - buf), "]");
      }
      v7->json_visited_stack.len -= sizeof(v);
      return b - buf;
    }
    case V7_TYPE_FUNCTION_OBJECT: {
      char *name;
      size_t name_len;
      char *b = buf;
      struct v7_function *func = v7_to_function(v);
      ast_off_t body, var, var_end, start, pos = func->ast_off;
      struct ast *a = func->ast;

      b += c_snprintf(b, BUF_LEFT(size, b - buf), "[function");

      V7_CHECK(v7, ast_fetch_tag(a, &pos) == AST_FUNC);
      start = pos - 1;
      body = ast_get_skip(a, pos, AST_FUNC_BODY_SKIP);
      /* TODO(mkm) cleanup this - 1 */
      var = ast_get_skip(a, pos, AST_FUNC_FIRST_VAR_SKIP) - 1;

      ast_move_to_children(a, &pos);
      if (ast_fetch_tag(a, &pos) == AST_IDENT) {
        name = ast_get_inlined_data(a, pos, &name_len);
        ast_move_to_children(a, &pos);
        b += c_snprintf(b, BUF_LEFT(size, b - buf), " %.*s", (int) name_len,
                        name);
      }
      b += c_snprintf(b, BUF_LEFT(size, b - buf), "(");
      while (pos < body) {
        V7_CHECK(v7, ast_fetch_tag(a, &pos) == AST_IDENT);
        name = ast_get_inlined_data(a, pos, &name_len);
        ast_move_to_children(a, &pos);
        b += c_snprintf(b, BUF_LEFT(size, b - buf), "%.*s", (int) name_len,
                        name);
        if (pos < body) {
          b += c_snprintf(b, BUF_LEFT(size, b - buf), ",");
        }
      }
      b += c_snprintf(b, BUF_LEFT(size, b - buf), ")");
      if (var != start) {
        ast_off_t next;
        b += c_snprintf(b, BUF_LEFT(size, b - buf), "{var ");

        do {
          V7_CHECK(v7, ast_fetch_tag(a, &var) == AST_VAR);
          next = ast_get_skip(a, var, AST_VAR_NEXT_SKIP);
          if (next == var) {
            next = 0;
          }

          var_end = ast_get_skip(a, var, AST_END_SKIP);
          ast_move_to_children(a, &var);
          while (var < var_end) {
            V7_CHECK(v7, ast_fetch_tag(a, &var) == AST_VAR_DECL);
            name = ast_get_inlined_data(a, var, &name_len);
            ast_move_to_children(a, &var);
            ast_skip_tree(a, &var);

            b += c_snprintf(b, BUF_LEFT(size, b - buf), "%.*s", (int) name_len,
                            name);
            if (var < var_end || next) {
              b += c_snprintf(b, BUF_LEFT(size, b - buf), ",");
            }
          }
          if (next > 0) {
            var = next - 1; /* TODO(mkm): cleanup */
          }
        } while (next != 0);
        b += c_snprintf(b, BUF_LEFT(size, b - buf), "}");
      }
      b += c_snprintf(b, BUF_LEFT(size, b - buf), "]");
      return b - buf;
    }
    case V7_TYPE_FOREIGN:
      return c_snprintf(buf, size, "[foreign_%p]", v7_to_foreign(v));
    default:
      printf("NOT IMPLEMENTED YET %d\n", val_type(v7, v)); /* LCOV_EXCL_LINE */
      abort();
  }
  return 0; /* for compilers that don't know about abort() */
}

#undef BUF_LEFT

/*
 * v7_to_json allocates a new buffer if value representation doesn't fit into
 * buf. Caller is responsible for freeing that buffer.
 */
char *v7_to_json(struct v7 *v7, val_t v, char *buf, size_t size) {
  int len = to_str(v7, v, buf, size, 1);

  /* fit null terminating byte */
  if (len >= (int) size) {
    /* Buffer is not large enough. Allocate a bigger one */
    char *p = (char *) malloc(len + 1);
    to_str(v7, v, p, len + 1, 1);
    p[len] = '\0';
    return p;
  } else {
    return buf;
  }
}

void v7_print(struct v7 *v7, v7_val_t v) {
  v7_fprint(stdout, v7, v);
}

void v7_fprint(FILE *f, struct v7 *v7, val_t v) {
  char buf[16];

  if (v7_is_string(v)) {
    size_t n;
    const char *s = v7_to_string(v7, &v, &n);
#ifndef NO_LIBC
    fprintf(f, "%s", s);
#else
    fprint_str(f, s);
#endif
  } else {
    char *s = v7_to_json(v7, v, buf, sizeof(buf));
#ifndef NO_LIBC
    fprintf(f, "%s", s);
#else
    fprint_str(f, s);
#endif
    if (buf != s) free(s);
  }
}

void v7_println(struct v7 *v7, v7_val_t v) {
  v7_fprintln(stdout, v7, v);
}

void v7_fprintln(FILE *f, struct v7 *v7, val_t v) {
  v7_fprint(f, v7, v);
  fprintf(f, ENDL);
}

int v7_stringify_value(struct v7 *v7, val_t v, char *buf, size_t size) {
  if (v7_is_string(v)) {
    size_t n;
    const char *str = v7_to_string(v7, &v, &n);
    if (n >= size) {
      n = size - 1;
    }
    memcpy(buf, str, n);
    buf[n] = '\0';
    return n;
  } else {
    size_t len = (size_t) to_str(v7, v, buf, size, 1);
    return len < size ? len : size;
  }
}

V7_PRIVATE struct v7_property *v7_create_property(struct v7 *v7) {
  struct v7_property *p = new_property(v7);
  p->next = NULL;
  p->name = v7_create_undefined();
  p->value = v7_create_undefined();
  p->attributes = 0;
  return p;
}

V7_PRIVATE struct v7_property *v7_get_own_property2(struct v7 *v7, val_t obj,
                                                    const char *name,
                                                    size_t len,
                                                    unsigned int attrs) {
  struct v7_property *p;
  struct v7_object *o;
  val_t ss;
  if (!v7_is_object(obj)) {
    return NULL;
  }
  if (len == (size_t) ~0) {
    len = strlen(name);
  }

  o = v7_to_object(obj);
  /*
   * len check is needed to allow getting the mbuf from the hidden property.
   * TODO(mkm): however hidden properties cannot be safely represented with
   * a zero length string anyway, so this will change.
   */
  if (o->attributes & V7_OBJ_DENSE_ARRAY && len > 0) {
    int ok, has;
    unsigned long i = cstr_to_ulong(name, len, &ok);
    if (ok) {
      v7->cur_dense_prop->value = v7_array_get2(v7, obj, i, &has);
      return has ? v7->cur_dense_prop : NULL;
    }
  }

  if (len <= 5) {
    ss = v7_create_string(v7, name, len, 1);
    for (p = o->properties; p != NULL; p = p->next) {
      if (p->name == ss && (attrs == 0 || (p->attributes & attrs))) {
        return p;
      }
    }
  } else {
    for (p = o->properties; p != NULL; p = p->next) {
      size_t n;
      const char *s = v7_to_string(v7, &p->name, &n);
      if (n == len && strncmp(s, name, len) == 0 &&
          (attrs == 0 || (p->attributes & attrs))) {
        return p;
      }
    }
  }
  return NULL;
}

V7_PRIVATE struct v7_property *v7_get_own_property(struct v7 *v7, val_t obj,
                                                   const char *name,
                                                   size_t len) {
  return v7_get_own_property2(v7, obj, name, len, 0);
}

struct v7_property *v7_get_property(struct v7 *v7, val_t obj, const char *name,
                                    size_t len) {
  if (!v7_is_object(obj)) {
    return NULL;
  }
  for (; obj != V7_NULL; obj = v_get_prototype(v7, obj)) {
    struct v7_property *prop;
    if ((prop = v7_get_own_property(v7, obj, name, len)) != NULL) {
      return prop;
    }
  }
  return NULL;
}

v7_val_t v7_get(struct v7 *v7, val_t obj, const char *name, size_t name_len) {
  val_t v = obj;
  if (v7_is_string(obj)) {
    v = v7->string_prototype;
  } else if (v7_is_number(obj)) {
    v = v7->number_prototype;
  } else if (v7_is_boolean(obj)) {
    v = v7->boolean_prototype;
  } else if (v7_is_undefined(obj)) {
    throw_exception(v7, TYPE_ERROR, "cannot read property '%.*s' of undefined",
                    (int) name_len, name);
  } else if (v7_is_cfunction(obj)) {
    return V7_UNDEFINED;
  }
  return v7_property_value(v7, obj, v7_get_property(v7, v, name, name_len));
}

V7_PRIVATE v7_val_t v7_get_v(struct v7 *v7, v7_val_t obj, v7_val_t name) {
  val_t res;
  const char *s;
  size_t name_len;
  STATIC char buf[8];
  int fr = 0;

  /* subscripting strings */
  if (v7_is_string(obj)) {
    char ch;
    double dch = v7_char_code_at(v7, obj, name);
    if (!isnan(dch)) {
      ch = dch;
      return v7_create_string(v7, &ch, 1, 1);
    }
  }

  if (v7_is_string(name)) {
    s = v7_to_string(v7, &name, &name_len);
  } else {
    s = v7_to_json(v7, name, buf, sizeof(buf));
    name_len = strlen(s);
    fr = (s != buf);
  }
  res = v7_get(v7, obj, s, name_len);
  if (fr) free((void *) s);
  return res;
}

V7_PRIVATE void v7_destroy_property(struct v7_property **p) {
  *p = NULL;
}

int v7_set_v(struct v7 *v7, val_t obj, val_t name, val_t val) {
  size_t len;
  const char *n = v7_to_string(v7, &name, &len);
  struct v7_property *p = v7_get_own_property(v7, obj, n, len);
  if (p == NULL || !(p->attributes & V7_PROPERTY_READ_ONLY)) {
    return v7_set_property_v(v7, obj, name, p == NULL ? 0 : p->attributes, val);
  }
  return -1;
}

int v7_set(struct v7 *v7, val_t obj, const char *name, size_t len,
           unsigned int attrs, val_t val) {
  struct v7_property *p = v7_get_own_property(v7, obj, name, len);
  if (p == NULL || !(p->attributes & V7_PROPERTY_READ_ONLY)) {
    return v7_set_property(v7, obj, name, len,
                           p == NULL ? attrs : p->attributes, val);
  }
  return -1;
}

V7_PRIVATE void v7_invoke_setter(struct v7 *v7, struct v7_property *prop,
                                 val_t obj, val_t val) {
  val_t setter = prop->value, args = v7_create_dense_array(v7);
  if (prop->attributes & V7_PROPERTY_GETTER) {
    setter = v7_array_get(v7, prop->value, 1);
  }
  v7_array_set(v7, args, 0, val);
  v7_apply(v7, setter, obj, args);
}

V7_PRIVATE struct v7_property *v7_set_prop(struct v7 *v7, val_t obj, val_t name,
                                           unsigned int attributes, val_t val) {
  struct v7_property *prop;
  size_t len;
  const char *n = v7_to_string(v7, &name, &len);

  if (!v7_is_object(obj)) {
    return NULL;
  }

  if (v7_to_object(obj)->attributes & V7_OBJ_NOT_EXTENSIBLE) {
    if (v7->strict_mode) {
      throw_exception(v7, TYPE_ERROR, "Object is not extensible");
    }
    return NULL;
  }

  prop = v7_get_own_property(v7, obj, n, len);
  if (prop == NULL) {
    if ((prop = v7_create_property(v7)) == NULL) {
      return NULL; /* LCOV_EXCL_LINE */
    }
    prop->next = v7_to_object(obj)->properties;
    v7_to_object(obj)->properties = prop;
  }

  if (v7_is_undefined(prop->name)) {
    prop->name = name;
  }
  if (prop->attributes & V7_PROPERTY_SETTER) {
    v7_invoke_setter(v7, prop, obj, val);
    return 0;
  }

  prop->value = val;
  prop->attributes = attributes;
  return prop;
}

int v7_set_property_v(struct v7 *v7, val_t obj, val_t name,
                      unsigned int attributes, v7_val_t val) {
  struct v7_property *prop = v7_set_prop(v7, obj, name, attributes, val);
  return prop == NULL ? -1 : 0;
}

int v7_set_property(struct v7 *v7, val_t obj, const char *name, size_t len,
                    unsigned int attributes, v7_val_t val) {
  val_t n;
  int res;
  /* set_property_v can trigger GC */
  struct gc_tmp_frame tf = new_tmp_frame(v7);
  tmp_stack_push(&tf, &val);

  if (len == (size_t) ~0) {
    len = strlen(name);
  }

  n = v7_create_string(v7, name, len, 1);
  res = v7_set_property_v(v7, obj, n, attributes, val);
  tmp_frame_cleanup(&tf);
  return res;
}

int v7_del_property(struct v7 *v7, val_t obj, const char *name, size_t len) {
  struct v7_property *prop, *prev;

  if (!v7_is_object(obj)) {
    return -1;
  }
  if (len == (size_t) ~0) {
    len = strlen(name);
  }
  for (prev = NULL, prop = v7_to_object(obj)->properties; prop != NULL;
       prev = prop, prop = prop->next) {
    size_t n;
    const char *s = v7_to_string(v7, &prop->name, &n);
    if (n == len && strncmp(s, name, len) == 0) {
      if (prev) {
        prev->next = prop->next;
      } else {
        v7_to_object(obj)->properties = prop->next;
      }
      v7_destroy_property(&prop);
      return 0;
    }
  }
  return -1;
}

v7_val_t v7_create_function(struct v7 *v7, v7_cfunction_t f, int num_args) {
  val_t obj = create_object(v7, v7->function_prototype);
  struct gc_tmp_frame tf = new_tmp_frame(v7);
  tmp_stack_push(&tf, &obj);
  v7_set_property(v7, obj, "", 0, V7_PROPERTY_HIDDEN, v7_create_cfunction(f));
  if (num_args >= 0) {
#ifndef V7_DISABLE_PREDEFINED_STRINGS
    v7_set_property_v(
        v7, obj, v7->predefined_strings[PREDEFINED_STR_LENGTH],
        V7_PROPERTY_READ_ONLY | V7_PROPERTY_DONT_ENUM | V7_PROPERTY_DONT_DELETE,
        v7_create_number(num_args));
#else
    v7_set_property(
        v7, obj, "length", 6,
        V7_PROPERTY_READ_ONLY | V7_PROPERTY_DONT_ENUM | V7_PROPERTY_DONT_DELETE,
        v7_create_number(num_args));
#endif
  }
  tmp_frame_cleanup(&tf);
  return obj;
}

v7_val_t v7_create_constructor(struct v7 *v7, v7_val_t proto, v7_cfunction_t f,
                               int num_args) {
  v7_val_t res = v7_create_function(v7, f, num_args);

#ifndef V7_DISABLE_PREDEFINED_STRINGS
  v7_set_property_v(
      v7, res, v7->predefined_strings[PREDEFINED_STR_PROTOTYPE],
      V7_PROPERTY_DONT_ENUM | V7_PROPERTY_READ_ONLY | V7_PROPERTY_DONT_DELETE,
      proto);

  v7_set_property_v(v7, proto,
                    v7->predefined_strings[PREDEFINED_STR_CONSTRUCTOR],
                    V7_PROPERTY_DONT_ENUM, res);
#else
  v7_set_property(
      v7, res, "prototype", 9,
      V7_PROPERTY_DONT_ENUM | V7_PROPERTY_READ_ONLY | V7_PROPERTY_DONT_DELETE,
      proto);
  v7_set_property(v7, proto, "constructor", 11, V7_PROPERTY_DONT_ENUM, res);
#endif
  return res;
}

V7_PRIVATE int set_method(struct v7 *v7, v7_val_t obj, const char *name,
                          v7_cfunction_t func, int num_args) {
  return v7_set_property(v7, obj, name, strlen(name), V7_PROPERTY_DONT_ENUM,
                         v7_create_function(v7, func, num_args));
}

int v7_set_method(struct v7 *v7, v7_val_t obj, const char *name,
                  v7_cfunction_t func) {
  return set_method(v7, obj, name, func, -1);
}

V7_PRIVATE int set_cfunc_prop(struct v7 *v7, val_t o, const char *name,
                              v7_cfunction_t f) {
  return v7_set_property(v7, o, name, strlen(name), 0, v7_create_cfunction(f));
}

V7_PRIVATE val_t
v7_property_value(struct v7 *v7, val_t obj, struct v7_property *p) {
  if (p == NULL) {
    return V7_UNDEFINED;
  }
  if (p->attributes & V7_PROPERTY_GETTER) {
    val_t getter = p->value;
    if (p->attributes & V7_PROPERTY_SETTER) {
      getter = v7_array_get(v7, p->value, 0);
    }
    return v7_apply(v7, getter, obj, V7_UNDEFINED);
  }
  return p->value;
}

/*
 * Pack 15-bit length and 15 bit index, leaving 2 bits for tag. the LSB has to
 * be set to distinguish it from a prop pointer.
 * In alternative we just fetch the length from obj at each call to v7_next_prop
 * and just stuff the index here (e.g. on 8/16-bit platforms).
 * TODO(mkm): conditional for 16-bit platforms
 */
#define PACK_ITER(len, idx) \
  ((struct v7_property *) ((len) << 17 | (idx) << 1 | 1))

#define UNPACK_ITER_LEN(p) (((uintptr_t) p) >> 17)
#define UNPACK_ITER_IDX(p) ((((uintptr_t) p) >> 1) & 0x7FFF)
#define IS_PACKED_ITER(p) ((uintptr_t) p & 1)

V7_PRIVATE struct v7_property *v7_next_prop(struct v7 *v7, val_t obj,
                                            struct v7_property *p) {
  if (p == NULL && v7_to_object(obj)->attributes & V7_OBJ_DENSE_ARRAY) {
    unsigned long len = v7_array_length(v7, obj);
    return PACK_ITER(len, 0);
  } else if (IS_PACKED_ITER(p)) {
    unsigned long len = UNPACK_ITER_LEN(p);
    unsigned long idx = UNPACK_ITER_IDX(p);
    return idx + 1 == len ? v7_to_object(obj)->properties
                          : PACK_ITER(len, idx + 1);
  }
  return p == NULL ? v7_to_object(obj)->properties : p->next;
}

V7_PRIVATE val_t
v7_iter_get_value(struct v7 *v7, val_t obj, struct v7_property *p) {
  return IS_PACKED_ITER(p) ? v7_array_get(v7, obj, UNPACK_ITER_IDX(p))
                           : p->value;
}

V7_PRIVATE val_t v7_iter_get_name(struct v7 *v7, struct v7_property *p) {
  return IS_PACKED_ITER(p) ? ulong_to_str(v7, UNPACK_ITER_IDX(p)) : p->name;
}

/* return array index as number or undefined. works with iterators */
V7_PRIVATE val_t v7_iter_get_index(struct v7 *v7, struct v7_property *p) {
  int ok;
  unsigned long res;
  if (IS_PACKED_ITER(p)) {
    return v7_create_number(UNPACK_ITER_IDX(p));
  }
  res = str_to_ulong(v7, p->name, &ok);
  if (!ok) return v7_create_undefined();
  return v7_create_number(res);
}

unsigned long v7_array_length(struct v7 *v7, val_t v) {
  struct v7_property *p;
  unsigned long key, len = 0;
  char *end;

  if (!v7_is_object(v)) {
    return 0;
  }

  if (v7_to_object(v)->attributes & V7_OBJ_DENSE_ARRAY) {
    struct v7_property *p =
        v7_get_own_property2(v7, v, "", 0, V7_PROPERTY_HIDDEN);
    struct mbuf *abuf;
    if (p == NULL) return 0;
    abuf = (struct mbuf *) v7_to_foreign(p->value);
    if (abuf == NULL) return 0;
    return abuf->len / sizeof(val_t);
  }

  for (p = v7_to_object(v)->properties; p != NULL; p = p->next) {
    size_t n;
    const char *s = v7_to_string(v7, &p->name, &n);
    key = strtoul(s, &end, 10);
    /* Array length could not be more then 2^32 */
    if (end > s && *end == '\0' && key >= len && key < 4294967295UL) {
      len = key + 1;
    }
  }

  return len;
}

int v7_array_set(struct v7 *v7, val_t arr, unsigned long index, val_t v) {
  int res = -1;
  if (v7_is_object(arr)) {
    if (v7_to_object(arr)->attributes & V7_OBJ_DENSE_ARRAY) {
      struct v7_property *p =
          v7_get_own_property2(v7, arr, "", 0, V7_PROPERTY_HIDDEN);
      struct mbuf *abuf;
      unsigned long len;
      assert(p != NULL);
      abuf = (struct mbuf *) v7_to_foreign(p->value);

      if (v7_to_object(arr)->attributes & V7_OBJ_NOT_EXTENSIBLE) {
        if (v7->strict_mode) {
          throw_exception(v7, TYPE_ERROR, "Object is not extensible");
        }
        return res;
      }

      if (abuf == NULL) {
        abuf = (struct mbuf *) malloc(sizeof(*abuf));
        mbuf_init(abuf, sizeof(val_t) * (index + 1));
        p->value = v7_create_foreign(abuf);
      }
      len = abuf->len / sizeof(val_t);
      /* TODO(mkm): possibly promote to sparse array */
      if (index > len) {
        unsigned long i;
        val_t s = V7_TAG_NOVALUE;
        for (i = len; i < index; i++) {
          mbuf_append(abuf, (char *) &s, sizeof(val_t));
        }
        len = index;
      }

      if (index == len) {
        mbuf_append(abuf, (char *) &v, sizeof(val_t));
      } else {
        memcpy(abuf->buf + index * sizeof(val_t), &v, sizeof(val_t));
      }
    } else {
      char buf[20];
      int n = v_sprintf_s(buf, sizeof(buf), "%lu", index);
      res = v7_set(v7, arr, buf, n, 0, v);
    }
  }
  return res;
}

int v7_array_push(struct v7 *v7, v7_val_t arr, v7_val_t v) {
  return v7_array_set(v7, arr, v7_array_length(v7, arr), v);
}

val_t v7_array_get(struct v7 *v7, val_t arr, unsigned long index) {
  return v7_array_get2(v7, arr, index, NULL);
}

val_t v7_array_get2(struct v7 *v7, val_t arr, unsigned long index, int *has) {
  if (has != NULL) {
    *has = 0;
  }
  if (v7_is_object(arr)) {
    if (v7_to_object(arr)->attributes & V7_OBJ_DENSE_ARRAY) {
      struct v7_property *p =
          v7_get_own_property2(v7, arr, "", 0, V7_PROPERTY_HIDDEN);
      struct mbuf *abuf = NULL;
      unsigned long len;
      if (p != NULL) {
        abuf = (struct mbuf *) v7_to_foreign(p->value);
      }
      if (abuf == NULL) {
        return v7_create_undefined();
      }
      len = abuf->len / sizeof(val_t);
      if (index >= len) {
        return v7_create_undefined();
      } else {
        val_t res;
        memcpy(&res, abuf->buf + index * sizeof(val_t), sizeof(val_t));
        if (has != NULL && res != V7_TAG_NOVALUE) *has = 1;
        if (res == V7_TAG_NOVALUE) {
          res = v7_create_undefined();
        }
        return res;
      }
    } else {
      struct v7_property *p;
      char buf[20];
      int n = v_sprintf_s(buf, sizeof(buf), "%lu", index);
      p = v7_get_property(v7, arr, buf, n);
      if (has != NULL && p != NULL) *has = 1;
      return v7_property_value(v7, arr, p);
    }
  } else {
    return v7_create_undefined();
  }
}

int nextesc(const char **p); /* from SLRE */
V7_PRIVATE size_t unescape(const char *s, size_t len, char *to) {
  const char *end = s + len;
  size_t n = 0;
  char tmp[4];
  Rune r;

  while (s < end) {
    s += chartorune(&r, s);
    if (r == '\\' && s < end) {
      switch (*s) {
        case '"':
          s++, r = '"';
          break;
        case '\'':
          s++, r = '\'';
          break;
        case '\n':
          s++, r = '\n';
          break;
        default: {
          const char *tmp_s = s;
          int i = nextesc(&s);
          switch (i) {
            case -SLRE_INVALID_ESC_CHAR:
              r = '\\';
              s = tmp_s;
              n += runetochar(to == NULL ? tmp : to + n, &r);
              s += chartorune(&r, s);
              break;
            case -SLRE_INVALID_HEX_DIGIT:
            default:
              r = i;
          }
        }
      }
    }
    n += runetochar(to == NULL ? tmp : to + n, &r);
  }

  return n;
}

/* Insert a string into mbuf at specified offset */
V7_PRIVATE void embed_string(struct mbuf *m, size_t offset, const char *p,
                             size_t len, int zero_term, int unesc) {
  char *old_base = m->buf;
  int p_backed_by_mbuf = p >= old_base && p < old_base + m->len;
  size_t n = unesc ? unescape(p, len, NULL) : len;
  int k = calc_llen(n); /* Calculate how many bytes length takes */
  size_t tot_len = k + n + zero_term;
  mbuf_insert(m, offset, NULL, tot_len); /* Allocate  buffer */
  /* Fixup p if it was relocated by mbuf_insert() above */
  if (p_backed_by_mbuf) {
    p += m->buf - old_base;
  }
  encode_varint(n, (unsigned char *) m->buf + offset); /* Write length */
  /* Write string */
  if (p != 0) {
    if (unesc) {
      unescape(p, len, m->buf + offset + k);
    } else {
      memcpy(m->buf + offset + k, p, len);
    }
  }
  if (zero_term) {
    m->buf[offset + tot_len - 1] = '\0';
  }
}

/* Create a string */
v7_val_t v7_create_string(struct v7 *v7, const char *p, size_t len, int own) {
  struct mbuf *m = own ? &v7->owned_strings : &v7->foreign_strings;
  val_t offset = m->len, tag = V7_TAG_STRING_F;

  if (len <= 4) {
    char *s = GET_VAL_NAN_PAYLOAD(offset) + 1;
    offset = 0;
    if (p != 0) {
      memcpy(s, p, len);
    }
    s[-1] = len;
    tag = V7_TAG_STRING_I;
  } else if (len == 5) {
    char *s = GET_VAL_NAN_PAYLOAD(offset);
    offset = 0;
    if (p != 0) {
      memcpy(s, p, len);
    }
    tag = V7_TAG_STRING_5;
  } else if (own) {
#ifdef V7_ENABLE_COMPACTING_GC
    if ((double) m->len / (double) m->size > 0.9) {
      v7->need_gc = 1;
    }
#endif
    embed_string(m, m->len, p, len, 1, 0);
    tag = V7_TAG_STRING_O;
  } else {
    /* TODO(mkm): this doesn't set correctly the foreign string length */
    embed_string(m, m->len, (char *) &p, sizeof(p), 0, 0);
  }

  /* NOTE(lsm): don't use v7_pointer_to_value, 32-bit ptrs will truncate */
  return (offset & ~V7_TAG_MASK) | tag;
}

V7_PRIVATE val_t to_string(struct v7 *v7, val_t v) {
  char buf[100], *p, *s;
  val_t res;
  if (v7_is_string(v)) {
    return v;
  }

  s = p = v7_to_json(v7, i_value_of(v7, v), buf, sizeof(buf));
  if (p[0] == '"') {
    p[strlen(p) - 1] = '\0';
    s++;
  }
  res = v7_create_string(v7, s, strlen(s), 1);
  if (p != buf) {
    free(p);
  }

  return res;
}

/*
 * Get a pointer to string and string length.
 *
 * Beware that V7 strings are not null terminated!
 */
const char *v7_to_string(struct v7 *v7, val_t *v, size_t *sizep) {
  uint64_t tag = v[0] & V7_TAG_MASK;
  char *p;
  int llen;

  assert(v7_is_string(*v));

  if (tag == V7_TAG_STRING_I) {
    p = GET_VAL_NAN_PAYLOAD(*v) + 1;
    *sizep = p[-1];
  } else if (tag == V7_TAG_STRING_5) {
    p = GET_VAL_NAN_PAYLOAD(*v);
    *sizep = 5;
  } else {
    struct mbuf *m =
        (tag == V7_TAG_STRING_O) ? &v7->owned_strings : &v7->foreign_strings;
    size_t offset = (size_t) v7_to_pointer(*v);
    char *s = m->buf + offset;

    *sizep = decode_varint((uint8_t *) s, &llen);
    if (tag == V7_TAG_STRING_O) {
      p = s + llen;
    } else {
      memcpy(&p, s + llen, sizeof(p));
    }
  }

  return p;
}

V7_PRIVATE int s_cmp(struct v7 *v7, val_t a, val_t b) {
  size_t a_len, b_len;
  const char *a_ptr, *b_ptr;

  a_ptr = v7_to_string(v7, &a, &a_len);
  b_ptr = v7_to_string(v7, &b, &b_len);

  if (a_len == b_len) {
    return memcmp(a_ptr, b_ptr, a_len);
  }
  if (a_len > b_len) {
    return 1;
  } else if (a_len < b_len) {
    return -1;
  } else {
    return 0;
  }
}

V7_PRIVATE val_t s_concat(struct v7 *v7, val_t a, val_t b) {
  size_t a_len, b_len;
  const char *a_ptr, *b_ptr;
  char *s = NULL;
  uint64_t tag = V7_TAG_STRING_F;
  val_t offset = v7->owned_strings.len;

  a_ptr = v7_to_string(v7, &a, &a_len);
  b_ptr = v7_to_string(v7, &b, &b_len);

  /* Create a new string which is a concatenation a + b */
  if (a_len + b_len <= 4) {
    offset = 0;
    /* TODO(mkm): make it work on big endian too */
    s = GET_VAL_NAN_PAYLOAD(offset) + 1;
    s[-1] = a_len + b_len;
    tag = V7_TAG_STRING_I;
  } else if (a_len + b_len == 5) {
    offset = 0;
    /* TODO(mkm): make it work on big endian too */
    s = GET_VAL_NAN_PAYLOAD(offset);
    tag = V7_TAG_STRING_5;
  } else {
    int llen = calc_llen(a_len + b_len);
    mbuf_append(&v7->owned_strings, NULL, a_len + b_len + llen + 1);
    /* all pointers might have been relocated */
    s = v7->owned_strings.buf + offset;
    encode_varint(a_len + b_len, (unsigned char *) s); /* Write length */
    s += llen;
    a_ptr = v7_to_string(v7, &a, &a_len);
    b_ptr = v7_to_string(v7, &b, &b_len);
    tag = V7_TAG_STRING_O;
  }
  memcpy(s, a_ptr, a_len);
  memcpy(s + a_len, b_ptr, b_len);
  /* Inlined strings are already 0-terminated, but still, why not. */
  s[a_len + b_len] = '\0';

  /* NOTE(lsm): don't use v7_pointer_to_value, 32-bit ptrs will truncate */
  return (offset & ~V7_TAG_MASK) | tag;
}

/* Create V7 strings for integers such as array indices */
V7_PRIVATE val_t ulong_to_str(struct v7 *v7, unsigned long n) {
  char buf[100];
  int len;
  len = c_snprintf(buf, sizeof(buf), "%lu", n);
  return v7_create_string(v7, buf, len, 1);
}

/*
 * Convert a V7 string to to an unsigned integer.
 * `ok` will be set to true if the string conforms to
 * an unsigned long.
 */
V7_PRIVATE unsigned long cstr_to_ulong(const char *s, size_t len, int *ok) {
  char *e;
  unsigned long res = strtoul(s, &e, 10);
  *ok = (e == s + len) && len != 0;
  return res;
}

/*
 * Convert a C string to to an unsigned integer.
 * `ok` will be set to true if the string conforms to
 * an unsigned long.
 */
V7_PRIVATE unsigned long str_to_ulong(struct v7 *v7, val_t v, int *ok) {
  char buf[100];
  size_t len = v7_stringify_value(v7, v, buf, sizeof(buf));
  return cstr_to_ulong(buf, len, ok);
}

V7_PRIVATE int is_prototype_of(struct v7 *v7, val_t o, val_t p) {
  struct v7_object *obj, *proto;
  if (!v7_is_object(o) || !v7_is_object(p)) {
    return 0;
  }
  if (v7_is_function(o)) {
    return p == v7->function_prototype ||
           is_prototype_of(v7, v7->function_prototype, p);
  }
  proto = v7_to_object(p);
  for (obj = v7_to_object(o); obj; obj = obj->prototype) {
    if (obj->prototype == proto) {
      return 1;
    }
  }
  return 0;
}

int v7_is_true(struct v7 *v7, val_t v) {
  size_t len;
  return ((v7_is_boolean(v) && v7_to_boolean(v)) ||
          (v7_is_number(v) && v7_to_number(v) != 0.0) ||
          (v7_is_string(v) && v7_to_string(v7, &v, &len) && len > 0) ||
          (v7_is_object(v))) &&
         v != V7_TAG_NAN;
}

static void object_destructor(struct v7 *v7, void *ptr) {
  struct v7_object *o = (struct v7_object *) ptr;
  struct v7_property *p;
  struct mbuf *abuf;

  p = v7_get_own_property2(v7, v7_object_to_value(o), "", 0,
                           V7_PROPERTY_HIDDEN);

#if V7_ENABLE__RegExp
  if (p != NULL && (p->value & V7_TAG_MASK) == V7_TAG_REGEXP) {
    struct v7_regexp *rp = (struct v7_regexp *) v7_to_foreign(p->value);
    slre_free(rp->compiled_regexp);
    free(rp);
  }
#endif

  if (o->attributes & V7_OBJ_DENSE_ARRAY) {
    if (p != NULL &&
        ((abuf = (struct mbuf *) v7_to_foreign(p->value)) != NULL)) {
      mbuf_free(abuf);
      free(abuf);
    }
  }
}

V7_PRIVATE void release_ast(struct v7 *v7, struct ast *a) {
  (void) v7;

  if (a->refcnt != 0) a->refcnt--;

  if (a->refcnt == 0) {
#if V7_ENABLE__Memory__stats
    v7->function_arena_ast_size -= a->mbuf.size;
#endif
    ast_free(a);
    free(a);
  }
}

static void function_destructor(struct v7 *v7, void *ptr) {
  struct v7_function *f = (struct v7_function *) ptr;
  (void) v7;
  if (f == NULL || f->ast == NULL) return;

  release_ast(v7, f->ast);
}

struct v7 *v7_create(void) {
  struct v7_create_opts opts;
  memset(&opts, 0, sizeof(opts));
  return v7_create_opt(opts);
}

struct v7 *v7_create_opt(struct v7_create_opts opts) {
  struct v7 *v7 = NULL;
  val_t *p;
  char z = 0;

#if defined(HAS_V7_INFINITY) || defined(HAS_V7_NAN)
  double zero = 0.0;
#endif

#ifdef HAS_V7_INFINITY
  _v7_infinity = 1.0 / zero;
#endif
#ifdef HAS_V7_NAN
  _v7_nan = zero / zero;
#endif

  if (opts.object_arena_size == 0) opts.object_arena_size = 200;
  if (opts.function_arena_size == 0) opts.function_arena_size = 100;
  if (opts.property_arena_size == 0) opts.property_arena_size = 4000;

  if ((v7 = (struct v7 *) calloc(1, sizeof(*v7))) != NULL) {
#ifdef V7_STACK_SIZE
    v7->sp_limit = (void *) ((uintptr_t) opts.c_stack_base - (V7_STACK_SIZE));
#endif

    v7->cur_dense_prop =
        (struct v7_property *) calloc(1, sizeof(struct v7_property));
    gc_arena_init(&v7->object_arena, sizeof(struct v7_object),
                  opts.object_arena_size, 10, "object");
    v7->object_arena.destructor = object_destructor;
    gc_arena_init(&v7->function_arena, sizeof(struct v7_function),
                  opts.function_arena_size, 10, "function");
    v7->function_arena.destructor = function_destructor;
    gc_arena_init(&v7->property_arena, sizeof(struct v7_property),
                  opts.property_arena_size, 10, "property");

    /*
     * The compacting GC exploits the null terminator of the previous
     * string as marker.
     */
    mbuf_append(&v7->owned_strings, &z, 1);

    p = v7->predefined_strings;
    p[PREDEFINED_STR_LENGTH] = v7_create_string(v7, "length", 6, 1);
    p[PREDEFINED_STR_PROTOTYPE] = v7_create_string(v7, "prototype", 9, 1);
    p[PREDEFINED_STR_CONSTRUCTOR] = v7_create_string(v7, "constructor", 11, 1);
    p[PREDEFINED_STR_ARGUMENTS] = v7_create_string(v7, "arguments", 9, 1);

#ifdef V7_FORCE_STRICT_MODE
    v7->strict_mode = 1;
#endif

    init_stdlib(v7);
    v7->thrown_error = v7_create_undefined();
  }

  init_file(v7);
  init_crypto(v7);
  init_socket(v7);

  return v7;
}

val_t v7_get_global_object(struct v7 *v7) {
  return v7->global_object;
}

void v7_destroy(struct v7 *v7) {
#if 0
  struct ast **a;
#endif
  if (v7 != NULL) {
    mbuf_free(&v7->owned_strings);
    mbuf_free(&v7->foreign_strings);
    mbuf_free(&v7->json_visited_stack);
    mbuf_free(&v7->tmp_stack);

    gc_arena_destroy(v7, &v7->object_arena);
    gc_arena_destroy(v7, &v7->function_arena);
    gc_arena_destroy(v7, &v7->property_arena);

    free(v7->cur_dense_prop);
    free(v7);
  }
}

v7_val_t v7_set_proto(v7_val_t obj, v7_val_t proto) {
  if (v7_is_object(obj)) {
    v7_val_t old_proto = v7_object_to_value(v7_to_object(obj)->prototype);
    v7_to_object(obj)->prototype = v7_to_object(proto);
    return old_proto;
  } else {
    return v7_create_undefined();
  }
}

void v7_own(struct v7 *v7, v7_val_t *v) {
  mbuf_append(&v7->owned_values, &v, sizeof(v));
}

int v7_disown(struct v7 *v7, v7_val_t *v) {
  v7_val_t **vp =
      (v7_val_t **) (v7->owned_values.buf + v7->owned_values.len - sizeof(v));

  for (; (char *) vp >= v7->owned_values.buf; vp--) {
    if (*vp == v) {
      *vp = *(v7_val_t **) (v7->owned_values.buf + v7->owned_values.len -
                            sizeof(v));
      v7->owned_values.len -= sizeof(v);
      return 1;
    }
  }

  return 0;
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#if V7_ENABLE__Memory__stats
int v7_heap_stat(struct v7 *v7, enum v7_heap_stat_what what);
#endif

#ifdef V7_ENABLE_COMPACTING_GC
void gc_mark_string(struct v7 *, val_t *);
#endif

static struct gc_block *gc_new_block(struct gc_arena *a, size_t size);
static void gc_free_block(struct gc_block *b);

V7_PRIVATE struct v7_object *new_object(struct v7 *v7) {
  return (struct v7_object *) gc_alloc_cell(v7, &v7->object_arena);
}

V7_PRIVATE struct v7_property *new_property(struct v7 *v7) {
  return (struct v7_property *) gc_alloc_cell(v7, &v7->property_arena);
}

V7_PRIVATE struct v7_function *new_function(struct v7 *v7) {
  return (struct v7_function *) gc_alloc_cell(v7, &v7->function_arena);
}

V7_PRIVATE struct gc_tmp_frame new_tmp_frame(struct v7 *v7) {
  struct gc_tmp_frame frame;
  frame.v7 = v7;
  frame.pos = v7->tmp_stack.len;
  return frame;
}

V7_PRIVATE void tmp_frame_cleanup(struct gc_tmp_frame *tf) {
  tf->v7->tmp_stack.len = tf->pos;
}

/*
 * TODO(mkm): perhaps it's safer to keep val_t in the temporary
 * roots stack, instead of keeping val_t*, in order to be better
 * able to debug the relocating GC.
 */
V7_PRIVATE void tmp_stack_push(struct gc_tmp_frame *tf, val_t *vp) {
  mbuf_append(&tf->v7->tmp_stack, (char *) &vp, sizeof(val_t *));
}

/* Initializes a new arena. */
V7_PRIVATE void gc_arena_init(struct gc_arena *a, size_t cell_size,
                              size_t initial_size, size_t size_increment,
                              const char *name) {
  assert(cell_size >= sizeof(uintptr_t));

  memset(a, 0, sizeof(*a));
  a->cell_size = cell_size;
  a->name = name;
  a->size_increment = size_increment;
  a->blocks = gc_new_block(a, initial_size);
}

V7_PRIVATE void gc_arena_destroy(struct v7 *v7, struct gc_arena *a) {
  struct gc_block *b;

  if (a->blocks != NULL) {
    if (a->destructor != NULL) {
      gc_sweep(v7, a, 0);
    }
    for (b = a->blocks; b != NULL;) {
      struct gc_block *tmp;
      tmp = b;
      b = b->next;
      gc_free_block(tmp);
    }
  }
}

static void gc_free_block(struct gc_block *b) {
  free(b->base);
  free(b);
}

static struct gc_block *gc_new_block(struct gc_arena *a, size_t size) {
  struct gc_cell *cur;
  struct gc_block *b = (struct gc_block *) calloc(1, sizeof(*b));
  if (b == NULL) abort();

  b->size = size;
  b->base = (struct gc_cell *) calloc(a->cell_size, b->size);
  if (b->base == NULL) abort();

  for (cur = GC_CELL_OP(a, b->base, +, 0);
       cur < GC_CELL_OP(a, b->base, +, b->size);
       cur = GC_CELL_OP(a, cur, +, 1)) {
    cur->head.link = a->free;
    a->free = cur;
  }

  return b;
}

V7_PRIVATE void *gc_alloc_cell(struct v7 *v7, struct gc_arena *a) {
#ifdef V7_DISABLE_GC
  (void) v7;
  return calloc(1, a->cell_size);
#else
  struct gc_cell *r;
  if (a->free == NULL) {
    v7_gc(v7, 0);
    if (a->free == NULL) {
#ifdef V7_DISABLE_GROWING_GC
      printf("%s arena exhausted\n",
             a == &v7->object_arena
                 ? "object"
                 : (a == &v7->property_arena ? "property" : "function"));

#if V7_ENABLE__Memory__stats
      printf("objnfree: %d\n", v7_heap_stat(v7, V7_HEAP_STAT_OBJ_HEAP_FREE));
      printf("propnfree: %d\n", v7_heap_stat(v7, V7_HEAP_STAT_PROP_HEAP_FREE));
      printf("funcnfree: %d\n", v7_heap_stat(v7, V7_HEAP_STAT_FUNC_HEAP_FREE));
#endif
      abort();
#else
      struct gc_block *b = gc_new_block(a, a->size_increment);
      b->next = a->blocks;
      a->blocks = b;
#endif
    }
  }
  r = a->free;

  UNMARK(r);

  a->free = r->head.link;

#if V7_ENABLE__Memory__stats
  a->allocations++;
  a->alive++;
#endif

  /*
   * TODO(mkm): minor opt possible since most of the fields
   * are overwritten downstream, but not worth the yak shave time
   * when fields are added to GC-able structures */
  memset(r, 0, a->cell_size);
  return (void *) r;
#endif
}

/*
 * Scans the arena and add all unmarked cells to the free list.
 *
 * Empty blocks get deallocated. The head of the free list will contais cells
 * from the last (oldest) block. Cells will thus be allocated in block order.
 */
void gc_sweep(struct v7 *v7, struct gc_arena *a, size_t start) {
  struct gc_block *b;
  struct gc_cell *cur;
  struct gc_block **prevp = &a->blocks;
#if V7_ENABLE__Memory__stats
  a->alive = 0;
#endif
  a->free = NULL;

  for (b = a->blocks; b != NULL;) {
    size_t freed_in_block = 0;
    /*
     * if it turns out that this block is 100% garbage
     * we can release the whole block, but the addition
     * of it's cells to the free list has to be undone.
     */
    struct gc_cell *prev_free = a->free;

    for (cur = GC_CELL_OP(a, b->base, +, start);
         cur < GC_CELL_OP(a, b->base, +, b->size);
         cur = GC_CELL_OP(a, cur, +, 1)) {
      if (MARKED(cur)) {
        UNMARK(cur);
#if V7_ENABLE__Memory__stats
        a->alive++;
#endif
      } else {
        if (a->destructor != NULL) {
          a->destructor(v7, cur);
        }
        memset(cur, 0, a->cell_size);
        cur->head.link = a->free;
        a->free = cur;
        freed_in_block++;
#if V7_ENABLE__Memory__stats
        a->garbage++;
#endif
      }
    }

    /*
     * don't free the initial block, which is at the tail
     * because it has a special size aimed at reducing waste
     * and simplifying initial startup. TODO(mkm): improve
     * */
    if (b->next != NULL && freed_in_block == b->size) {
      *prevp = b->next;
      gc_free_block(b);
      b = *prevp;
      a->free = prev_free;
    } else {
      prevp = &b->next;
      b = b->next;
    }
  }
}

/*
 * dense arrays contain only one property pointing to an mbuf with array values.
 */
V7_PRIVATE void gc_mark_dense_array(struct v7 *v7, struct v7_object *obj) {
  val_t v = obj->properties->value;
  struct mbuf *mbuf = (struct mbuf *) v7_to_foreign(v);
  val_t *vp;

  if (mbuf == NULL) return;
  for (vp = (val_t *) mbuf->buf; (char *) vp < mbuf->buf + mbuf->len; vp++) {
    gc_mark(v7, *vp);
#ifdef V7_ENABLE_COMPACTING_GC
    gc_mark_string(v7, vp);
#endif
  }
}

V7_PRIVATE void gc_mark(struct v7 *v7, val_t v) {
  struct v7_object *obj;
  struct v7_property *prop;
  struct v7_property *next;

  if (!v7_is_object(v)) {
    return;
  }
  obj = v7_to_object(v);
  if (MARKED(obj)) return;

  if (obj->attributes & V7_OBJ_DENSE_ARRAY) {
    gc_mark_dense_array(v7, obj);
  }

  for ((prop = obj->properties), MARK(obj); prop != NULL; prop = next) {
#ifdef V7_ENABLE_COMPACTING_GC
    gc_mark_string(v7, &prop->value);
    gc_mark_string(v7, &prop->name);
#endif
    gc_mark(v7, prop->value);

    next = prop->next;

#if 0
    /* This usually triggers when marking an already free object */
    assert((struct gc_cell *) prop >= v7->property_arena.base &&
           (struct gc_cell *) prop < GC_CELL_OP(&v7->property_arena,
                                                v7->property_arena.base, +,
                                                v7->property_arena.size));
#endif
    MARK(prop);
  }

  /* function scope pointer is aliased to the object's prototype pointer */
  gc_mark(v7, v7_object_to_value(obj->prototype));
}

#if V7_ENABLE__Memory__stats

V7_PRIVATE size_t gc_arena_size(struct gc_arena *a) {
  size_t size = 0;
  struct gc_block *b;
  for (b = a->blocks; b != NULL; b = b->next) {
    size += b->size;
  }
  return size;
}

int v7_heap_stat(struct v7 *v7, enum v7_heap_stat_what what) {
  switch (what) {
    case V7_HEAP_STAT_HEAP_SIZE:
      return gc_arena_size(&v7->object_arena) * v7->object_arena.cell_size +
             gc_arena_size(&v7->function_arena) * v7->function_arena.cell_size +
             gc_arena_size(&v7->property_arena) * v7->property_arena.cell_size;
    case V7_HEAP_STAT_HEAP_USED:
      return v7->object_arena.alive * v7->object_arena.cell_size +
             v7->function_arena.alive * v7->function_arena.cell_size +
             v7->property_arena.alive * v7->property_arena.cell_size;
    case V7_HEAP_STAT_STRING_HEAP_RESERVED:
      return v7->owned_strings.size;
    case V7_HEAP_STAT_STRING_HEAP_USED:
      return v7->owned_strings.len;
    case V7_HEAP_STAT_OBJ_HEAP_MAX:
      return gc_arena_size(&v7->object_arena);
    case V7_HEAP_STAT_OBJ_HEAP_FREE:
      return gc_arena_size(&v7->object_arena) - v7->object_arena.alive;
    case V7_HEAP_STAT_OBJ_HEAP_CELL_SIZE:
      return v7->object_arena.cell_size;
    case V7_HEAP_STAT_FUNC_HEAP_MAX:
      return gc_arena_size(&v7->function_arena);
    case V7_HEAP_STAT_FUNC_HEAP_FREE:
      return gc_arena_size(&v7->function_arena) - v7->function_arena.alive;
    case V7_HEAP_STAT_FUNC_HEAP_CELL_SIZE:
      return v7->function_arena.cell_size;
    case V7_HEAP_STAT_PROP_HEAP_MAX:
      return gc_arena_size(&v7->property_arena);
    case V7_HEAP_STAT_PROP_HEAP_FREE:
      return gc_arena_size(&v7->property_arena) - v7->property_arena.alive;
    case V7_HEAP_STAT_PROP_HEAP_CELL_SIZE:
      return v7->property_arena.cell_size;
    case V7_HEAP_STAT_FUNC_AST_SIZE:
      return v7->function_arena_ast_size;
    case V7_HEAP_STAT_FUNC_OWNED:
      return v7->owned_values.len / sizeof(val_t *);
    case V7_HEAP_STAT_FUNC_OWNED_MAX:
      return v7->owned_values.size / sizeof(val_t *);
  }

  return -1;
}
#endif

static void gc_dump_arena_stats(const char *msg, struct gc_arena *a) {
  (void) msg;
  (void) a;
#ifndef NO_LIBC
#if V7_ENABLE__Memory__stats
  if (a->verbose) {
    fprintf(stderr, "%s: total allocations %lu, max %lu, alive %lu\n", msg,
            a->allocations, gc_arena_size(a), a->alive);
  }
#endif
#endif
}

#ifdef V7_ENABLE_COMPACTING_GC

uint64_t gc_string_val_to_offset(val_t v) {
  return ((uint64_t)(uintptr_t) v7_to_pointer(v)) & ~V7_TAG_MASK;
}

val_t gc_string_val_from_offset(uint64_t s) {
  return s | V7_TAG_STRING_O;
}

/* Mark a string value */
void gc_mark_string(struct v7 *v7, val_t *v) {
  val_t h, tmp = 0;
  char *s;

  if (((*v & V7_TAG_MASK) != V7_TAG_STRING_O) &&
      (*v & V7_TAG_MASK) != V7_TAG_STRING_C) {
    return;
  }

  /*
   * If a value points to an unmarked string we shall:
   *  1. save the first 6 bytes of the string
   *     since we need to be able to distinguish real values from
   *     the saved first 6 bytes of the string, we need to tag the chunk
   *     as V7_TAG_STRING_C
   *  2. encode value's address (v) into the first bytes of the string.
   *     the first byte is set to 0 to serve as a mark.
   *     The remaining 6 bytes are taken from v's least significant bytes.
   *  3. put the saved 8 bytes (tag + chunk) back into the value.
   *
   * If a value points to an already marked string we shall:
   *     (0, <6 bytes of a pointer to a val_t>), hence we have to skip
   *     the first byte. We tag the value pointer as a V7_TAG_FOREIGN
   *     so that it won't be followed during recursive mark.
   *
   *  ... the rest is the same
   *
   *  Note: 64-bit pointers can be represented with 48-bits
   */

  s = v7->owned_strings.buf + gc_string_val_to_offset(*v);
  if (s[-1] == '\0') {
    memcpy(&tmp, s, sizeof(tmp) - 2);
    tmp |= V7_TAG_STRING_C;
  } else {
    memcpy(&tmp, s, sizeof(tmp) - 2);
    tmp |= V7_TAG_FOREIGN;
  }

  h = (val_t)(uintptr_t) v;
  s[-1] = 1;
  memcpy(s, &h, sizeof(h) - 2);
  memcpy(v, &tmp, sizeof(tmp));
}

void gc_compact_strings(struct v7 *v7) {
  char *p = v7->owned_strings.buf + 1;
  uint64_t h, next, head = 1;
  int len, llen;

  while (p < v7->owned_strings.buf + v7->owned_strings.len) {
    if (p[-1] == '\1') {
      /* relocate and update ptrs */
      h = 0;
      memcpy(&h, p, sizeof(h) - 2);

      /*
       * relocate pointers until we find the tail.
       * The tail is marked with V7_TAG_STRING_C,
       * while val_t link pointers are tagged with V7_TAG_FOREIGN
       */
      for (; (h & V7_TAG_MASK) != V7_TAG_STRING_C; h = next) {
        h &= ~V7_TAG_MASK;
        memcpy(&next, (char *) (uintptr_t) h, sizeof(h));

        *(val_t *) (uintptr_t) h = gc_string_val_from_offset(head);
      }
      h &= ~V7_TAG_MASK;

      /*
       * the tail contains the first 6 bytes we stole from
       * the actual string.
       */
      len = decode_varint((unsigned char *) &h, &llen);
      len += llen + 1;

      /*
       * restore the saved 6 bytes
       * TODO(mkm): think about endianness
       */
      memcpy(p, &h, sizeof(h) - 2);

      /*
       * and relocate the string data by packing it to the left.
       */
      memmove(v7->owned_strings.buf + head, p, len);
      v7->owned_strings.buf[head - 1] = 0x0;
      p += len;
      head += len;
    } else {
      len = decode_varint((unsigned char *) p, &llen);
      len += llen + 1;

      p += len;
    }
  }

  v7->owned_strings.len = head;
}

void gc_dump_owned_strings(struct v7 *v7) {
  size_t i;
#if 0
  for (i = 0; i < v7->owned_strings.len; i++) {
    printf("%02x ", (uint8_t) v7->owned_strings.buf[i]);
  }
  printf("\n");
  for (i = 0; i < v7->owned_strings.len; i++) {
    if (isprint(v7->owned_strings.buf[i])) {
      printf(" %c ", v7->owned_strings.buf[i]);
    } else {
      printf(" . ");
    }
  }
#else
  for (i = 0; i < v7->owned_strings.len; i++) {
    if (isprint(v7->owned_strings.buf[i])) {
      printf("%c", v7->owned_strings.buf[i]);
    } else {
      printf(".");
    }
  }
#endif
  printf("\n");
}

#endif

#ifndef V7_DISABLE_GC

/*
 * builting on gcc, tried out by redefining it.
 * Using null pointer as base can trigger undefined behavior, hence
 * a portable workaround that involves a valid yet dummy pointer.
 * It's meant to be used as a contant expression.
 */
#ifndef offsetof
#define offsetof(st, m) (((ptrdiff_t)(&((st *) 32)->m)) - 32)
#endif

/* Perform garbage collection */
void v7_gc(struct v7 *v7, int full) {
  val_t **vp;

  /*
   * constant offsets for mbufs to be scanned for roots
   * needed for pre C99 compatibility.
   */
  static const ptrdiff_t root_mbuf_offs[] = {offsetof(struct v7, tmp_stack),
                                             offsetof(struct v7, owned_values)};
  int i;

  gc_dump_arena_stats("Before GC objects", &v7->object_arena);
  gc_dump_arena_stats("Before GC functions", &v7->function_arena);
  gc_dump_arena_stats("Before GC properties", &v7->property_arena);

  /* TODO(mkm): paranoia? */
  gc_mark(v7, v7->object_prototype);
  gc_mark(v7, v7->array_prototype);
  gc_mark(v7, v7->boolean_prototype);
  gc_mark(v7, v7->error_prototype);
  gc_mark(v7, v7->string_prototype);
  gc_mark(v7, v7->number_prototype);
  gc_mark(v7, v7->function_prototype); /* possibly not reachable */

  gc_mark(v7, v7->object_prototype);
  gc_mark(v7, v7->global_object);
  gc_mark(v7, v7->this_object);
  gc_mark(v7, v7->call_stack);
  gc_mark(v7, v7->thrown_error);

  for (i = 0; i < ERROR_CTOR_MAX; i++) {
    gc_mark(v7, v7->error_objects[i]);
  }

  for (i = 0; i < (int) ARRAY_SIZE(root_mbuf_offs); i++) {
    const struct mbuf *mbuf =
        (const struct mbuf *) (((uintptr_t) v7) + root_mbuf_offs[i]);

    for (vp = (val_t **) mbuf->buf; (char *) vp < mbuf->buf + mbuf->len; vp++) {
      gc_mark(v7, **vp);
#ifdef V7_ENABLE_COMPACTING_GC
      gc_mark_string(v7, *vp);
#endif
    }
  }

#ifdef V7_ENABLE_COMPACTING_GC
#ifndef V7_DISABLE_PREDEFINED_STRINGS
  {
    int i;
    for (i = 0; i < PREDEFINED_STR_MAX; i++) {
      gc_mark_string(v7, &v7->predefined_strings[i]);
    }
  }
#endif
  gc_compact_strings(v7);
#endif

  gc_sweep(v7, &v7->object_arena, 0);
  gc_sweep(v7, &v7->function_arena, 0);
  gc_sweep(v7, &v7->property_arena, 0);

  gc_dump_arena_stats("After GC objects", &v7->object_arena);
  gc_dump_arena_stats("After GC functions", &v7->function_arena);
  gc_dump_arena_stats("After GC properties", &v7->property_arena);

  if (full) {
    mbuf_trim(&v7->owned_strings);
  }
}
#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#define ACCEPT(t) (((v7)->cur_tok == (t)) ? next_tok((v7)), 1 : 0)

#define PARSE(p) TRY(parse_##p(v7, a))
#define PARSE_ARG(p, arg) TRY(parse_##p(v7, a, arg))
#define PARSE_ARG_2(p, a1, a2) TRY(parse_##p(v7, a, a1, a2))

#define TRY(call)           \
  do {                      \
    enum v7_err _e = call;  \
    CHECK(_e == V7_OK, _e); \
  } while (0)

#define THROW(err_code)                \
  do {                                 \
    return parser_throw(v7, err_code); \
  } while (0)

#define CHECK(cond, code)     \
  do {                        \
    if (!(cond)) THROW(code); \
  } while (0)

#define EXPECT(t)                                     \
  do {                                                \
    if ((v7)->cur_tok != (t)) return V7_SYNTAX_ERROR; \
    next_tok(v7);                                     \
  } while (0)

/* check for stack overflow on embedded devices */
#ifdef V7_STACK_SIZE
#define CHECK_STACK() \
  if ((void *) &v7 <= v7->sp_limit) THROW(V7_STACK_OVERFLOW)
#else
#define CHECK_STACK() (void) 0
#endif

static enum v7_err parse_expression(struct v7 *, struct ast *);
static enum v7_err parse_statement(struct v7 *, struct ast *);
static enum v7_err parse_terminal(struct v7 *, struct ast *);
static enum v7_err parse_assign(struct v7 *, struct ast *);
static enum v7_err parse_memberexpr(struct v7 *, struct ast *);
static enum v7_err parse_funcdecl(struct v7 *, struct ast *, int, int);
static enum v7_err parse_block(struct v7 *, struct ast *);
static enum v7_err parse_body(struct v7 *, struct ast *, enum v7_tok);
static enum v7_err parse_use_strict(struct v7 *, struct ast *);

static enum v7_err parser_throw(struct v7 *v7, enum v7_err err) {
  c_snprintf(v7->error_msg, sizeof(v7->error_msg), "Parse error: %s line %d",
             v7->pstate.file_name, v7->pstate.line_no);
  return err;
}

static enum v7_tok lookahead(const struct v7 *v7) {
  const char *s = v7->pstate.pc;
  double d;
  return get_tok(&s, &d, v7->cur_tok);
}

static enum v7_tok next_tok(struct v7 *v7) {
  int prev_line_no = v7->pstate.prev_line_no;
  CHECK_STACK();
  v7->pstate.prev_line_no = v7->pstate.line_no;
  v7->pstate.line_no += skip_to_next_tok(&v7->pstate.pc);
  v7->after_newline = prev_line_no != v7->pstate.line_no;
  v7->tok = v7->pstate.pc;
  v7->cur_tok = get_tok(&v7->pstate.pc, &v7->cur_tok_dbl, v7->cur_tok);
  v7->tok_len = v7->pstate.pc - v7->tok;
  v7->pstate.line_no += skip_to_next_tok(&v7->pstate.pc);
  return v7->cur_tok;
}

static enum v7_err parse_ident(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  if (v7->cur_tok == TOK_IDENTIFIER) {
    ast_add_inlined_node(a, AST_IDENT, v7->tok, v7->tok_len);
    next_tok(v7);
    return V7_OK;
  }
  return V7_SYNTAX_ERROR;
}

static enum v7_err parse_ident_allow_reserved_words(struct v7 *v7,
                                                    struct ast *a) {
  CHECK_STACK();
  /* Allow reserved words as property names. */
  if (is_reserved_word_token(v7->cur_tok)) {
    ast_add_inlined_node(a, AST_IDENT, v7->tok, v7->tok_len);
    next_tok(v7);
  } else {
    PARSE(ident);
  }
  return V7_OK;
}

static enum v7_err parse_prop(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  if (v7->cur_tok == TOK_IDENTIFIER && v7->tok_len == 3 &&
      strncmp(v7->tok, "get", v7->tok_len) == 0 && lookahead(v7) != TOK_COLON) {
    next_tok(v7);
    ast_add_node(a, AST_GETTER);
    parse_funcdecl(v7, a, 1, 1);
  } else if (v7->cur_tok == TOK_IDENTIFIER && v7->tok_len == 3 &&
             strncmp(v7->tok, "set", v7->tok_len) == 0 &&
             lookahead(v7) != TOK_COLON) {
    next_tok(v7);
    ast_add_node(a, AST_SETTER);
    parse_funcdecl(v7, a, 1, 1);
  } else {
    /* Allow reserved words as property names. */
    if (is_reserved_word_token(v7->cur_tok) || v7->cur_tok == TOK_IDENTIFIER ||
        v7->cur_tok == TOK_NUMBER) {
      ast_add_inlined_node(a, AST_PROP, v7->tok, v7->tok_len);
    } else if (v7->cur_tok == TOK_STRING_LITERAL) {
      ast_add_inlined_node(a, AST_PROP, v7->tok + 1, v7->tok_len - 2);
    } else {
      return V7_SYNTAX_ERROR;
    }
    next_tok(v7);
    EXPECT(TOK_COLON);
    PARSE(assign);
  }
  return V7_OK;
}

static enum v7_err parse_terminal(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  CHECK_STACK();
  switch (v7->cur_tok) {
    case TOK_OPEN_PAREN:
      next_tok(v7);
      PARSE(expression);
      EXPECT(TOK_CLOSE_PAREN);
      break;
    case TOK_OPEN_BRACKET:
      next_tok(v7);
      start = ast_add_node(a, AST_ARRAY);
      while (v7->cur_tok != TOK_CLOSE_BRACKET) {
        if (v7->cur_tok == TOK_COMMA) {
          /* Array literals allow missing elements, e.g. [,,1,] */
          ast_add_node(a, AST_NOP);
        } else {
          PARSE(assign);
        }
        ACCEPT(TOK_COMMA);
      }
      EXPECT(TOK_CLOSE_BRACKET);
      ast_set_skip(a, start, AST_END_SKIP);
      break;
    case TOK_OPEN_CURLY:
      next_tok(v7);
      start = ast_add_node(a, AST_OBJECT);
      if (v7->cur_tok != TOK_CLOSE_CURLY) {
        do {
          if (v7->cur_tok == TOK_CLOSE_CURLY) {
            break;
          }
          PARSE(prop);
        } while (ACCEPT(TOK_COMMA));
      }
      EXPECT(TOK_CLOSE_CURLY);
      ast_set_skip(a, start, AST_END_SKIP);
      break;
    case TOK_THIS:
      next_tok(v7);
      ast_add_node(a, AST_THIS);
      break;
    case TOK_TRUE:
      next_tok(v7);
      ast_add_node(a, AST_TRUE);
      break;
    case TOK_FALSE:
      next_tok(v7);
      ast_add_node(a, AST_FALSE);
      break;
    case TOK_NULL:
      next_tok(v7);
      ast_add_node(a, AST_NULL);
      break;
    case TOK_STRING_LITERAL:
      ast_add_inlined_node(a, AST_STRING, v7->tok + 1, v7->tok_len - 2);
      next_tok(v7);
      break;
    case TOK_NUMBER:
      ast_add_inlined_node(a, AST_NUM, v7->tok, v7->tok_len);
      next_tok(v7);
      break;
    case TOK_REGEX_LITERAL:
      ast_add_inlined_node(a, AST_REGEX, v7->tok, v7->tok_len);
      next_tok(v7);
      break;
    case TOK_IDENTIFIER:
      if (v7->tok_len == 9 && strncmp(v7->tok, "undefined", v7->tok_len) == 0) {
        ast_add_node(a, AST_UNDEFINED);
        next_tok(v7);
        break;
      }
    /* fall through */
    default:
      PARSE(ident);
  }
  return V7_OK;
}

static enum v7_err parse_arglist(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  if (v7->cur_tok != TOK_CLOSE_PAREN) {
    do {
      PARSE(assign);
    } while (ACCEPT(TOK_COMMA));
  }
  return V7_OK;
}

static enum v7_err parse_newexpr(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  CHECK_STACK();
  switch (v7->cur_tok) {
    case TOK_NEW:
      next_tok(v7);
      start = ast_add_node(a, AST_NEW);
      PARSE(memberexpr);
      if (ACCEPT(TOK_OPEN_PAREN)) {
        PARSE(arglist);
        EXPECT(TOK_CLOSE_PAREN);
      }
      ast_set_skip(a, start, AST_END_SKIP);
      break;
    case TOK_FUNCTION:
      next_tok(v7);
      PARSE_ARG_2(funcdecl, 0, 0);
      break;
    default:
      PARSE(terminal);
      break;
  }
  return V7_OK;
}

static enum v7_err parse_member(struct v7 *v7, struct ast *a, ast_off_t pos) {
  CHECK_STACK();
  switch (v7->cur_tok) {
    case TOK_DOT:
      next_tok(v7);
      /* Allow reserved words as member identifiers */
      if (is_reserved_word_token(v7->cur_tok) ||
          v7->cur_tok == TOK_IDENTIFIER) {
        ast_insert_inlined_node(a, pos, AST_MEMBER, v7->tok, v7->tok_len);
        next_tok(v7);
      } else {
        return V7_SYNTAX_ERROR;
      }
      break;
    case TOK_OPEN_BRACKET:
      next_tok(v7);
      PARSE(expression);
      EXPECT(TOK_CLOSE_BRACKET);
      ast_insert_node(a, pos, AST_INDEX);
      break;
    default:
      return V7_OK;
  }
  return V7_OK;
}

static enum v7_err parse_memberexpr(struct v7 *v7, struct ast *a) {
  ast_off_t pos = a->mbuf.len;
  CHECK_STACK();
  PARSE(newexpr);

  for (;;) {
    switch (v7->cur_tok) {
      case TOK_DOT:
      case TOK_OPEN_BRACKET:
        PARSE_ARG(member, pos);
        break;
      default:
        return V7_OK;
    }
  }
}

static enum v7_err parse_callexpr(struct v7 *v7, struct ast *a) {
  ast_off_t pos = a->mbuf.len;
  CHECK_STACK();
  PARSE(newexpr);

  for (;;) {
    switch (v7->cur_tok) {
      case TOK_DOT:
      case TOK_OPEN_BRACKET:
        PARSE_ARG(member, pos);
        break;
      case TOK_OPEN_PAREN:
        next_tok(v7);
        PARSE(arglist);
        EXPECT(TOK_CLOSE_PAREN);
        ast_insert_node(a, pos, AST_CALL);
        break;
      default:
        return V7_OK;
    }
  }
}

static enum v7_err parse_postfix(struct v7 *v7, struct ast *a) {
  ast_off_t pos = a->mbuf.len;
  CHECK_STACK();
  PARSE(callexpr);

  if (v7->after_newline) {
    return V7_OK;
  }
  switch (v7->cur_tok) {
    case TOK_PLUS_PLUS:
      next_tok(v7);
      ast_insert_node(a, pos, AST_POSTINC);
      break;
    case TOK_MINUS_MINUS:
      next_tok(v7);
      ast_insert_node(a, pos, AST_POSTDEC);
      break;
    default:
      break; /* nothing */
  }
  return V7_OK;
}

enum v7_err parse_prefix(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  for (;;) {
    switch (v7->cur_tok) {
      case TOK_PLUS:
        next_tok(v7);
        ast_add_node(a, AST_POSITIVE);
        break;
      case TOK_MINUS:
        next_tok(v7);
        ast_add_node(a, AST_NEGATIVE);
        break;
      case TOK_PLUS_PLUS:
        next_tok(v7);
        ast_add_node(a, AST_PREINC);
        break;
      case TOK_MINUS_MINUS:
        next_tok(v7);
        ast_add_node(a, AST_PREDEC);
        break;
      case TOK_TILDA:
        next_tok(v7);
        ast_add_node(a, AST_NOT);
        break;
      case TOK_NOT:
        next_tok(v7);
        ast_add_node(a, AST_LOGICAL_NOT);
        break;
      case TOK_VOID:
        next_tok(v7);
        ast_add_node(a, AST_VOID);
        break;
      case TOK_DELETE:
        next_tok(v7);
        ast_add_node(a, AST_DELETE);
        break;
      case TOK_TYPEOF:
        next_tok(v7);
        ast_add_node(a, AST_TYPEOF);
        break;
      default:
        return parse_postfix(v7, a);
    }
  }
}

/*
 * On ESP8266 'levels' declaration have to be outside of 'parse_binary'
 * in order to prevent reboot on return from this function
 * TODO(alashkin): understand why
 */
#define NONE \
  { (enum v7_tok) 0, (enum v7_tok) 0, (enum ast_tag) 0 }

static const struct {
  int len, left_to_right;
  struct {
    enum v7_tok start_tok, end_tok;
    enum ast_tag start_ast;
  } parts[2];
} levels[] = {
    {1, 0, {{TOK_ASSIGN, TOK_URSHIFT_ASSIGN, AST_ASSIGN}, NONE}},
    {1, 0, {{TOK_QUESTION, TOK_QUESTION, AST_COND}, NONE}},
    {1, 1, {{TOK_LOGICAL_OR, TOK_LOGICAL_OR, AST_LOGICAL_OR}, NONE}},
    {1, 1, {{TOK_LOGICAL_AND, TOK_LOGICAL_AND, AST_LOGICAL_AND}, NONE}},
    {1, 1, {{TOK_OR, TOK_OR, AST_OR}, NONE}},
    {1, 1, {{TOK_XOR, TOK_XOR, AST_XOR}, NONE}},
    {1, 1, {{TOK_AND, TOK_AND, AST_AND}, NONE}},
    {1, 1, {{TOK_EQ, TOK_NE_NE, AST_EQ}, NONE}},
    {2, 1, {{TOK_LE, TOK_GT, AST_LE}, {TOK_IN, TOK_INSTANCEOF, AST_IN}}},
    {1, 1, {{TOK_LSHIFT, TOK_URSHIFT, AST_LSHIFT}, NONE}},
    {1, 1, {{TOK_PLUS, TOK_MINUS, AST_ADD}, NONE}},
    {1, 1, {{TOK_REM, TOK_DIV, AST_REM}, NONE}}};

static enum v7_err parse_binary(struct v7 *v7, struct ast *a, int level,
                                ast_off_t pos) {
  int i;
  enum v7_tok tok;
  enum ast_tag ast;
  CHECK_STACK();

  if (level == (int) ARRAY_SIZE(levels) - 1) {
    PARSE(prefix);
  } else {
    TRY(parse_binary(v7, a, level + 1, a->mbuf.len));
  }

  for (i = 0; i < levels[level].len; i++) {
    tok = levels[level].parts[i].start_tok;
    ast = levels[level].parts[i].start_ast;
    do {
      if (v7->pstate.inhibit_in && tok == TOK_IN) {
        continue;
      }

      /*
       * Ternary operator sits in the middle of the binary operator
       * precedence chain. Deal with it as an exception and don't break
       * the chain.
       */
      if (tok == TOK_QUESTION && v7->cur_tok == TOK_QUESTION) {
        next_tok(v7);
        PARSE(assign);
        EXPECT(TOK_COLON);
        PARSE(assign);
        ast_insert_node(a, pos, AST_COND);
        return V7_OK;
      } else if (ACCEPT(tok)) {
        if (levels[level].left_to_right) {
          ast_insert_node(a, pos, ast);
          TRY(parse_binary(v7, a, level, pos));
        } else {
          TRY(parse_binary(v7, a, level, a->mbuf.len));
          ast_insert_node(a, pos, ast);
        }
      }
    } while (
        ast = (enum ast_tag)(ast + 1),
        tok < levels[level].parts[i].end_tok && (tok = (enum v7_tok)(tok + 1)));
  }

  return V7_OK;
}

static enum v7_err parse_assign(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  return parse_binary(v7, a, 0, a->mbuf.len);
}

static enum v7_err parse_expression(struct v7 *v7, struct ast *a) {
  ast_off_t pos = a->mbuf.len;
  int group = 0;
  CHECK_STACK();
  do {
    PARSE(assign);
  } while (ACCEPT(TOK_COMMA) && (group = 1));
  if (group) {
    ast_insert_node(a, pos, AST_SEQ);
  }
  return V7_OK;
}

static enum v7_err end_of_statement(struct v7 *v7) {
  CHECK_STACK();
  if (v7->cur_tok == TOK_SEMICOLON || v7->cur_tok == TOK_END_OF_INPUT ||
      v7->cur_tok == TOK_CLOSE_CURLY || v7->after_newline) {
    return V7_OK;
  }
  return V7_SYNTAX_ERROR;
}

static enum v7_err parse_var(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  CHECK_STACK();
  start = ast_add_node(a, AST_VAR);
  ast_modify_skip(a, v7->last_var_node, start, AST_FUNC_FIRST_VAR_SKIP);
  /* zero out var node pointer */
  ast_modify_skip(a, start, start, AST_FUNC_FIRST_VAR_SKIP);
  v7->last_var_node = start;
  do {
    ast_add_inlined_node(a, AST_VAR_DECL, v7->tok, v7->tok_len);
    EXPECT(TOK_IDENTIFIER);
    if (ACCEPT(TOK_ASSIGN)) {
      PARSE(assign);
    } else {
      ast_add_node(a, AST_NOP);
    }
  } while (ACCEPT(TOK_COMMA));
  ast_set_skip(a, start, AST_END_SKIP);
  return V7_OK;
}

static int parse_optional(struct v7 *v7, struct ast *a,
                          enum v7_tok terminator) {
  CHECK_STACK();
  if (v7->cur_tok != terminator) {
    return 1;
  }
  ast_add_node(a, AST_NOP);
  return 0;
}

static enum v7_err parse_if(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  CHECK_STACK();
  start = ast_add_node(a, AST_IF);
  EXPECT(TOK_OPEN_PAREN);
  PARSE(expression);
  EXPECT(TOK_CLOSE_PAREN);
  PARSE(statement);
  ast_set_skip(a, start, AST_END_IF_TRUE_SKIP);
  if (ACCEPT(TOK_ELSE)) {
    PARSE(statement);
  }
  ast_set_skip(a, start, AST_END_SKIP);
  return V7_OK;
}

static enum v7_err parse_while(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  int saved_in_loop;
  CHECK_STACK();
  start = ast_add_node(a, AST_WHILE);
  saved_in_loop = v7->pstate.in_loop;
  EXPECT(TOK_OPEN_PAREN);
  PARSE(expression);
  EXPECT(TOK_CLOSE_PAREN);
  v7->pstate.in_loop = 1;
  PARSE(statement);
  ast_set_skip(a, start, AST_END_SKIP);
  v7->pstate.in_loop = saved_in_loop;
  return V7_OK;
}

static enum v7_err parse_dowhile(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  int saved_in_loop;
  CHECK_STACK();

  start = ast_add_node(a, AST_DOWHILE);
  saved_in_loop = v7->pstate.in_loop;

  v7->pstate.in_loop = 1;
  PARSE(statement);
  v7->pstate.in_loop = saved_in_loop;
  ast_set_skip(a, start, AST_DO_WHILE_COND_SKIP);
  EXPECT(TOK_WHILE);
  EXPECT(TOK_OPEN_PAREN);
  PARSE(expression);
  EXPECT(TOK_CLOSE_PAREN);
  ast_set_skip(a, start, AST_END_SKIP);
  return V7_OK;
}

static enum v7_err parse_for(struct v7 *v7, struct ast *a) {
  /* TODO(mkm): for of, for each in */
  ast_off_t start;
  int saved_in_loop;

  CHECK_STACK();
  start = ast_add_node(a, AST_FOR);
  saved_in_loop = v7->pstate.in_loop;

  EXPECT(TOK_OPEN_PAREN);

  if (parse_optional(v7, a, TOK_SEMICOLON)) {
    /*
     * TODO(mkm): make this reentrant otherwise this pearl won't parse:
     * for((function(){return 1 in o.a ? o : x})().a in [1,2,3])
     */
    v7->pstate.inhibit_in = 1;
    if (ACCEPT(TOK_VAR)) {
      PARSE(var);
    } else {
      PARSE(expression);
    }
    v7->pstate.inhibit_in = 0;

    if (ACCEPT(TOK_IN)) {
      PARSE(expression);
      ast_add_node(a, AST_NOP);
      /*
       * Assumes that for and for in have the same AST format which is
       * suboptimal but avoids the need of fixing up the var offset chain.
       * TODO(mkm) improve this
       */
      a->mbuf.buf[start - 1] = AST_FOR_IN;
      goto body;
    }
  }

  EXPECT(TOK_SEMICOLON);
  if (parse_optional(v7, a, TOK_SEMICOLON)) {
    PARSE(expression);
  }
  EXPECT(TOK_SEMICOLON);
  if (parse_optional(v7, a, TOK_CLOSE_PAREN)) {
    PARSE(expression);
  }

body:
  EXPECT(TOK_CLOSE_PAREN);
  ast_set_skip(a, start, AST_FOR_BODY_SKIP);
  v7->pstate.in_loop = 1;
  PARSE(statement);
  v7->pstate.in_loop = saved_in_loop;
  ast_set_skip(a, start, AST_END_SKIP);
  return V7_OK;
}

static enum v7_err parse_switch(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  int saved_in_switch;

  CHECK_STACK();
  start = ast_add_node(a, AST_SWITCH);
  saved_in_switch = v7->pstate.in_switch;

  ast_set_skip(a, start, AST_SWITCH_DEFAULT_SKIP); /* clear out */
  EXPECT(TOK_OPEN_PAREN);
  PARSE(expression);
  EXPECT(TOK_CLOSE_PAREN);
  EXPECT(TOK_OPEN_CURLY);
  v7->pstate.in_switch = 1;
  while (v7->cur_tok != TOK_CLOSE_CURLY) {
    ast_off_t case_start;
    switch (v7->cur_tok) {
      case TOK_CASE:
        next_tok(v7);
        case_start = ast_add_node(a, AST_CASE);
        PARSE(expression);
        EXPECT(TOK_COLON);
        while (v7->cur_tok != TOK_CASE && v7->cur_tok != TOK_DEFAULT &&
               v7->cur_tok != TOK_CLOSE_CURLY) {
          PARSE(statement);
        }
        ast_set_skip(a, case_start, AST_END_SKIP);
        break;
      case TOK_DEFAULT:
        next_tok(v7);
        EXPECT(TOK_COLON);
        ast_set_skip(a, start, AST_SWITCH_DEFAULT_SKIP);
        case_start = ast_add_node(a, AST_DEFAULT);
        while (v7->cur_tok != TOK_CASE && v7->cur_tok != TOK_DEFAULT &&
               v7->cur_tok != TOK_CLOSE_CURLY) {
          PARSE(statement);
        }
        ast_set_skip(a, case_start, AST_END_SKIP);
        break;
      default:
        return V7_SYNTAX_ERROR;
    }
  }
  EXPECT(TOK_CLOSE_CURLY);
  ast_set_skip(a, start, AST_END_SKIP);
  v7->pstate.in_switch = saved_in_switch;
  return V7_OK;
}

static enum v7_err parse_try(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  CHECK_STACK();
  start = ast_add_node(a, AST_TRY);
  PARSE(block);
  ast_set_skip(a, start, AST_TRY_CATCH_SKIP);
  if (ACCEPT(TOK_CATCH)) {
    EXPECT(TOK_OPEN_PAREN);
    PARSE(ident);
    EXPECT(TOK_CLOSE_PAREN);
    PARSE(block);
  }
  ast_set_skip(a, start, AST_TRY_FINALLY_SKIP);
  if (ACCEPT(TOK_FINALLY)) {
    PARSE(block);
  }
  ast_set_skip(a, start, AST_END_SKIP);
  return V7_OK;
}

static enum v7_err parse_with(struct v7 *v7, struct ast *a) {
  ast_off_t start;
  CHECK_STACK();
  start = ast_add_node(a, AST_WITH);
  if (v7->pstate.in_strict) {
    return V7_SYNTAX_ERROR;
  }
  EXPECT(TOK_OPEN_PAREN);
  PARSE(expression);
  EXPECT(TOK_CLOSE_PAREN);
  PARSE(statement);
  ast_set_skip(a, start, AST_END_SKIP);
  return V7_OK;
}

#define PARSE_WITH_OPT_ARG(tag, arg_tag, arg_parser) \
  do {                                               \
    if (end_of_statement(v7) == V7_OK) {             \
      ast_add_node(a, tag);                          \
    } else {                                         \
      ast_add_node(a, arg_tag);                      \
      PARSE(arg_parser);                             \
    }                                                \
  } while (0)

static enum v7_err parse_statement(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  switch (v7->cur_tok) {
    case TOK_SEMICOLON:
      next_tok(v7);
      return V7_OK;      /* empty statement */
    case TOK_OPEN_CURLY: /* block */
      PARSE(block);
      return V7_OK; /* returning because no semicolon required */
    case TOK_IF:
      next_tok(v7);
      return parse_if(v7, a);
    case TOK_WHILE:
      next_tok(v7);
      return parse_while(v7, a);
    case TOK_DO:
      next_tok(v7);
      return parse_dowhile(v7, a);
    case TOK_FOR:
      next_tok(v7);
      return parse_for(v7, a);
    case TOK_TRY:
      next_tok(v7);
      return parse_try(v7, a);
    case TOK_SWITCH:
      next_tok(v7);
      return parse_switch(v7, a);
    case TOK_WITH:
      next_tok(v7);
      return parse_with(v7, a);
    case TOK_BREAK:
      if (!(v7->pstate.in_loop || v7->pstate.in_switch)) {
        return V7_SYNTAX_ERROR;
      }
      next_tok(v7);
      PARSE_WITH_OPT_ARG(AST_BREAK, AST_LABELED_BREAK, ident);
      break;
    case TOK_CONTINUE:
      if (!v7->pstate.in_loop) {
        return V7_SYNTAX_ERROR;
      }
      next_tok(v7);
      PARSE_WITH_OPT_ARG(AST_CONTINUE, AST_LABELED_CONTINUE, ident);
      break;
    case TOK_RETURN:
      if (!v7->pstate.in_function) {
        return V7_SYNTAX_ERROR;
      }
      next_tok(v7);
      PARSE_WITH_OPT_ARG(AST_RETURN, AST_VALUE_RETURN, expression);
      break;
    case TOK_THROW:
      next_tok(v7);
      ast_add_node(a, AST_THROW);
      PARSE(expression);
      break;
    case TOK_DEBUGGER:
      next_tok(v7);
      ast_add_node(a, AST_DEBUGGER);
      break;
    case TOK_VAR:
      next_tok(v7);
      PARSE(var);
      break;
    case TOK_IDENTIFIER:
      if (lookahead(v7) == TOK_COLON) {
        ast_add_inlined_node(a, AST_LABEL, v7->tok, v7->tok_len);
        next_tok(v7);
        EXPECT(TOK_COLON);
        return V7_OK;
      }
    /* fall through */
    default:
      PARSE(expression);
      break;
  }

  TRY(end_of_statement(v7));
  ACCEPT(TOK_SEMICOLON); /* swallow optional semicolon */
  return V7_OK;
}

static enum v7_err parse_funcdecl(struct v7 *v7, struct ast *a,
                                  int require_named, int reserved_name) {
  ast_off_t start;
  ast_off_t outer_last_var_node;
  int saved_in_function;
  int saved_in_strict;

  CHECK_STACK();
  start = ast_add_node(a, AST_FUNC);
  outer_last_var_node = v7->last_var_node;
  saved_in_function = v7->pstate.in_function;
  saved_in_strict = v7->pstate.in_strict;

  v7->last_var_node = start;
  ast_modify_skip(a, start, start, AST_FUNC_FIRST_VAR_SKIP);
  if ((reserved_name ? parse_ident_allow_reserved_words : parse_ident)(v7, a) ==
      V7_SYNTAX_ERROR) {
    if (require_named) {
      return V7_SYNTAX_ERROR;
    }
    ast_add_node(a, AST_NOP);
  }
  EXPECT(TOK_OPEN_PAREN);
  PARSE(arglist);
  EXPECT(TOK_CLOSE_PAREN);
  ast_set_skip(a, start, AST_FUNC_BODY_SKIP);
  v7->pstate.in_function = 1;
  EXPECT(TOK_OPEN_CURLY);
  if (parse_use_strict(v7, a) == V7_OK) {
    v7->pstate.in_strict = 1;
  }
  PARSE_ARG(body, TOK_CLOSE_CURLY);
  EXPECT(TOK_CLOSE_CURLY);
  v7->pstate.in_strict = saved_in_strict;
  v7->pstate.in_function = saved_in_function;
  ast_set_skip(a, start, AST_END_SKIP);
  v7->last_var_node = outer_last_var_node;
  return V7_OK;
}

static enum v7_err parse_block(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  EXPECT(TOK_OPEN_CURLY);
  PARSE_ARG(body, TOK_CLOSE_CURLY);
  EXPECT(TOK_CLOSE_CURLY);
  return V7_OK;
}

static enum v7_err parse_body(struct v7 *v7, struct ast *a, enum v7_tok end) {
  ast_off_t start;
  CHECK_STACK();
  while (v7->cur_tok != end) {
    if (ACCEPT(TOK_FUNCTION)) {
      if (v7->cur_tok != TOK_IDENTIFIER) {
        return V7_SYNTAX_ERROR;
      }
      start = ast_add_node(a, AST_VAR);
      ast_modify_skip(a, v7->last_var_node, start, AST_FUNC_FIRST_VAR_SKIP);
      /* zero out var node pointer */
      ast_modify_skip(a, start, start, AST_FUNC_FIRST_VAR_SKIP);
      v7->last_var_node = start;
      ast_add_inlined_node(a, AST_FUNC_DECL, v7->tok, v7->tok_len);

      PARSE_ARG_2(funcdecl, 1, 0);
      ast_set_skip(a, start, AST_END_SKIP);
    } else {
      PARSE(statement);
    }
  }
  return V7_OK;
}

static enum v7_err parse_use_strict(struct v7 *v7, struct ast *a) {
  CHECK_STACK();
  if (v7->cur_tok == TOK_STRING_LITERAL &&
      (strncmp(v7->tok, "\"use strict\"", v7->tok_len) == 0 ||
       strncmp(v7->tok, "'use strict'", v7->tok_len) == 0)) {
    next_tok(v7);
    ast_add_node(a, AST_USE_STRICT);
    return V7_OK;
  }
  return V7_SYNTAX_ERROR;
}

static enum v7_err parse_script(struct v7 *v7, struct ast *a) {
  ast_off_t start = ast_add_node(a, AST_SCRIPT);
  ast_off_t outer_last_var_node = v7->last_var_node;
  int saved_in_strict = v7->pstate.in_strict;
  v7->last_var_node = start;
  ast_modify_skip(a, start, 1, AST_FUNC_FIRST_VAR_SKIP);
  if (parse_use_strict(v7, a) == V7_OK) {
    v7->pstate.in_strict = 1;
  }
  PARSE_ARG(body, TOK_END_OF_INPUT);
  ast_set_skip(a, start, AST_END_SKIP);
  v7->pstate.in_strict = saved_in_strict;
  v7->last_var_node = outer_last_var_node;
  return V7_OK;
}

static unsigned long get_column(const char *code, const char *pos) {
  const char *p = pos;
  while (p > code && *p != '\n') {
    p--;
  }
  return p == code ? pos - p : pos - (p + 1);
}

V7_PRIVATE enum v7_err parse(struct v7 *v7, struct ast *a, const char *src,
                             int verbose) {
  enum v7_err err;
  v7->pstate.source_code = v7->pstate.pc = src;
  v7->pstate.file_name = "<stdin>";
  v7->pstate.line_no = 1;
  v7->pstate.in_function = 0;
  v7->pstate.in_loop = 0;
  v7->pstate.in_switch = 0;

  next_tok(v7);
  err = parse_script(v7, a);
  if (err == V7_OK && v7->cur_tok != TOK_END_OF_INPUT) {
#ifndef NO_LIBC
    fprintf(stderr, "WARNING parse input not consumed\n");
#endif
  }
  if (verbose && err != V7_OK) {
    unsigned long col = get_column(v7->pstate.source_code, v7->tok);
    c_snprintf(v7->error_msg, sizeof(v7->error_msg),
               "parse error at at line %d col %lu: [%.*s]", v7->pstate.line_no,
               col, (int) (col + v7->tok_len), v7->tok - col);
  }
  return err;
}

const char *v7_get_parser_error(struct v7 *v7) {
  return v7->error_msg;
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#undef siglongjmp
#undef sigsetjmp

#if defined(_WIN32) || defined(ARDUINO) || 1
#define siglongjmp longjmp
#define sigsetjmp(buf, mask) setjmp(buf)
#endif

static const enum ast_tag assign_op_map[] = {
    AST_REM, AST_MUL, AST_DIV,    AST_XOR,    AST_ADD,    AST_SUB,
    AST_OR,  AST_AND, AST_LSHIFT, AST_RSHIFT, AST_URSHIFT};

enum i_break { B_RUN, B_RETURN, B_BREAK, B_CONTINUE };

static val_t i_eval_stmts(struct v7 *, struct ast *, ast_off_t *, ast_off_t,
                          val_t, enum i_break *);
static val_t i_eval_expr(struct v7 *, struct ast *, ast_off_t *, val_t);
static val_t i_eval_call(struct v7 *, struct ast *, ast_off_t *, val_t, val_t,
                         int);
static val_t i_find_this(struct v7 *, struct ast *, ast_off_t, val_t);

void v7_throw_value(struct v7 *v7, val_t v) {
  v7->thrown_error = v;
  siglongjmp(v7->jmp_buf, THROW_JMP);
} /* LCOV_EXCL_LINE */

static val_t create_exception(struct v7 *v7, enum error_ctor ex,
                              const char *msg) {
  val_t e, args;
  if (v7->creating_exception) {
#ifndef NO_LIBC
    fprintf(stderr, "Exception creation throws an exception %d: %s\n", ex, msg);
#endif
    return V7_UNDEFINED;
  }
  args = v7_create_dense_array(v7);
  v7_array_set(v7, args, 0, v7_create_string(v7, msg, strlen(msg), 1));
  v7->creating_exception++;
  e = create_object(v7, v7_get(v7, v7->error_objects[ex], "prototype", 9));
  v7_apply(v7, v7->error_objects[ex], e, args);
  v7->creating_exception--;
  return e;
}

V7_PRIVATE void throw_exception(struct v7 *v7, enum error_ctor ex,
                                const char *err_fmt, ...) {
  va_list ap;
  va_start(ap, err_fmt);
  c_vsnprintf(v7->error_msg, sizeof(v7->error_msg), err_fmt, ap);
  va_end(ap);
  v7_throw_value(v7, create_exception(v7, ex, v7->error_msg));
} /* LCOV_EXCL_LINE */

void v7_throw(struct v7 *v7, const char *err_fmt, ...) {
  va_list ap;
  va_start(ap, err_fmt);
  c_vsnprintf(v7->error_msg, sizeof(v7->error_msg), err_fmt, ap);
  va_end(ap);
  v7_throw_value(v7, create_exception(v7, TYPE_ERROR, v7->error_msg));
}

V7_PRIVATE val_t i_value_of(struct v7 *v7, val_t v) {
  val_t f;
  if (!v7_is_object(v)) {
    return v;
  }

  if ((f = v7_get(v7, v, "valueOf", 7)) != V7_UNDEFINED) {
    /*
     * v7_apply will root all parameters since it can be called
     * from user code, hence it's not necessary to root `f`.
     * This assumes all callers of i_value_of will root their
     * temporary values.
     */
    v = v7_apply(v7, f, v, v7_create_undefined());
  }
  return v;
}

/* i_as_num expects callers to root temporary values passed as args */
V7_PRIVATE double i_as_num(struct v7 *v7, val_t v) {
  double res = 0.0;

  v = i_value_of(v7, v);
  if (v7_is_number(v)) {
    res = v7_to_number(v);
  } else if (v7_is_string(v)) {
    size_t n;
    char *e, *s = (char *) v7_to_string(v7, &v, &n);
    if (n != 0) {
      res = strtod(s, &e);
      if (e - n != s) {
        res = NAN;
      }
    }
  } else if (v7_is_boolean(v)) {
    res = (double) v7_to_boolean(v);
  } else if (v7_is_null(v)) {
    res = 0.0;
  } else {
    res = NAN;
  }
  return res;
}

static double i_num_unary_op(struct v7 *v7, enum ast_tag tag, double a) {
  switch (tag) {
    case AST_POSITIVE:
      return a;
    case AST_NEGATIVE:
      return -a;
    default:
      throw_exception(v7, INTERNAL_ERROR, "%s", __func__); /* LCOV_EXCL_LINE */
      return 0;                                            /* LCOV_EXCL_LINE */
  }
}

static double i_int_bin_op(struct v7 *v7, enum ast_tag tag, double a,
                           double b) {
  int32_t ia = isnan(a) || isinf(a) ? 0 : (int32_t)(int64_t) a;
  int32_t ib = isnan(b) || isinf(b) ? 0 : (int32_t)(int64_t) b;

  switch (tag) {
    case AST_LSHIFT:
      return (int32_t)((uint32_t) ia << ((uint32_t) ib & 31));
    case AST_RSHIFT:
      return ia >> ((uint32_t) ib & 31);
    case AST_URSHIFT:
      return (uint32_t) ia >> ((uint32_t) ib & 31);
    case AST_OR:
      return ia | ib;
    case AST_XOR:
      return ia ^ ib;
    case AST_AND:
      return ia & ib;
    default:
      throw_exception(v7, INTERNAL_ERROR, "%s", __func__); /* LCOV_EXCL_LINE */
      return 0;                                            /* LCOV_EXCL_LINE */
  }
}

/* Visual studio 2012+ has signbit() */
#if defined(V7_WINDOWS) && _MSC_VER < 1700
static int signbit(double x) {
  double s = _copysign(1, x);
  return s < 0;
}
#endif

static double i_num_bin_op(struct v7 *v7, enum ast_tag tag, double a,
                           double b) {
  switch (tag) {
    case AST_ADD: /* simple fixed width nodes with no payload */
      return a + b;
    case AST_SUB:
      return a - b;
    case AST_REM:
      if (b == 0 || isnan(b) || isnan(a) || isinf(b) || isinf(a)) {
        return NAN;
      }
      return (int) a % (int) b;
    case AST_MUL:
      return a * b;
    case AST_DIV:
      if (b == 0) {
        if (a == 0) return NAN;
        return (!signbit(a) == !signbit(b)) ? INFINITY : -INFINITY;
      }
      return a / b;
    case AST_LSHIFT:
    case AST_RSHIFT:
    case AST_URSHIFT:
    case AST_OR:
    case AST_XOR:
    case AST_AND:
      return i_int_bin_op(v7, tag, a, b);
    default:
      throw_exception(v7, INTERNAL_ERROR, "%s", __func__); /* LCOV_EXCL_LINE */
      return 0;                                            /* LCOV_EXCL_LINE */
  }
}

static int i_bool_bin_op(struct v7 *v7, enum ast_tag tag, double a, double b) {
#ifdef V7_BROKEN_NAN
  if (isnan(a) || isnan(b)) return tag == AST_NE || tag == AST_NE_NE;
#endif

  switch (tag) {
    case AST_EQ:
    case AST_EQ_EQ:
      return a == b;
    case AST_NE:
    case AST_NE_NE:
      return a != b;
    case AST_LT:
      return a < b;
    case AST_LE:
      return a <= b;
    case AST_GT:
      return a > b;
    case AST_GE:
      return a >= b;
    default:
      throw_exception(v7, INTERNAL_ERROR, "%s", __func__); /* LCOV_EXCL_LINE */
      return 0;                                            /* LCOV_EXCL_LINE */
  }
}

static __attribute__((noinline)) val_t
    i_eval_expr_common(struct v7 *v7, struct ast *a, ast_off_t *pos,
                       val_t scope) {
  enum ast_tag tag = ast_fetch_tag(a, pos);
  val_t res = v7_create_undefined(), v1 = v7_create_undefined();
  val_t v2 = v7_create_undefined();
  double dv;
  char *name;
  size_t name_len;
  struct gc_tmp_frame tf = new_tmp_frame(v7);

  tmp_stack_push(&tf, &res);
  tmp_stack_push(&tf, &v1);
  tmp_stack_push(&tf, &v2);

#if defined(V7_STACK_SIZE) && !defined(V7_DISABLE_INTERPRETER_STACK_CHECK)
  if ((void *) &v7 <= v7->sp_limit) {
    v7_throw(v7, "stack overflow");
  }
#endif

  if (v7->interrupt == 1) {
    v7->interrupt = 0;
    v7_throw(v7, "interrupted");
  }

  switch (tag) {
    case AST_NUM:
      ast_get_num(a, *pos, &dv);
      ast_move_to_children(a, pos);
      res = v7_create_number(dv);
      break;
    case AST_MEMBER:
      name = ast_get_inlined_data(a, *pos, &name_len);
      ast_move_to_children(a, pos);
      v1 = i_eval_expr(v7, a, pos, scope);
      res = v7_get(v7, v1, name, name_len);
      break;
    default:
      throw_exception(v7, INTERNAL_ERROR, "Unhandled op");
  }

  tmp_frame_cleanup(&tf);
  return res;
}

static NOINLINE val_t i_eval_expr_uncommon(struct v7 *v7, struct ast *a,
                                           ast_off_t *pos, val_t scope) {
  enum ast_tag tag = ast_fetch_tag(a, pos);
  ast_off_t end;
  val_t res = v7_create_undefined(), v1 = v7_create_undefined();
  val_t v2 = v7_create_undefined();
  double d1, d2;
  int i;
  /*
   * TODO(mkm): put this temporary somewhere in the evaluation context
   * or use alloca.
   */
  STATIC char buf[512];
  char *name;
  size_t name_len;
  struct gc_tmp_frame tf = new_tmp_frame(v7);

  tmp_stack_push(&tf, &res);
  tmp_stack_push(&tf, &v1);
  tmp_stack_push(&tf, &v2);

#if defined(V7_STACK_SIZE) && !defined(V7_DISABLE_INTERPRETER_STACK_CHECK)
  if ((void *) &v7 <= v7->sp_limit) {
    v7_throw(v7, "stack overflow");
  }
#endif

  if (v7->interrupt == 1) {
    v7->interrupt = 0;
    v7_throw(v7, "interrupted");
  }

  switch (tag) {
    case AST_NEGATIVE:
    case AST_POSITIVE:
      res = v7_create_number(i_num_unary_op(
          v7, tag, i_as_num(v7, i_eval_expr(v7, a, pos, scope))));
      break;
    case AST_ADD: {
      int l;
      v1 = i_eval_expr(v7, a, pos, scope);
      v2 = i_eval_expr(v7, a, pos, scope);
      v1 = i_value_of(v7, v1);
      v2 = i_value_of(v7, v2);
      if (!(v7_is_undefined(v1) || v7_is_number(v1) || v7_is_boolean(v1)) ||
          !(v7_is_undefined(v2) || v7_is_number(v2) || v7_is_boolean(v2))) {
        l = v7_stringify_value(v7, v1, buf, sizeof(buf));
        v1 = v7_create_string(v7, buf, l, 1);
        l = v7_stringify_value(v7, v2, buf, sizeof(buf));
        v2 = v7_create_string(v7, buf, l, 1);
        res = s_concat(v7, v1, v2);
      } else {
        res = v7_create_number(
            i_num_bin_op(v7, tag, i_as_num(v7, v1), i_as_num(v7, v2)));
      }
      break;
    }
    case AST_SUB:
    case AST_REM:
    case AST_MUL:
    case AST_DIV:
    case AST_LSHIFT:
    case AST_RSHIFT:
    case AST_URSHIFT:
    case AST_OR:
    case AST_XOR:
    case AST_AND:
      d1 = i_as_num(v7, i_eval_expr(v7, a, pos, scope));
      d2 = i_as_num(v7, i_eval_expr(v7, a, pos, scope));
      res = v7_create_number(i_num_bin_op(v7, tag, d1, d2));
      break;
    case AST_EQ_EQ:
      v1 = i_eval_expr(v7, a, pos, scope);
      v2 = i_eval_expr(v7, a, pos, scope);
      if (v7_is_string(v1) && v7_is_string(v2)) {
        res = v7_create_boolean(s_cmp(v7, v1, v2) == 0);
      } else if (v1 == v2 && v1 == V7_TAG_NAN) {
        res = v7_create_boolean(0);
      } else {
        res = v7_create_boolean(v1 == v2);
      }
      break;
    case AST_NE_NE:
      v1 = i_eval_expr(v7, a, pos, scope);
      v2 = i_eval_expr(v7, a, pos, scope);
      if (v7_is_string(v1) && v7_is_string(v2)) {
        res = v7_create_boolean(s_cmp(v7, v1, v2) != 0);
      } else if (v1 == v2 && v1 == V7_TAG_NAN) {
        res = v7_create_boolean(1);
      } else {
        res = v7_create_boolean(v1 != v2);
      }
      break;
    case AST_EQ:
    case AST_NE:
    case AST_LT:
    case AST_LE:
    case AST_GT:
    case AST_GE:
      v1 = i_value_of(v7, i_eval_expr(v7, a, pos, scope));
      v2 = i_value_of(v7, i_eval_expr(v7, a, pos, scope));
      if (tag == AST_EQ || tag == AST_NE) {
        if (((v7_is_object(v1) || v7_is_object(v2)) && v1 == v2)) {
          res = v7_create_boolean(tag == AST_EQ);
          break;
        } else if (v7_is_undefined(v1) || v7_is_null(v1)) {
          res = v7_create_boolean((tag != AST_EQ) ^
                                  (v7_is_undefined(v2) || v7_is_null(v2)));
          break;
        } else if (v7_is_undefined(v2) || v7_is_null(v2)) {
          res = v7_create_boolean((tag != AST_EQ) ^
                                  (v7_is_undefined(v1) || v7_is_null(v1)));
          break;
        }
      }
      if (v7_is_string(v1) && v7_is_string(v2)) {
        int cmp = s_cmp(v7, v1, v2);
        switch (tag) {
          case AST_EQ:
            res = v7_create_boolean(cmp == 0);
            break;
          case AST_NE:
            res = v7_create_boolean(cmp != 0);
            break;
          case AST_LT:
            res = v7_create_boolean(cmp < 0);
            break;
          case AST_LE:
            res = v7_create_boolean(cmp <= 0);
            break;
          case AST_GT:
            res = v7_create_boolean(cmp > 0);
            break;
          case AST_GE:
            res = v7_create_boolean(cmp >= 0);
            break;
          default:
            throw_exception(v7, INTERNAL_ERROR, "Unhandled op");
        }
      } else {
        res = v7_create_boolean(
            i_bool_bin_op(v7, tag, i_as_num(v7, v1), i_as_num(v7, v2)));
      }
      break;
    case AST_LOGICAL_OR:
      v1 = i_eval_expr(v7, a, pos, scope);
      if (v7_is_true(v7, v1)) {
        ast_skip_tree(a, pos);
        res = v1;
      } else {
        res = i_eval_expr(v7, a, pos, scope);
      }
      break;
    case AST_LOGICAL_AND:
      v1 = i_eval_expr(v7, a, pos, scope);
      if (!v7_is_true(v7, v1)) {
        ast_skip_tree(a, pos);
        res = v1;
      } else {
        res = i_eval_expr(v7, a, pos, scope);
      }
      break;
    case AST_LOGICAL_NOT:
      v1 = i_eval_expr(v7, a, pos, scope);
      res = v7_create_boolean(!(int64_t) v7_is_true(v7, v1));
      break;
    case AST_NOT:
      v1 = i_eval_expr(v7, a, pos, scope);
      d1 = i_as_num(v7, v1);
      if (isnan(d1) || isinf(d1)) {
        res = v7_create_number(-1);
      } else {
        res = v7_create_number(~(int64_t) d1);
      }
      break;
    case AST_ASSIGN:
    case AST_REM_ASSIGN:
    case AST_MUL_ASSIGN:
    case AST_DIV_ASSIGN:
    case AST_XOR_ASSIGN:
    case AST_PLUS_ASSIGN:
    case AST_MINUS_ASSIGN:
    case AST_OR_ASSIGN:
    case AST_AND_ASSIGN:
    case AST_LSHIFT_ASSIGN:
    case AST_RSHIFT_ASSIGN:
    case AST_URSHIFT_ASSIGN:
    case AST_PREINC:
    case AST_PREDEC:
    case AST_POSTINC:
    case AST_POSTDEC: {
      struct v7_property *prop;
      enum ast_tag op = tag;
      val_t lval = v7_create_undefined(), root = v7->global_object;
      tmp_stack_push(&tf, &lval);
      tmp_stack_push(&tf, &root);
      switch ((tag = ast_fetch_tag(a, pos))) {
        case AST_IDENT:
          lval = scope;
          name = ast_get_inlined_data(a, *pos, &name_len);
          ast_move_to_children(a, pos);
          break;
        case AST_MEMBER:
          name = ast_get_inlined_data(a, *pos, &name_len);
          ast_move_to_children(a, pos);
          lval = root = i_eval_expr(v7, a, pos, scope);
          break;
        case AST_INDEX:
          lval = root = i_eval_expr(v7, a, pos, scope);
          v1 = i_eval_expr(v7, a, pos, scope);
          name_len = v7_stringify_value(v7, v1, buf, sizeof(buf));
          name = buf;
          break;
        default:
          throw_exception(v7, REFERENCE_ERROR,
                          "Invalid left-hand side in assignment");
          /* unreacheable */
          return v7_create_undefined(); /* LCOV_EXCL_LINE */
      }

      /*
       * TODO(mkm): this will incorrectly mutate an existing property in
       * Object.prototype instead of creating a new variable in `global`.
       * `get_property` should also return a pointer to the object where
       * the property is found.
       */
      v1 = v7_create_undefined();
      prop = v7_get_property(v7, lval, name, name_len);
      if (prop != NULL) {
        v1 = prop->value;
      }

      switch (op) {
        case AST_PREINC:
          v1 = res = v7_create_number(i_as_num(v7, v1) + 1.0);
          break;
        case AST_PREDEC:
          v1 = res = v7_create_number(i_as_num(v7, v1) - 1.0);
          break;
        case AST_POSTINC:
          res = i_value_of(v7, v1);
          v1 = v7_create_number(i_as_num(v7, v1) + 1.0);
          break;
        case AST_POSTDEC:
          res = i_value_of(v7, v1);
          v1 = v7_create_number(i_as_num(v7, v1) - 1.0);
          break;
        case AST_ASSIGN:
          v1 = res = i_eval_expr(v7, a, pos, scope);
          break;
        case AST_PLUS_ASSIGN:
          res = i_eval_expr(v7, a, pos, scope);
          v1 = i_value_of(v7, v1);
          res = i_value_of(v7, res);
          if (!(v7_is_undefined(v1) || v7_is_number(v1) || v7_is_boolean(v1)) ||
              !(v7_is_undefined(res) || v7_is_number(res) ||
                v7_is_boolean(res))) {
            /*
             * Only stringify non-strings. Note that if an object is large,
             * v7_stringify_value() might not fit it in sizeof(buf).
             */
            if (!v7_is_string(v1)) {
              v7_stringify_value(v7, v1, buf, sizeof(buf));
              v1 = v7_create_string(v7, buf, strlen(buf), 1);
            }
            if (!v7_is_string(res)) {
              v7_stringify_value(v7, res, buf, sizeof(buf));
              res = v7_create_string(v7, buf, strlen(buf), 1);
            }
            v1 = res = s_concat(v7, v1, res);
            break;
          }
          res = v1 = v7_create_number(
              i_num_bin_op(v7, AST_ADD, i_as_num(v7, v1), i_as_num(v7, res)));
          break;
        default:
          op = assign_op_map[op - AST_ASSIGN - 1];
          res = i_eval_expr(v7, a, pos, scope);
          d1 = i_as_num(v7, v1);
          d2 = i_as_num(v7, res);
          res = v1 = v7_create_number(i_num_bin_op(v7, op, d1, d2));
      }

      if (v7_is_object(lval) &&
          v7_to_object(lval)->attributes & V7_OBJ_DENSE_ARRAY) {
        int ok;
        unsigned long i = cstr_to_ulong(name, name_len, &ok);
        if (ok) {
          v7_array_set(v7, lval, i, v1);
          break;
        }
      }

      if (prop != NULL && tag == AST_IDENT) {
        /* variables are modified where they are found in the scope chain */
        prop->value = v1;
      } else if (prop != NULL && prop->attributes & V7_PROPERTY_READ_ONLY) {
        /* nop */
      } else if (prop != NULL && prop->attributes & V7_PROPERTY_SETTER) {
        v7_invoke_setter(v7, prop, root, v1);
      } else {
        v7_set_property(v7, root, name, name_len, 0, v1);
      }
      break;
    }
    case AST_INDEX:
      v1 = i_eval_expr(v7, a, pos, scope);
      v2 = i_eval_expr(v7, a, pos, scope);
      res = v7_get_v(v7, v1, v2);
      break;
    case AST_SEQ:
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      while (*pos < end) {
        res = i_eval_expr(v7, a, pos, scope);
      }
      break;
    case AST_ARRAY:
      res = v7_create_array(v7);
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      for (i = 0; *pos < end; i++) {
        ast_off_t lookahead = *pos;
        tag = ast_fetch_tag(a, &lookahead);
        v1 = i_eval_expr(v7, a, pos, scope);
        if (tag != AST_NOP) {
          v7_array_set(v7, res, i, v1);
        }
      }
      break;
    case AST_OBJECT:
      res = v7_create_object(v7);
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      while (*pos < end) {
        tag = ast_fetch_tag(a, pos);
        switch (tag) {
          case AST_PROP:
            name = ast_get_inlined_data(a, *pos, &name_len);
            ast_move_to_children(a, pos);
            v1 = i_eval_expr(v7, a, pos, scope);
            if (v7->strict_mode &&
                v7_get_own_property(v7, res, name, name_len) != NULL) {
              /* Ideally this should be thrown at parse time */
              throw_exception(v7, SYNTAX_ERROR,
                              "duplicate data property in object literal "
                              "not allowed in strict mode");
            }
            v7_set_property(v7, res, name, name_len, 0, v1);
            break;
          case AST_GETTER:
          case AST_SETTER: {
            ast_off_t func = *pos;
            unsigned int attr =
                tag == AST_GETTER ? V7_PROPERTY_GETTER : V7_PROPERTY_SETTER;
            unsigned int other =
                tag == AST_GETTER ? V7_PROPERTY_SETTER : V7_PROPERTY_GETTER;
            struct v7_property *p;
            V7_CHECK(v7, ast_fetch_tag(a, &func) == AST_FUNC);
            ast_move_to_children(a, &func);
            V7_CHECK(v7, ast_fetch_tag(a, &func) == AST_IDENT);
            name = ast_get_inlined_data(a, func, &name_len);
            v1 = i_eval_expr(v7, a, pos, scope);
            if ((p = v7_get_property(v7, res, name, name_len)) &&
                p->attributes & other) {
              val_t arr = v7_create_dense_array(v7);
              tmp_stack_push(&tf, &arr);
              v7_array_set(v7, arr, tag == AST_GETTER ? 1 : 0, p->value);
              v7_array_set(v7, arr, tag == AST_SETTER ? 1 : 0, v1);
              p->value = arr;
              p->attributes |= attr;
            } else {
              v7_set_property(v7, res, name, name_len, attr, v1);
            }
            break;
          }
          default:
            throw_exception(v7, INTERNAL_ERROR,
                            "Expecting AST_(PROP|GETTER|SETTER) got %d", tag);
        }
      }
      break;
    case AST_TRUE:
      res = v7_create_boolean(1);
      break;
    case AST_FALSE:
      res = v7_create_boolean(0);
      break;
    case AST_NULL:
      res = v7_create_null();
      break;
    case AST_USE_STRICT:
    case AST_NOP:
    case AST_UNDEFINED:
      res = v7_create_undefined();
      break;
    case AST_STRING:
      name = ast_get_inlined_data(a, *pos, &name_len);
      ast_move_to_children(a, pos);
      res = v7_create_string(v7, name, name_len, 1);
      break;
    case AST_REGEX: {
#if V7_ENABLE__RegExp
      char *p;
      name = ast_get_inlined_data(a, *pos, &name_len);
      ast_move_to_children(a, pos);
      for (p = name + name_len - 1; *p != '/';) p--;
      res = v7_create_regexp(v7, name + 1, p - (name + 1), p + 1,
                             (name + name_len) - p - 1);
      break;
#else
      throw_exception(v7, INTERNAL_ERROR, "Regexp support is disabled");
#endif
    }
    case AST_IDENT: {
      struct v7_property *p;
      name = ast_get_inlined_data(a, *pos, &name_len);
      ast_move_to_children(a, pos);
      if ((p = v7_get_property(v7, scope, name, name_len)) == NULL) {
        throw_exception(v7, REFERENCE_ERROR, "[%.*s] is not defined",
                        (int) name_len, name);
      }
      res = v7_property_value(v7, scope, p);
      break;
    }
    case AST_FUNC: {
      ast_off_t fbody;
      struct v7_function *funcp;
      res = create_function(v7);
      funcp = v7_to_function(res);
      tmp_stack_push(&tf, &res);
      funcp->scope = v7_to_object(scope);
      funcp->ast = a;
      funcp->ast->refcnt++;
      funcp->ast_off = *pos - 1;
      ast_move_to_children(a, pos);
      tag = ast_fetch_tag(a, pos);
      if (tag == AST_IDENT) {
        name = ast_get_inlined_data(a, *pos, &name_len);
        v7_set_property(v7, scope, name, name_len, 0, res);
      }
      *pos = ast_get_skip(a, funcp->ast_off + 1, AST_END_SKIP);
      fbody = ast_get_skip(a, funcp->ast_off + 1, AST_FUNC_BODY_SKIP);
      if (fbody < *pos && (tag = ast_fetch_tag(a, &fbody)) == AST_USE_STRICT) {
        funcp->attributes |= V7_FUNCTION_STRICT;
      }
      break;
    }
    case AST_CALL: {
      ast_off_t pp = *pos;
      ast_move_to_children(a, &pp);
      v1 = i_find_this(v7, a, pp, scope);
      res = i_eval_call(v7, a, pos, scope, v1, 0);
      break;
    }
    case AST_NEW:
      v1 = v7_create_object(v7);
      res = i_eval_call(v7, a, pos, scope, v1, 1);
      if (v7_is_undefined(res) || v7_is_null(res)) {
        res = v1;
      }
      break;
    case AST_COND:
      if (v7_is_true(v7, i_eval_expr(v7, a, pos, scope))) {
        res = i_eval_expr(v7, a, pos, scope);
        ast_skip_tree(a, pos); /* TODO(mkm): change AST to include skips ? */
      } else {
        ast_skip_tree(a, pos);
        res = i_eval_expr(v7, a, pos, scope);
      }
      break;
    case AST_IN:
      v1 = i_eval_expr(v7, a, pos, scope);
      v7_stringify_value(v7, v1, buf, sizeof(buf));
      v2 = i_eval_expr(v7, a, pos, scope);
      res = v7_create_boolean(v7_get_property(v7, v2, buf, -1) != NULL);
      break;
    case AST_VAR:
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      while (*pos < end) {
        struct v7_property *prop;
        tag = ast_fetch_tag(a, pos);
        /* func declarations are already set during hoisting */
        if (tag == AST_FUNC_DECL) {
          ast_move_to_children(a, pos);
          ast_skip_tree(a, pos);
          continue;
        }

        V7_CHECK(v7, tag == AST_VAR_DECL);
        name = ast_get_inlined_data(a, *pos, &name_len);
        ast_move_to_children(a, pos);
        res = i_eval_expr(v7, a, pos, scope);
        /*
         * Var decls are hoisted when the function frame is created. Vars
         * declared inside a `with` or `catch` block belong to the function
         * lexical scope, and although those clauses create an inner frame
         * no new variables should be created in it. A var decl thus
         * behaves as a normal assignment at runtime.
         */
        if ((prop = v7_get_property(v7, scope, name, name_len)) != NULL) {
          prop->value = res;
        } else {
          v7_set_property(v7, v7->global_object, name, name_len, 0, res);
        }
      }
      break;
    case AST_THIS:
      res = v7->this_object;
      break;
    case AST_TYPEOF: {
      ast_off_t peek = *pos;
      if ((tag = ast_fetch_tag(a, &peek)) == AST_IDENT) {
        name = ast_get_inlined_data(a, peek, &name_len);
        if (v7_get_property(v7, scope, name, name_len) == NULL) {
          ast_move_to_children(a, &peek);
          *pos = peek;
          /* TODO(mkm): use interned strings */
          res = v7_create_string(v7, "undefined", 9, 1);
          break;
        }
      }
      /* for some reason lcov doesn't mark the following lines as executing */
      res = i_eval_expr(v7, a, pos, scope); /* LCOV_EXCL_LINE */
      switch (val_type(v7, res)) {          /* LCOV_EXCL_LINE */
        case V7_TYPE_NUMBER:
          res = v7_create_string(v7, "number", 6, 1);
          break;
        case V7_TYPE_STRING:
          res = v7_create_string(v7, "string", 6, 1);
          break;
        case V7_TYPE_BOOLEAN:
          res = v7_create_string(v7, "boolean", 7, 1);
          break;
        case V7_TYPE_FUNCTION_OBJECT:
        case V7_TYPE_CFUNCTION_OBJECT:
        case V7_TYPE_CFUNCTION:
          res = v7_create_string(v7, "function", 8, 1);
          break;
        default:
          res = v7_create_string(v7, "object", 6, 1);
          break;
      }
      break;
    }
    case AST_DELETE: {
      struct v7_property *prop;
      val_t lval = v7_create_null(), root = v7->global_object;
      ast_off_t start = *pos;
      tmp_stack_push(&tf, &lval);
      tmp_stack_push(&tf, &root);
      switch ((tag = ast_fetch_tag(a, pos))) {
        case AST_IDENT:
          name = ast_get_inlined_data(a, *pos, &name_len);
          ast_move_to_children(a, pos);
          if (v7_get_property(v7, scope, name, name_len) ==
              v7_get_property(v7, root, name, name_len)) {
            lval = root;
          }
          if (v7->strict_mode) {
            throw_exception(v7, SYNTAX_ERROR, "Delete in strict");
          }
          break;
        case AST_MEMBER:
          name = ast_get_inlined_data(a, *pos, &name_len);
          ast_move_to_children(a, pos);
          lval = root = i_eval_expr(v7, a, pos, scope);
          break;
        case AST_INDEX:
          lval = root = i_eval_expr(v7, a, pos, scope);
          res = i_eval_expr(v7, a, pos, scope);
          name_len = v7_stringify_value(v7, res, buf, sizeof(buf));
          name = buf;
          break;
        default:
          *pos = start;
          i_eval_expr(v7, a, pos, scope);
          res = v7_create_boolean(1);
          goto cleanup;
      }

      if (v7_is_object(lval) &&
          v7_to_object(lval)->attributes & V7_OBJ_DENSE_ARRAY) {
        int ok;
        unsigned long i = cstr_to_ulong(name, name_len, &ok);
        if (ok) {
          int has;
          v7_array_get2(v7, lval, (unsigned long) i, &has);
          if (has) {
            v7_array_set(v7, lval, (unsigned long) i, V7_TAG_NOVALUE);
          }
          res = v7_create_boolean(1);
        }
      }

      prop = v7_get_property(v7, lval, name, name_len);
      if (prop != NULL) {
        if (prop->attributes & V7_PROPERTY_DONT_DELETE) {
          res = v7_create_boolean(0);
          break;
        }
        v7_del_property(v7, lval, name, name_len);
      }
      res = v7_create_boolean(1);
      break;
    }
    case AST_INSTANCEOF:
      v1 = i_eval_expr(v7, a, pos, scope);
      v2 = i_eval_expr(v7, a, pos, scope);
      if (!v7_is_function(v2) && !v7_is_cfunction(i_value_of(v7, v2))) {
        throw_exception(v7, TYPE_ERROR,
                        "Expecting a function in instanceof check");
      }
      res = v7_create_boolean(
          is_prototype_of(v7, v1, v7_get(v7, v2, "prototype", 9)));
      break;
    case AST_VOID:
      i_eval_expr(v7, a, pos, scope);
      res = v7_create_undefined();
      break;
    default: {
#ifndef V7_DISABLE_AST_TAG_NAMES
      const struct ast_node_def *def = &ast_node_defs[tag];
      throw_exception(v7, INTERNAL_ERROR, "%s", def->name); /* LCOV_EXCL_LINE */
#else
      throw_exception(v7, INTERNAL_ERROR, "TAG_%d", tag); /* LCOV_EXCL_LINE */
#endif
      /* unreacheable */
      break;
    }
  }

cleanup:
  tmp_frame_cleanup(&tf);
  return res;
}

static val_t i_eval_expr(struct v7 *v7, struct ast *a, ast_off_t *pos,
                         val_t scope) {
  enum ast_tag tag = (enum ast_tag)(uint8_t) * (a->mbuf.buf + *pos);
  switch (tag) {
    case AST_NUM:
    case AST_MEMBER:
      return i_eval_expr_common(v7, a, pos, scope);
    default:
      return i_eval_expr_uncommon(v7, a, pos, scope);
  }
}

static val_t i_find_this(struct v7 *v7, struct ast *a, ast_off_t pos,
                         val_t scope) {
  enum ast_tag tag = ast_fetch_tag(a, &pos);
  switch (tag) {
    case AST_MEMBER:
      ast_move_to_children(a, &pos);
      return i_eval_expr(v7, a, &pos, scope);
    case AST_INDEX:
      return i_eval_expr(v7, a, &pos, scope);
    default:
      return V7_UNDEFINED;
  }
}

static void i_populate_local_vars(struct v7 *v7, struct ast *a, ast_off_t start,
                                  ast_off_t fvar, val_t frame) {
  enum ast_tag tag;
  ast_off_t next, fvar_end;
  char *name;
  size_t name_len;
  val_t val = v7_create_undefined();
  struct gc_tmp_frame tf = new_tmp_frame(v7);

  if (fvar == start) {
    tmp_frame_cleanup(&tf);
    return;
  }

  tmp_stack_push(&tf, &val);

  do {
    tag = ast_fetch_tag(a, &fvar);
    V7_CHECK(v7, tag == AST_VAR);
    next = ast_get_skip(a, fvar, AST_VAR_NEXT_SKIP);
    if (next == fvar) {
      next = 0;
    }
    V7_CHECK(v7, next < 1024 * 128);

    fvar_end = ast_get_skip(a, fvar, AST_END_SKIP);
    ast_move_to_children(a, &fvar);
    while (fvar < fvar_end) {
      val = v7_create_undefined();
      tag = ast_fetch_tag(a, &fvar);
      V7_CHECK(v7, tag == AST_VAR_DECL || tag == AST_FUNC_DECL);
      name = ast_get_inlined_data(a, fvar, &name_len);
      ast_move_to_children(a, &fvar);
      if (tag == AST_VAR_DECL) {
        ast_skip_tree(a, &fvar);
      } else {
        val = i_eval_expr(v7, a, &fvar, frame);
      }
      v7_set_property(v7, frame, name, name_len, 0, val);
    }
    if (next > 0) {
      fvar = next - 1; /* TODO(mkm): cleanup */
    }
  } while (next != 0);

  tmp_frame_cleanup(&tf);
}

V7_PRIVATE val_t i_prepare_call(struct v7 *v7, struct v7_function *func,
                                ast_off_t *pos, ast_off_t *body,
                                ast_off_t *end) {
  val_t frame;
  enum ast_tag tag;
  ast_off_t fstart, fvar;
  struct gc_tmp_frame tf = new_tmp_frame(v7);

  *pos = func->ast_off;
  fstart = *pos;
  tag = ast_fetch_tag(func->ast, pos);
  V7_CHECK(v7, tag == AST_FUNC);
  *end = ast_get_skip(func->ast, *pos, AST_END_SKIP);
  *body = ast_get_skip(func->ast, *pos, AST_FUNC_BODY_SKIP);
  fvar = ast_get_skip(func->ast, *pos, AST_FUNC_FIRST_VAR_SKIP) - 1;
  ast_move_to_children(func->ast, pos);
  ast_skip_tree(func->ast, pos);

  frame = v7_create_object(v7);
  v7_to_object(frame)->prototype = func->scope;

  tmp_stack_push(&tf, &frame);
  i_populate_local_vars(v7, func->ast, fstart, fvar, frame);
  tmp_frame_cleanup(&tf);
  return frame;
}

V7_PRIVATE val_t i_invoke_function(struct v7 *v7, struct v7_function *func,
                                   val_t frame, ast_off_t body, ast_off_t end) {
#ifndef V7_FORCE_STRICT_MODE
  int saved_strict_mode = v7->strict_mode;
#endif
  enum i_break brk = B_RUN;
  val_t res = v7_create_undefined(), saved_call_stack = v7->call_stack;
  struct gc_tmp_frame tf = new_tmp_frame(v7);

  tmp_stack_push(&tf, &res);
#ifndef V7_FORCE_STRICT_MODE
  if (func->attributes & V7_FUNCTION_STRICT) {
    v7->strict_mode = 1;
  }
#endif
  v7->call_stack = frame; /* ensure GC knows about this call frame */
  res = i_eval_stmts(v7, func->ast, &body, end, frame, &brk);
  if (brk != B_RETURN) {
    res = v7_create_undefined();
  }
#ifndef V7_FORCE_STRICT_MODE
  v7->strict_mode = saved_strict_mode;
#endif
  v7->call_stack = saved_call_stack;

  tmp_frame_cleanup(&tf);
  return res;
}

static val_t i_eval_call(struct v7 *v7, struct ast *a, ast_off_t *pos,
                         val_t scope, val_t this_object, int is_constructor) {
  ast_off_t end, fpos, fend, fbody;
  val_t frame = v7_create_undefined(), res = v7_create_undefined();
  val_t v1 = v7_create_undefined(), args = v7_create_undefined();
  val_t cfunc = v7_create_undefined(), old_this = v7->this_object;
  val_t fun_proto = v7_create_undefined();
  struct v7_function *func;
  enum ast_tag tag;
  char *name;
  size_t name_len;
  int i;

  struct gc_tmp_frame tf = new_tmp_frame(v7);
  tmp_stack_push(&tf, &frame);
  tmp_stack_push(&tf, &res);
  tmp_stack_push(&tf, &v1);
  tmp_stack_push(&tf, &args);
  tmp_stack_push(&tf, &old_this);
  tmp_stack_push(&tf, &fun_proto);

  end = ast_get_skip(a, *pos, AST_END_SKIP);
  ast_move_to_children(a, pos);
  cfunc = v1 = i_eval_expr(v7, a, pos, scope);
  if (!v7_is_cfunction(v1) && !v7_is_function(v1)) {
    /* extract the hidden property from a cfunction_object */
    struct v7_property *p;
    p = v7_get_own_property2(v7, v1, "", 0, V7_PROPERTY_HIDDEN);
    if (p != NULL) {
      cfunc = p->value;
    }
  }

  if (is_constructor) {
    if (!v7_is_cfunction(v1)) {
      fun_proto = v7_get(v7, v1, "prototype", 9);
      if (!v7_is_object(fun_proto)) {
        /* TODO(mkm): box primitive value */
        throw_exception(v7, TYPE_ERROR,
                        "Cannot set a primitive value as object prototype");
      }
      v7_to_object(this_object)->prototype = v7_to_object(fun_proto);
    }
  } else if (v7_is_undefined(this_object) && v7_is_function(v1) &&
             !(v7_to_function(v1)->attributes & V7_FUNCTION_STRICT)) {
    /*
     * null and undefined are replaced with `global` in non-strict mode,
     * as per ECMA-262 6th, 19.2.3.3.
     */
    this_object = v7->global_object;
  }

  if (v7_is_cfunction(cfunc)) {
    args = v7_create_dense_array(v7);
    for (i = 0; *pos < end; i++) {
      res = i_eval_expr(v7, a, pos, scope);
      v7_array_set(v7, args, i, res);
    }
    res = v7_to_cfunction(cfunc)(v7, this_object, args);
    goto cleanup;
  }
  if (!v7_is_function(v1)) {
    throw_exception(v7, TYPE_ERROR, "%s",
                    "value is not a function"); /* LCOV_EXCL_LINE */
  }

  func = v7_to_function(v1);
  frame = i_prepare_call(v7, func, &fpos, &fbody, &fend);

  /*
   * TODO(mkm): don't create args array if the parser didn't see
   * any `arguments` or `eval` identifier being referenced in the function.
   */
  args = v7_create_dense_array(v7);

  /* scan actual and formal arguments and updates the value in the frame */
  for (i = 0; fpos < fbody; i++) {
    tag = ast_fetch_tag(func->ast, &fpos);
    V7_CHECK(v7, tag == AST_IDENT);
    name = ast_get_inlined_data(func->ast, fpos, &name_len);
    ast_move_to_children(func->ast, &fpos);

    if (*pos < end) {
      res = i_eval_expr(v7, a, pos, scope);
      if (!v7_is_undefined(args)) {
        v7_array_set(v7, args, i, res);
      }
    } else {
      res = v7_create_undefined();
    }

    v7_set_property(v7, frame, name, name_len, 0, res);
  }

  /* evaluate trailing actual arguments for side effects */
  for (; *pos < end; i++) {
    res = i_eval_expr(v7, a, pos, scope);
    if (!v7_is_undefined(args)) {
      v7_array_set(v7, args, i, res);
    }
  }

  if (!v7_is_undefined(args)) {
#ifndef V7_DISABLE_PREDEFINED_STRINGS
    v7_set_v(v7, frame, v7->predefined_strings[PREDEFINED_STR_ARGUMENTS], args);
#else
    v7_set(v7, frame, "arguments", 9, 0, args);
#endif
  }

  v7->this_object = this_object;
  res = i_invoke_function(v7, func, frame, fbody, fend);
  v7->this_object = old_this;

cleanup:
  tmp_frame_cleanup(&tf);
  return res;
}

static val_t i_eval_stmt(struct v7 *, struct ast *, ast_off_t *, val_t,
                         enum i_break *);

static val_t i_eval_stmts(struct v7 *v7, struct ast *a, ast_off_t *pos,
                          ast_off_t end, val_t scope, enum i_break *brk) {
  val_t res = v7_create_undefined();
  while (*pos < end && !*brk) {
    res = i_eval_stmt(v7, a, pos, scope, brk);
  }
  return res;
}

static val_t i_eval_stmt(struct v7 *v7, struct ast *a, ast_off_t *pos,
                         val_t scope, enum i_break *brk) {
#ifndef V7_FORCE_STRICT_MODE
  ast_off_t maybe_strict;
#endif
  ast_off_t start = *pos;
  enum ast_tag tag = ast_fetch_tag(a, pos);
  val_t res = v7_create_undefined();
  volatile ast_off_t end; /* Only to pacify GCC. */
  ast_off_t end_true, cond, iter_end, loop, iter, finally, acatch, fvar;
#ifndef V7_FORCE_STRICT_MODE
  int saved_strict_mode = v7->strict_mode;
#endif
  struct gc_tmp_frame tf = new_tmp_frame(v7);
  tmp_stack_push(&tf, &res);

#ifdef V7_ENABLE_GC
  if (v7->need_gc) {
    v7_gc(v7, 0);
    v7->need_gc = 0;
  }
#endif

  switch (tag) {
    case AST_SCRIPT:
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      fvar = ast_get_skip(a, *pos, AST_FUNC_FIRST_VAR_SKIP) - 1;
      ast_move_to_children(a, pos);
#ifndef V7_FORCE_STRICT_MODE
      maybe_strict = *pos;
      if (*pos < end &&
          (tag = ast_fetch_tag(a, &maybe_strict)) == AST_USE_STRICT) {
        v7->strict_mode = 1;
        *pos = maybe_strict;
      }
#endif
      i_populate_local_vars(v7, a, start, fvar, scope);
      res = i_eval_stmts(v7, a, pos, end, scope, brk);
#ifndef V7_FORCE_STRICT_MODE
      v7->strict_mode = saved_strict_mode;
#endif
      break;
    case AST_IF:
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      end_true = ast_get_skip(a, *pos, AST_END_IF_TRUE_SKIP);
      ast_move_to_children(a, pos);
      if (v7_is_true(v7, i_eval_expr(v7, a, pos, scope))) {
        res = i_eval_stmts(v7, a, pos, end_true, scope, brk);
        if (*brk != B_RUN) {
          break;
        }
      } else {
        res = i_eval_stmts(v7, a, &end_true, end, scope, brk);
        if (*brk != B_RUN) {
          break;
        }
      }
      *pos = end;
      break;
    case AST_WHILE:
      v7->lab_cont = 0;
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      cond = *pos;
      for (;;) {
        if (v7_is_true(v7, i_eval_expr(v7, a, pos, scope))) {
          res = i_eval_stmts(v7, a, pos, end, scope, brk);
          switch (*brk) {
            case B_RUN:
              break;
            case B_CONTINUE:
              *brk = B_RUN;
              break;
            case B_BREAK:
              *brk = B_RUN; /* fall through */
            case B_RETURN:
              *pos = end;
              goto cleanup;
          }
        } else {
          *pos = end;
          break;
        }
        *pos = cond;
      }
      break;
    case AST_DOWHILE:
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      iter_end = ast_get_skip(a, *pos, AST_DO_WHILE_COND_SKIP);
      ast_move_to_children(a, pos);
      /* skip to condition if coming from a labeled continue */
      if (v7->lab_cont) {
        *pos = iter_end;
        v7->lab_cont = 0;
      }
      loop = *pos;
      for (;;) {
        res = i_eval_stmts(v7, a, pos, iter_end, scope, brk);
        switch (*brk) {
          case B_RUN:
            break;
          case B_CONTINUE:
            *pos = iter_end;
            *brk = B_RUN;
            break;
          case B_BREAK:
            *brk = B_RUN; /* fall through */
          case B_RETURN:
            *pos = end;
            goto cleanup;
        }
        if (!v7_is_true(v7, i_eval_expr(v7, a, pos, scope))) {
          break;
        }
        *pos = loop;
      }
      break;
    case AST_FOR:
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      iter_end = ast_get_skip(a, *pos, AST_FOR_BODY_SKIP);
      ast_move_to_children(a, pos);
      /* initializer */
      if (!v7->lab_cont) {
        i_eval_expr(v7, a, pos, scope);
      } else {
        ast_skip_tree(a, pos);
        iter = *pos;
        ast_skip_tree(a, &iter);
        i_eval_expr(v7, a, &iter, scope);
        v7->lab_cont = 0;
      }
      for (;;) {
        loop = *pos;
        if (!v7_is_true(v7, i_eval_expr(v7, a, &loop, scope))) {
          *pos = end;
          goto cleanup;
        }
        iter = loop;
        loop = iter_end;
        res = i_eval_stmts(v7, a, &loop, end, scope, brk);
        switch (*brk) {
          case B_RUN:
            break;
          case B_CONTINUE:
            *brk = B_RUN;
            break;
          case B_BREAK:
            *brk = B_RUN; /* fall through */
          case B_RETURN:
            *pos = end;
            goto cleanup;
        }
        i_eval_expr(v7, a, &iter, scope);
      }
    case AST_FOR_IN: {
      char *name;
      size_t name_len;
      val_t obj, key;
      ast_off_t loop;
      struct v7_property *p, *var;
      tmp_stack_push(&tf, &obj);
      tmp_stack_push(&tf, &key);

      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      tag = ast_fetch_tag(a, pos);
      /* TODO(mkm) accept any l-value */
      if (tag == AST_VAR) {
        ast_move_to_children(a, pos);
        tag = ast_fetch_tag(a, pos);
        V7_CHECK(v7, tag == AST_VAR_DECL);
        name = ast_get_inlined_data(a, *pos, &name_len);
        ast_move_to_children(a, pos);
        ast_skip_tree(a, pos);
      } else {
        V7_CHECK(v7, tag == AST_IDENT);
        name = ast_get_inlined_data(a, *pos, &name_len);
        ast_move_to_children(a, pos);
      }

      obj = i_eval_expr(v7, a, pos, scope);
      if (!v7_is_object(obj)) {
        *pos = end;
        goto cleanup;
      }
      ast_skip_tree(a, pos);
      loop = *pos;

      /* first iterate on dense array elements if any */
      /* TODO(mkm): make it DRY */
      if (v7_to_object(obj)->attributes & V7_OBJ_DENSE_ARRAY) {
        struct v7_property *p =
            v7_get_own_property2(v7, obj, "", 0, V7_PROPERTY_HIDDEN);
        struct mbuf *abuf;
        if (p != NULL) {
          abuf = (struct mbuf *) v7_to_foreign(p->value);
          if (abuf != NULL) {
            unsigned long i, len = v7_array_length(v7, obj);
            for (i = 0; i < len; i++, *pos = loop) {
              key = ulong_to_str(v7, i);
              if ((var = v7_get_property(v7, scope, name, name_len)) != NULL) {
                var->value = key;
              } else {
                v7_set_property(v7, v7->global_object, name, name_len, 0, key);
              }
              res = i_eval_stmts(v7, a, pos, end, scope,
                                 brk); /* LCOV_EXCL_LINE */
              switch (*brk) {          /* LCOV_EXCL_LINE */
                case B_RUN:
                  break;
                case B_CONTINUE:
                  *brk = B_RUN;
                  break;
                case B_BREAK:
                  *brk = B_RUN; /* fall through */
                case B_RETURN:
                  *pos = end;
                  goto cleanup;
              }
            }
          }
        }
      }
      loop = *pos;

      for (p = v7_to_object(obj)->properties; p; p = p->next, *pos = loop) {
        if (p->attributes & (V7_PROPERTY_HIDDEN | V7_PROPERTY_DONT_ENUM)) {
          continue;
        }
        key = p->name;
        if ((var = v7_get_property(v7, scope, name, name_len)) != NULL) {
          var->value = key;
        } else {
          v7_set_property(v7, v7->global_object, name, name_len, 0, key);
        }

        /* for some reason lcov doesn't mark the following lines executing */
        res = i_eval_stmts(v7, a, pos, end, scope, brk); /* LCOV_EXCL_LINE */
        switch (*brk) {                                  /* LCOV_EXCL_LINE */
          case B_RUN:
            break;
          case B_CONTINUE:
            *brk = B_RUN;
            break;
          case B_BREAK:
            *brk = B_RUN; /* fall through */
          case B_RETURN:
            *pos = end;
            goto cleanup;
        }
      }
      *pos = end;
      break;
    }
    case AST_DEFAULT:
      /* handle fallthroughs */
      ast_move_to_children(a, pos);
      break;
    case AST_CASE:
      /* handle fallthroughs */
      ast_move_to_children(a, pos);
      ast_skip_tree(a, pos);
      break;
    case AST_SWITCH: {
      int found = 0;
      val_t test = v7_create_undefined(), val = v7_create_undefined();
      ast_off_t case_end, default_pos = 0;
      enum ast_tag case_tag;
      tmp_stack_push(&tf, &test);
      tmp_stack_push(&tf, &val);

      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      test = i_eval_expr(v7, a, pos, scope);
      while (*pos < end) {
        switch (case_tag = ast_fetch_tag(a, pos)) {
          default:
            throw_exception(v7, INTERNAL_ERROR, /* LCOV_EXCL_LINE */
                            "invalid ast node %d", case_tag);
          case AST_DEFAULT:
            default_pos = *pos;
            *pos = ast_get_skip(a, *pos, AST_END_SKIP);
            break;
          case AST_CASE:
            case_end = ast_get_skip(a, *pos, AST_END_SKIP);
            ast_move_to_children(a, pos);
            val = i_eval_expr(v7, a, pos, scope);
            /* TODO(mkm): factor out equality check from eval_expr */
            if (test != val || val == V7_TAG_NAN) {
              *pos = case_end;
              break;
            }
            res = i_eval_stmts(v7, a, pos, end, scope, brk);
            if (*brk == B_BREAK) {
              *brk = B_RUN;
            }
            *pos = end;
            found = 1;
            break;
        }
      }

      if (!found && default_pos != 0) {
        ast_move_to_children(a, &default_pos);
        res = i_eval_stmts(v7, a, &default_pos, end, scope, brk);
        if (*brk == B_BREAK) {
          *brk = B_RUN;
        }
      }
      break;
    }
    case AST_LABEL: {
      jmp_buf old_jmp;
      char *name;
      size_t name_len;
      ast_off_t saved_pos;
      size_t saved_tmp_stack_pos = v7->tmp_stack.len;
      volatile enum jmp_type j;
      memcpy(old_jmp, v7->jmp_buf, sizeof(old_jmp));
      name = ast_get_inlined_data(a, *pos, &name_len);

      ast_move_to_children(a, pos);
      saved_pos = *pos;
    /*
     * Percolate up all exceptions and labeled breaks
     * not matching the current label.
     */
    cont:
      if ((j = (enum jmp_type) sigsetjmp(v7->jmp_buf, 0)) == 0) {
        res = i_eval_stmt(v7, a, pos, scope, brk);
      } else if ((j == BREAK_JMP || j == CONTINUE_JMP) &&
                 name_len == v7->label_len &&
                 memcmp(name, v7->label, name_len) == 0) {
        v7->tmp_stack.len = saved_tmp_stack_pos;
        *pos = saved_pos;
        if (j == CONTINUE_JMP) {
          v7->lab_cont = 1;
          goto cont;
        }
        ast_skip_tree(a, pos);
      } else {
        siglongjmp(old_jmp, j);
      }
      memcpy(v7->jmp_buf, old_jmp, sizeof(old_jmp));
      break;
    }
    case AST_TRY: {
      volatile int percolate = 0;
      jmp_buf old_jmp;
      char *name;
      size_t name_len;
      size_t saved_tmp_stack_pos = v7->tmp_stack.len;
      volatile enum jmp_type j;

      memcpy(old_jmp, v7->jmp_buf, sizeof(old_jmp));

      end = ast_get_skip(a, *pos, AST_END_SKIP);
      acatch = ast_get_skip(a, *pos, AST_TRY_CATCH_SKIP);
      finally = ast_get_skip(a, *pos, AST_TRY_FINALLY_SKIP);
      ast_move_to_children(a, pos);
      if ((j = (enum jmp_type) sigsetjmp(v7->jmp_buf, 0)) == 0) {
        res = i_eval_stmts(v7, a, pos, acatch, scope, brk);
      } else if (j == THROW_JMP && acatch != finally) {
        val_t catch_scope;
        v7->tmp_stack.len = saved_tmp_stack_pos;
        catch_scope = create_object(v7, scope);
        tmp_stack_push(&tf, &catch_scope);

        tag = ast_fetch_tag(a, &acatch);
        V7_CHECK(v7, tag == AST_IDENT);
        name = ast_get_inlined_data(a, acatch, &name_len);
        v7_set_property(v7, catch_scope, name, name_len, 0, v7->thrown_error);
        ast_move_to_children(a, &acatch);
        memcpy(v7->jmp_buf, old_jmp, sizeof(old_jmp));
        res = i_eval_stmts(v7, a, &acatch, finally, catch_scope, brk);
      } else {
        percolate = 1;
      }

      memcpy(v7->jmp_buf, old_jmp, sizeof(old_jmp));
      if (finally != end) {
        enum i_break fin_brk = B_RUN;
        res = i_eval_stmts(v7, a, &finally, end, scope, &fin_brk);
        if (fin_brk != B_RUN) {
          *brk = fin_brk;
        }
        if (!*brk && percolate) {
          siglongjmp(v7->jmp_buf, j);
        }
      }
      *pos = end;
      break;
    }
    case AST_WITH: {
      val_t with_scope = v7_create_undefined();
      tmp_stack_push(&tf, &with_scope);
      end = ast_get_skip(a, *pos, AST_END_SKIP);
      ast_move_to_children(a, pos);
      /*
       * TODO(mkm) make an actual scope chain. Possibly by mutating
       * the with expression and adding the 'outer environment
       * reference' hidden property.
       */
      with_scope = i_eval_expr(v7, a, pos, scope);
      if (!v7_is_object(with_scope)) {
        throw_exception(v7, INTERNAL_ERROR,
                        "with statement is not really implemented yet");
      }
      i_eval_stmts(v7, a, pos, end, with_scope, brk);
      break;
    }
    case AST_VALUE_RETURN:
      res = i_eval_expr(v7, a, pos, scope);
      *brk = B_RETURN;
      break;
    case AST_RETURN:
      *brk = B_RETURN;
      break;
    case AST_BREAK:
      *brk = B_BREAK;
      break;
    case AST_CONTINUE:
      *brk = B_CONTINUE;
      break;
    case AST_LABELED_BREAK:
      V7_CHECK(v7, ast_fetch_tag(a, pos) == AST_IDENT);
      v7->label = ast_get_inlined_data(a, *pos, &v7->label_len);
      siglongjmp(v7->jmp_buf, BREAK_JMP);
      break; /* unreachable */
    case AST_LABELED_CONTINUE:
      V7_CHECK(v7, ast_fetch_tag(a, pos) == AST_IDENT);
      v7->label = ast_get_inlined_data(a, *pos, &v7->label_len);
      siglongjmp(v7->jmp_buf, CONTINUE_JMP);
      break; /* unreachable */
    case AST_THROW:
      v7->thrown_error = i_eval_expr(v7, a, pos, scope);
      siglongjmp(v7->jmp_buf, THROW_JMP);
      break; /* unreachable */
    default:
      (*pos)--;
      res = i_eval_expr(v7, a, pos, scope);
      break;
  }

cleanup:
  tmp_frame_cleanup(&tf);
  return res;
}

/* Invoke a function applying the argument array */
val_t v7_apply(struct v7 *v7, val_t f, val_t this_object, val_t args) {
  struct v7_function *func;
  ast_off_t pos, body, end;
  enum ast_tag tag;
  val_t frame = v7_create_undefined(), res = v7_create_undefined();
  val_t arguments = v7_create_undefined(), saved_this = v7->this_object;
  char *name;
  size_t name_len;
  int i;

  struct gc_tmp_frame vf = new_tmp_frame(v7);
  tmp_stack_push(&vf, &frame);
  tmp_stack_push(&vf, &res);
  tmp_stack_push(&vf, &arguments);
  tmp_stack_push(&vf, &saved_this);
  /*
   * Since v7_apply can be called from user code
   * we have to treat all arguments as roots.
   */
  tmp_stack_push(&vf, &args);
  tmp_stack_push(&vf, &f);
  tmp_stack_push(&vf, &this_object);

  if (!v7_is_cfunction(f) && !v7_is_function(f)) {
    /* extract the hidden property from a cfunction_object */
    struct v7_property *p;
    p = v7_get_own_property2(v7, f, "", 0, V7_PROPERTY_HIDDEN);
    if (p != NULL) {
      f = p->value;
    }
  }

  if (v7_is_cfunction(f)) {
    res = v7_to_cfunction(f)(v7, this_object, args);
    goto cleanup;
  }
  if (!v7_is_function(f)) {
    throw_exception(v7, TYPE_ERROR, "value is not a function");
  }
  func = v7_to_function(f);
  frame = i_prepare_call(v7, func, &pos, &body, &end);

  /*
   * TODO(mkm): don't create arguments array if the parser didn't see
   * any `arguments` or `eval` identifier being referenced in the function.
   */
  arguments = v7_create_dense_array(v7);

  for (i = 0; pos < body; i++) {
    tag = ast_fetch_tag(func->ast, &pos);
    V7_CHECK(v7, tag == AST_IDENT);
    name = ast_get_inlined_data(func->ast, pos, &name_len);
    ast_move_to_children(func->ast, &pos);
    res = v7_array_get(v7, args, i);
    v7_set_property(v7, frame, name, name_len, 0, res);
    if (!v7_is_undefined(arguments)) {
      v7_array_set(v7, arguments, i, res);
    }
  }

  if (!v7_is_undefined(arguments)) {
#ifndef V7_DISABLE_PREDEFINED_STRINGS
    v7_set_v(v7, frame, v7->predefined_strings[PREDEFINED_STR_ARGUMENTS],
             arguments);
#else
    v7_set(v7, frame, "arguments", 9, 0, arguments);
#endif
  }

  v7->this_object = this_object;
  res = i_invoke_function(v7, func, frame, body, end);
  v7->this_object = saved_this;

cleanup:
  tmp_frame_cleanup(&vf);
  return res;
}

/* like v7_exec_with but frees src if fr is true */

V7_PRIVATE enum v7_err v7_exec_with2(struct v7 *v7, val_t *res, const char *src,
                                     val_t w, int fr) {
  /* TODO(mkm): use GC pool */
  struct ast *a = (struct ast *) malloc(sizeof(struct ast));
  val_t old_this = v7->this_object, saved_call_stack = v7->call_stack;
  enum i_break brk = B_RUN;
  ast_off_t pos = 0;
  jmp_buf saved_jmp_buf, saved_label_buf;
  size_t saved_tmp_stack_pos = v7->tmp_stack.len;
  enum v7_err err = V7_OK;
  val_t r = v7_create_undefined();

  /* Make v7_exec() reentrant: save exception environments */
  memcpy(&saved_jmp_buf, &v7->jmp_buf, sizeof(saved_jmp_buf));
  memcpy(&saved_label_buf, &v7->label_jmp_buf, sizeof(saved_label_buf));

  v7_own(v7, &saved_call_stack);
  v7->call_stack = v7->global_object;

  ast_init(a, 0);
  a->refcnt = 1;
  if (sigsetjmp(v7->jmp_buf, 0) != 0) {
    v7->tmp_stack.len = saved_tmp_stack_pos;
    r = v7->thrown_error;
    /* v7->thrown_error is in the root set, remove it so it doesn't leak */
    v7->thrown_error = v7_create_undefined();
    err = V7_EXEC_EXCEPTION;
    goto cleanup;
  }
  err = parse(v7, a, src, 1);
  if (fr) {
    free((void *) src);
  }

  if (err != V7_OK) {
    /*
     * The actual error might not be syntax error but there is no need to
     * add more overhead to the runtime by creating a specific exception for
     * other parse errors.
     */
    r = create_exception(v7, SYNTAX_ERROR, v7->error_msg);
    goto cleanup;
  }
  ast_optimize(a);
#if V7_ENABLE__Memory__stats
  v7->function_arena_ast_size += a->mbuf.size;
#endif

  v7->this_object = v7_is_undefined(w) ? v7->global_object : w;
  r = i_eval_stmt(v7, a, &pos, v7->call_stack, &brk);

cleanup:
  v7_disown(v7, &saved_call_stack);
  v7->call_stack = saved_call_stack;

  release_ast(v7, a);

  if (res != NULL) {
    *res = r;
  }
  v7->this_object = old_this;
  memcpy(&v7->jmp_buf, &saved_jmp_buf, sizeof(saved_jmp_buf));
  memcpy(&v7->label_jmp_buf, &saved_label_buf, sizeof(saved_label_buf));

  return err;
}

enum v7_err v7_exec_with(struct v7 *v7, val_t *res, const char *src, val_t w) {
  return v7_exec_with2(v7, res, src, w, 0);
}

void v7_interrupt(struct v7 *v7) {
  v7->interrupt = 1;
}

enum v7_err v7_exec(struct v7 *v7, val_t *res, const char *src) {
  return v7_exec_with(v7, res, src, V7_UNDEFINED);
}

#ifndef NO_LIBC
/*
 * Note: this function is intended only for v7_exec_file
 * It is move file pointer to the end of file
 */
static int v7_get_file_size(c_file_t fp) {
  int res = -1;
  if (c_fseek(fp, 0, SEEK_END) == 0) {
    res = c_ftell(fp);
  }

  return res;
}
#endif

#ifndef V7_NO_FS
enum v7_err v7_exec_file(struct v7 *v7, val_t *res, const char *path) {
  c_file_t fp;
  char *p;
  long file_size;
  enum v7_err err = V7_EXEC_EXCEPTION;
  *res = v7_create_undefined();

  if ((fp = c_fopen(path, "r")) == INVALID_FILE) {
    snprintf(v7->error_msg, sizeof(v7->error_msg), "cannot open file [%s]",
             path);
    *res = create_exception(v7, SYNTAX_ERROR, v7->error_msg);
  } else if ((file_size = v7_get_file_size(fp)) <= 0) {
    snprintf(v7->error_msg, sizeof(v7->error_msg), "fseek(%s): %s", path,
             strerror(errno));
    *res = create_exception(v7, SYNTAX_ERROR, v7->error_msg);
    c_fclose(fp);
  } else if ((p = (char *) calloc(1, (size_t) file_size + 1)) == NULL) {
    snprintf(v7->error_msg, sizeof(v7->error_msg), "cannot allocate %ld bytes",
             file_size + 1);
    c_fclose(fp);
  } else {
    c_rewind(fp);
    if ((c_fread(p, 1, (size_t) file_size, fp) < (size_t) file_size) &&
        c_ferror(fp)) {
      c_fclose(fp);
      return err;
    }
    c_fclose(fp);
    /* v7_exec_with2 will free sources after parse */
    err = v7_exec_with2(v7, res, p, V7_UNDEFINED, 1);
  }

  return err;
}
#endif
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#ifdef V7_ENABLE_BCODE

#define PUSH(v) (v7->stack[v7->sp++] = (v))
#define POP() (v7->stack[--v7->sp])
#define TOS() (v7->stack[v7->sp - 1])

static double b_int_bin_op(struct v7 *v7, enum opcode op, double a, double b) {
  int32_t ia = isnan(a) || isinf(a) ? 0 : (int32_t)(int64_t) a;
  int32_t ib = isnan(b) || isinf(b) ? 0 : (int32_t)(int64_t) b;

  switch (op) {
    case OP_LSHIFT:
      return (int32_t)((uint32_t) ia << ((uint32_t) ib & 31));
    case OP_RSHIFT:
      return ia >> ((uint32_t) ib & 31);
    case OP_URSHIFT:
      return (uint32_t) ia >> ((uint32_t) ib & 31);
    case OP_OR:
      return ia | ib;
    case OP_XOR:
      return ia ^ ib;
    case OP_AND:
      return ia & ib;
    default:
      throw_exception(v7, INTERNAL_ERROR, "%s", __func__); /* LCOV_EXCL_LINE */
      return 0;                                            /* LCOV_EXCL_LINE */
  }
}

static double b_num_bin_op(struct v7 *v7, enum opcode op, double a, double b) {
  switch (op) {
    case OP_ADD: /* simple fixed width nodes with no payload */
      return a + b;
    case OP_SUB:
      return a - b;
    case OP_REM:
      if (b == 0 || isnan(b) || isnan(a) || isinf(b) || isinf(a)) {
        return NAN;
      }
      return (int) a % (int) b;
    case OP_MUL:
      return a * b;
    case OP_DIV:
      if (b == 0) {
        if (a == 0) return NAN;
        return (!signbit(a) == !signbit(b)) ? INFINITY : -INFINITY;
      }
      return a / b;
    case OP_LSHIFT:
    case OP_RSHIFT:
    case OP_URSHIFT:
    case OP_OR:
    case OP_XOR:
    case OP_AND:
      return b_int_bin_op(v7, op, a, b);
    default:
      throw_exception(v7, INTERNAL_ERROR, "%s", __func__); /* LCOV_EXCL_LINE */
      return 0;                                            /* LCOV_EXCL_LINE */
  }
}

static int b_bool_bin_op(struct v7 *v7, enum opcode op, double a, double b) {
#ifdef V7_BROKEN_NAN
  if (isnan(a) || isnan(b)) return op == OP_NE || op == OP_NE_NE;
#endif

  switch (op) {
    case OP_EQ:
    case OP_EQ_EQ:
      return a == b;
    case OP_NE:
    case OP_NE_NE:
      return a != b;
    case OP_LT:
      return a < b;
    case OP_LE:
      return a <= b;
    case OP_GT:
      return a > b;
    case OP_GE:
      return a >= b;
    default:
      throw_exception(v7, INTERNAL_ERROR, "%s", __func__); /* LCOV_EXCL_LINE */
      return 0;                                            /* LCOV_EXCL_LINE */
  }
}

V7_PRIVATE void eval_bcode(struct v7 *v7, struct bcode *bcode) {
  uint8_t *ops = bcode->ops;
  uint8_t *end = ops + bcode->ops_len;

  char buf[512];

  val_t res, v1, v2, v3;
  (void) res;

  while (ops != end) {
    enum opcode op = (enum opcode) * ops;
    switch (op) {
      case OP_PUSH_ZERO:
        PUSH(v7_create_number(0));
        break;
      case OP_PUSH_ONE:
        PUSH(v7_create_number(1));
        break;
      case OP_PUSH_LIT: {
        int arg = (int) *(++ops);
        PUSH(bcode->lit[arg]);
        break;
      }
      case OP_ADD: /* TODO: JS add is different! */
      case OP_SUB:
      case OP_REM:
      case OP_MUL:
      case OP_DIV:
      case OP_LSHIFT:
      case OP_RSHIFT:
      case OP_URSHIFT:
      case OP_OR:
      case OP_XOR:
      case OP_AND: {
        double d1, d2;
        v2 = POP();
        v1 = POP();
        d1 = i_as_num(v7, v1);
        d2 = i_as_num(v7, v2);
        PUSH(v7_create_number(b_num_bin_op(v7, op, d1, d2)));
        break;
      }
      case OP_EQ_EQ:
      case OP_EQ:
      case OP_NE:
      case OP_NE_NE:
      case OP_LT:
      case OP_LE:
      case OP_GT:
      case OP_GE: {
        double d1, d2;
        v2 = POP();
        v1 = POP();
        d1 = i_as_num(v7, v1);
        d2 = i_as_num(v7, v2);
        PUSH(v7_create_boolean(b_bool_bin_op(v7, op, d1, d2)));
        break;
      }
      case OP_GET:
        v2 = POP();
        v1 = POP();
        PUSH(v7_get_v(v7, v1, v2));
        break;
      case OP_SET:
        v3 = POP();
        v2 = POP();
        v1 = POP();
        v7_set_v(v7, v1, v2, v3);
        PUSH(v3);
        break;
      case OP_GET_VAR: {
        int arg = (int) *(++ops);
        PUSH(v7_get_v(v7, v7->call_stack, bcode->lit[arg]));
        break;
      }
      case OP_SET_VAR: {
        struct v7_property *prop;
        int arg = (int) *(++ops);
        v3 = POP();
        v2 = bcode->lit[arg];
        v1 = v7->call_stack;

        v7_stringify_value(v7, v2, buf, sizeof(buf));
        prop = v7_get_property(v7, v1, buf, strlen(buf));
        if (prop != NULL) {
          prop->value = v3;
        } else {
          v7_set_v(v7, v7_get_global_object(v7), v2, v3);
        }
        PUSH(v3);
        break;
      }
    }
    ops++;
  }
}

#endif /* V7_ENABLE_BCODE */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#ifdef NO_LIBC
void print_str(const char *str);
#endif

V7_PRIVATE v7_val_t Std_print(struct v7 *v7, v7_val_t this_obj, v7_val_t args) {
  int i, num_args = v7_array_length(v7, args);

  (void) this_obj;
  for (i = 0; i < num_args; i++) {
    v7_print(v7, v7_array_get(v7, args, i));
    printf(" ");
  }
  printf(ENDL);

  return v7_create_undefined();
}

V7_PRIVATE v7_val_t
_std_eval(struct v7 *v7, v7_val_t args, char before, char after) {
  enum v7_err err;
  v7_val_t res = v7_create_undefined(), arg = v7_array_get(v7, args, 0);

  if (arg != V7_UNDEFINED) {
    char buf[100], *p;
    p = v7_to_json(v7, arg, buf, sizeof(buf));
    if (p[0] == '"') {
      p[0] = before;
      p[strlen(p) - 1] = after;
    }
    err = v7_exec(v7, &res, p);

    if (p != buf) free(p);
    if (err != V7_OK) v7_throw_value(v7, res);
  }
  return res;
}

V7_PRIVATE v7_val_t Std_eval(struct v7 *v7, v7_val_t t, v7_val_t args) {
  (void) t;
  return _std_eval(v7, args, ' ', ' ');
}

V7_PRIVATE v7_val_t Std_parseInt(struct v7 *v7, v7_val_t t, v7_val_t args) {
  v7_val_t arg0 = i_value_of(v7, v7_array_get(v7, args, 0));
  v7_val_t arg1 = i_value_of(v7, v7_array_get(v7, args, 1));
  long sign = 1, base = v7_is_undefined(arg1) ? 0 : to_long(v7, arg1, 0), n;
  char buf[20], *p = buf, *end;

  (void) t;

  if (base == 0) {
    base = 10;
  }

  if (base < 2 || base > 36) {
    return V7_TAG_NAN;
  }

  if (v7_is_string(arg0)) {
    size_t str_len;
    p = (char *) v7_to_string(v7, &arg0, &str_len);
  } else {
    to_str(v7, arg0, buf, sizeof(buf), 0);
    buf[sizeof(buf) - 1] = '\0';
  }

  /* Strip leading whitespaces */
  while (*p != '\0' && isspace(*(unsigned char *) p)) {
    p++;
  }

  if (*p == '+') {
    sign = 1;
    p++;
  } else if (*p == '-') {
    sign = -1;
    p++;
  }

  if (p[0] == '0' && (p[1] == 'x' || p[1] == 'X')) {
    base = 16;
    p += 2;
  }

  n = strtol(p, &end, base);

  return p == end ? V7_TAG_NAN : v7_create_number(n * sign);
}

V7_PRIVATE v7_val_t Std_parseFloat(struct v7 *v7, v7_val_t t, v7_val_t args) {
  v7_val_t arg0 = i_value_of(v7, v7_array_get(v7, args, 0));
  char buf[20], *p = buf, *end;
  double result;

  (void) t;

  if (v7_is_string(arg0)) {
    size_t str_len;
    p = (char *) v7_to_string(v7, &arg0, &str_len);
  } else {
    to_str(v7, arg0, buf, sizeof(buf), 0);
    buf[sizeof(buf) - 1] = '\0';
  }

  while (*p != '\0' && isspace(*(unsigned char *) p)) {
    p++;
  }

  result = strtod(p, &end);

  return p == end ? V7_TAG_NAN : v7_create_number(result);
}

V7_PRIVATE v7_val_t Std_isNaN(struct v7 *v7, v7_val_t t, v7_val_t args) {
  v7_val_t arg0 = i_value_of(v7, v7_array_get(v7, args, 0));
  (void) t;
  return v7_create_boolean(arg0 == V7_TAG_NAN);
}

V7_PRIVATE v7_val_t Std_isFinite(struct v7 *v7, v7_val_t t, v7_val_t args) {
  v7_val_t arg0 = i_value_of(v7, v7_array_get(v7, args, 0));
  (void) t;
  return v7_create_boolean(v7_is_number(arg0) && arg0 != V7_TAG_NAN &&
                           !isinf(v7_to_number(arg0)));
}

#ifndef NO_LIBC
static v7_val_t Std_exit(struct v7 *v7, v7_val_t t, v7_val_t args) {
  int exit_code = arg_long(v7, args, 0, 0);
  (void) t;
  exit(exit_code);
  return v7_create_undefined();
}
#endif

V7_PRIVATE void init_stdlib(struct v7 *v7) {
  /*
   * Ensure the first call to v7_create_value will use a null proto:
   * {}.__proto__.__proto__ == null
   */
  v7->object_prototype = create_object(v7, V7_NULL);
  v7->array_prototype = v7_create_object(v7);
  v7->boolean_prototype = v7_create_object(v7);
  v7->string_prototype = v7_create_object(v7);
  v7->regexp_prototype = v7_create_object(v7);
  v7->number_prototype = v7_create_object(v7);
  v7->error_prototype = v7_create_object(v7);
  v7->global_object = v7_create_object(v7);
  v7->this_object = v7->global_object;
  v7->date_prototype = v7_create_object(v7);
  v7->function_prototype = v7_create_object(v7);

  set_method(v7, v7->global_object, "eval", Std_eval, 1);
  set_method(v7, v7->global_object, "print", Std_print, 1);
#ifndef NO_LIBC
  set_method(v7, v7->global_object, "exit", Std_exit, 1);
#endif
  set_method(v7, v7->global_object, "parseInt", Std_parseInt, 2);
  set_method(v7, v7->global_object, "parseFloat", Std_parseFloat, 1);
  set_method(v7, v7->global_object, "isNaN", Std_isNaN, 1);
  set_method(v7, v7->global_object, "isFinite", Std_isFinite, 1);

  v7_set_property(v7, v7->global_object, "Infinity", 8, 0,
                  v7_create_number(INFINITY));
  v7_set_property(v7, v7->global_object, "global", 6, 0, v7->global_object);

  init_object(v7);
  init_array(v7);
  init_error(v7);
  init_boolean(v7);
#if V7_ENABLE__Math
  init_math(v7);
#endif
  init_string(v7);
#if V7_ENABLE__RegExp
  init_regex(v7);
#endif
  init_number(v7);
  init_json(v7);
#if V7_ENABLE__Date
  init_date(v7);
#endif
  init_function(v7);
  init_js_stdlib(v7);
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#define STRINGIFY(x) #x

static const char js_array_indexOf[] = STRINGIFY(
    Array.prototype.indexOf = function(a, x) {
      var i; var r = -1; var b = +x;
      if (!b || b < 0) b = 0;
      for (i in this) if (i >= b && (r < 0 || i < r) && this[i] === a) r = +i;
      return r;
    };);

static const char js_array_lastIndexOf[] = STRINGIFY(
    Array.prototype.lastIndexOf = function(a, x) {
      var i; var r = -1; var b = +x;
      if (isNaN(b) || b < 0 || b >= this.length) b = this.length - 1;
      for (i in this) if (i <= b && (r < 0 || i > r) && this[i] === a) r = +i;
      return r;
    };);

#if V7_ENABLE__Array__reduce
static const char js_array_reduce[] = STRINGIFY(
    Array.prototype.reduce = function(a, b) {
      var f = 0;
      if (typeof(a) != "function") {
        throw new TypeError(a + " is not a function");
      }
      for (var k in this) {
        if (f == 0 && b === undefined) {
          b = this[k];
          f = 1;
        } else {
          b = a(b, this[k], k, this);
        }
      }
      return b;
    };);
#endif

static const char js_array_pop[] = STRINGIFY(
    Array.prototype.pop = function() {
      var i = this.length - 1;
      return this.splice(i, 1)[0];
    };);

static const char js_array_shift[] = STRINGIFY(
    Array.prototype.shift = function() {
      return this.splice(0, 1)[0];
    };);

#if V7_ENABLE__Function__call
static const char js_function_call[] = STRINGIFY(
    Function.prototype.call = function() {
      var t = arguments.splice(0, 1)[0];
      return this.apply(t, arguments);
    };);
#endif

static const char * const js_functions[] = {
#if V7_ENABLE__Function__call
  js_function_call,
#endif
#if V7_ENABLE__Array__reduce
  js_array_reduce,
#endif
  js_array_indexOf,
  js_array_lastIndexOf,
  js_array_pop,
  js_array_shift
};

#define CEIL(x, y) ((x) / (y) + ((x) % (y) > 0))

 V7_PRIVATE void init_js_stdlib(struct v7 *v7) {
  val_t res;
  int i;

  for(i = 0; i < (int) ARRAY_SIZE(js_functions); i++) {
    v7_exec(v7, &res, js_functions[i]);
  }

  /* TODO(lsm): re-enable in a separate PR */
#if 0
  v7_exec(v7, &res, STRINGIFY(
    Array.prototype.unshift = function() {
      var a = new Array(0, 0);
      Array.prototype.push.apply(a, arguments);
      Array.prototype.splice.apply(this, a);
      return this.length;
    };));
#endif
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 *
 * This software is dual-licensed: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation. For the terms of this
 * license, see <http://www.gnu.org/licenses/>.
 *
 * You are free to use this software under the terms of the GNU General
 * Public License, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * Alternatively, you can license this software under a commercial
 * license, as set out in <http://cesanta.com/>.
 */


#include <setjmp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef NO_LIBC
#include <ctype.h>
#endif


/* Limitations */
#define SLRE_MAX_RANGES 32
#define SLRE_MAX_SETS 16
#define SLRE_MAX_REP 0xFFFF

#define SLRE_MALLOC malloc
#define SLRE_FREE free
#define SLRE_THROW(e, err_code) longjmp((e)->jmp_buf, (err_code))

static int hex(int c) {
  if (c >= '0' && c <= '9') return c - '0';
  if (c >= 'a' && c <= 'f') return c - 'a' + 10;
  if (c >= 'A' && c <= 'F') return c - 'A' + 10;
  return -SLRE_INVALID_HEX_DIGIT;
}

int nextesc(const char **p) {
  const unsigned char *s = (unsigned char *) (*p)++;
  switch (*s) {
    case 0:
      return -SLRE_UNTERM_ESC_SEQ;
    case 'c':
      ++*p;
      return *s & 31;
    case 'f':
      return '\f';
    case 'n':
      return '\n';
    case 'r':
      return '\r';
    case 't':
      return '\t';
    case 'v':
      return '\v';
    case '\\':
      return '\\';
    case 'u':
      if (isxdigit(s[1]) && isxdigit(s[2]) && isxdigit(s[3]) &&
          isxdigit(s[4])) {
        (*p) += 4;
        return hex(s[1]) << 12 | hex(s[2]) << 8 | hex(s[3]) << 4 | hex(s[4]);
      }
      return -SLRE_INVALID_HEX_DIGIT;
    case 'x':
      if (isxdigit(s[1]) && isxdigit(s[2])) {
        (*p) += 2;
        return (hex(s[1]) << 4) | hex(s[2]);
      }
      return -SLRE_INVALID_HEX_DIGIT;
    default:
      return -SLRE_INVALID_ESC_CHAR;
  }
}

#if V7_ENABLE__RegExp

/* Parser Information */
struct slre_node {
  unsigned char type;
  union {
    Rune c;                /* character */
    struct slre_class *cp; /* class pointer */
    struct {
      struct slre_node *x;
      union {
        struct slre_node *y;
        unsigned char n;
        struct {
          unsigned char ng; /* not greedy flag */
          unsigned short min;
          unsigned short max;
        } rp;
      } y;
    } xy;
  } par;
};

struct slre_range {
  unsigned short s, e;
};

/* character class, each pair of rune's defines a range */
struct slre_class {
  struct slre_range *end;
  struct slre_range spans[SLRE_MAX_RANGES];
};

struct slre_instruction {
  unsigned char opcode;
  union {
    unsigned char n;
    Rune c;                /* character */
    struct slre_class *cp; /* class pointer */
    struct {
      struct slre_instruction *x;
      union {
        struct {
          unsigned short min;
          unsigned short max;
        } rp;
        struct slre_instruction *y;
      } y;
    } xy;
  } par;
};

struct slre_prog {
  struct slre_instruction *start, *end;
  unsigned int num_captures;
  int flags;
  struct slre_class charset[SLRE_MAX_SETS];
};

struct slre_env {
  int is_regex;
  const char *src;
  const char *src_end;
  Rune curr_rune;

  struct slre_prog *prog;
  struct slre_node *pstart, *pend;

  struct slre_node *caps[SLRE_MAX_CAPS];
  unsigned int num_captures;
  unsigned int sets_num;

  int lookahead;
  struct slre_class *curr_set;
  int min_rep, max_rep;

#if defined(__cplusplus)
  ::jmp_buf jmp_buf;
#else
  jmp_buf jmp_buf;
#endif
};

struct slre_thread {
  struct slre_thread *prev;
  struct slre_instruction *pc;
  const char *start;
  struct slre_loot loot;
};

enum slre_opcode {
  I_END = 10, /* Terminate: match found */
  I_ANY,
  P_ANY = I_ANY, /* Any character except newline, . */
  I_ANYNL,       /* Any character including newline, . */
  I_BOL,
  P_BOL = I_BOL, /* Beginning of line, ^ */
  I_CH,
  P_CH = I_CH,
  I_EOL,
  P_EOL = I_EOL, /* End of line, $ */
  I_EOS,
  P_EOS = I_EOS, /* End of string, \0 */
  I_JUMP,
  I_LA,
  P_LA = I_LA,
  I_LA_N,
  P_LA_N = I_LA_N,
  I_LBRA,
  P_BRA = I_LBRA, /* Left bracket, ( */
  I_REF,
  P_REF = I_REF,
  I_REP,
  P_REP = I_REP,
  I_REP_INI,
  I_RBRA, /* Right bracket, ) */
  I_SET,
  P_SET = I_SET, /* Character set, [] */
  I_SET_N,
  P_SET_N = I_SET_N, /* Negated character set, [] */
  I_SPLIT,
  I_WORD,
  P_WORD = I_WORD,
  I_WORD_N,
  P_WORD_N = I_WORD_N,
  P_ALT, /* Alternation, | */
  P_CAT, /* Concatentation, implicit operator */
  L_CH = 256,
  L_COUNT,  /* {M,N} */
  L_EOS,    /* End of string, \0 */
  L_LA,     /* "(?=" lookahead */
  L_LA_CAP, /* "(?:" lookahead, capture */
  L_LA_N,   /* "(?!" negative lookahead */
  L_REF,    /* "\1" back-reference */
  L_CHSET,  /* character set */
  L_SET_N,  /* negative character set */
  L_WORD,   /* "\b" word boundary */
  L_WORD_N  /* "\B" non-word boundary */
};

static signed char dec(int c) {
  if (isdigitrune(c)) return c - '0';
  return SLRE_INVALID_DEC_DIGIT;
}

static unsigned char re_dec_digit(struct slre_env *e, int c) {
  signed char ret = dec(c);
  if (ret < 0) {
    SLRE_THROW(e, SLRE_INVALID_DEC_DIGIT);
  }
  return ret;
}

static int re_nextc(Rune *r, const char **src, const char *src_end) {
  *r = 0;
  if (*src >= src_end) return 0;
  *src += chartorune(r, *src);
  if (*r == '\\') {
    const char *tmp_s = *src;
    int i = nextesc(src);
    switch (i) {
      case -SLRE_INVALID_ESC_CHAR:
        *r = '\\';
        *src = tmp_s;
        *src += chartorune(r, *src);
        break;
      case -SLRE_INVALID_HEX_DIGIT:
      default:
        *r = i;
    }
    return 1;
  }
  return 0;
}

static int re_nextc_env(struct slre_env *e) {
  return re_nextc(&e->curr_rune, &e->src, e->src_end);
}

static void re_nchset(struct slre_env *e) {
  if (e->sets_num >= nelem(e->prog->charset)) {
    SLRE_THROW(e, SLRE_TOO_MANY_CHARSETS);
  }
  e->curr_set = e->prog->charset + e->sets_num++;
  e->curr_set->end = e->curr_set->spans;
}

static void re_rng2set(struct slre_env *e, Rune start, Rune end) {
  if (start > end) {
    SLRE_THROW(e, SLRE_INV_CHARSET_RANGE);
  }
  if (e->curr_set->end + 2 == e->curr_set->spans + nelem(e->curr_set->spans)) {
    SLRE_THROW(e, SLRE_CHARSET_TOO_LARGE);
  }
  e->curr_set->end->s = start;
  e->curr_set->end->e = end;
  e->curr_set->end++;
}

#define re_char2set(e, c) re_rng2set(e, c, c)

#define re_d_2set(e) re_rng2set(e, '0', '9')

static void re_D_2set(struct slre_env *e) {
  re_rng2set(e, 0, '0' - 1);
  re_rng2set(e, '9' + 1, 0xFFFF);
}

static void re_s_2set(struct slre_env *e) {
  re_char2set(e, 0x9);
  re_rng2set(e, 0xA, 0xD);
  re_char2set(e, 0x20);
  re_char2set(e, 0xA0);
  re_rng2set(e, 0x2028, 0x2029);
  re_char2set(e, 0xFEFF);
}

static void re_S_2set(struct slre_env *e) {
  re_rng2set(e, 0, 0x9 - 1);
  re_rng2set(e, 0xD + 1, 0x20 - 1);
  re_rng2set(e, 0x20 + 1, 0xA0 - 1);
  re_rng2set(e, 0xA0 + 1, 0x2028 - 1);
  re_rng2set(e, 0x2029 + 1, 0xFEFF - 1);
  re_rng2set(e, 0xFEFF + 1, 0xFFFF);
}

static void re_w_2set(struct slre_env *e) {
  re_d_2set(e);
  re_rng2set(e, 'A', 'Z');
  re_char2set(e, '_');
  re_rng2set(e, 'a', 'z');
}

static void re_W_2set(struct slre_env *e) {
  re_rng2set(e, 0, '0' - 1);
  re_rng2set(e, '9' + 1, 'A' - 1);
  re_rng2set(e, 'Z' + 1, '_' - 1);
  re_rng2set(e, '_' + 1, 'a' - 1);
  re_rng2set(e, 'z' + 1, 0xFFFF);
}

static unsigned char re_endofcount(Rune c) {
  switch (c) {
    case ',':
    case '}':
      return 1;
  }
  return 0;
}

static void re_ex_num_overfl(struct slre_env *e) {
  SLRE_THROW(e, SLRE_NUM_OVERFLOW);
}

static enum slre_opcode re_countrep(struct slre_env *e) {
  e->min_rep = 0;
  while (e->src < e->src_end && !re_endofcount(e->curr_rune = *e->src++)) {
    e->min_rep = e->min_rep * 10 + re_dec_digit(e, e->curr_rune);
    if (e->min_rep >= SLRE_MAX_REP) re_ex_num_overfl(e);
  }

  if (e->curr_rune != ',') {
    e->max_rep = e->min_rep;
    return L_COUNT;
  }
  e->max_rep = 0;
  while (e->src < e->src_end && (e->curr_rune = *e->src++) != '}') {
    e->max_rep = e->max_rep * 10 + re_dec_digit(e, e->curr_rune);
    if (e->max_rep >= SLRE_MAX_REP) re_ex_num_overfl(e);
  }
  if (!e->max_rep) {
    e->max_rep = SLRE_MAX_REP;
    return L_COUNT;
  }

  return L_COUNT;
}

static enum slre_opcode re_lexset(struct slre_env *e) {
  Rune ch = 0;
  unsigned char esc, ch_fl = 0, dash_fl = 0;
  enum slre_opcode type = L_CHSET;

  re_nchset(e);

  esc = re_nextc_env(e);
  if (!esc && e->curr_rune == '^') {
    type = L_SET_N;
    esc = re_nextc_env(e);
  }

  for (; esc || e->curr_rune != ']'; esc = re_nextc_env(e)) {
    if (!e->curr_rune) {
      SLRE_THROW(e, SLRE_MALFORMED_CHARSET);
    }
    if (esc) {
      if (strchr("DdSsWw", e->curr_rune)) {
        if (ch_fl) {
          re_char2set(e, ch);
          if (dash_fl) re_char2set(e, '-');
        }
        switch (e->curr_rune) {
          case 'D':
            re_D_2set(e);
            break;
          case 'd':
            re_d_2set(e);
            break;
          case 'S':
            re_S_2set(e);
            break;
          case 's':
            re_s_2set(e);
            break;
          case 'W':
            re_W_2set(e);
            break;
          case 'w':
            re_w_2set(e);
            break;
        }
        ch_fl = dash_fl = 0;
        continue;
      }
      switch (e->curr_rune) {
        default:
          /* case '-':
          case '\\':
          case '.':
          case '/':
          case ']':
          case '|': */
          break;
        case '0':
          e->curr_rune = 0;
          break;
        case 'b':
          e->curr_rune = '\b';
          break;
          /* default:
            SLRE_THROW(e->catch_point, e->err_msg,
            SLRE_INVALID_ESC_CHAR); */
      }
    } else {
      if (e->curr_rune == '-') {
        if (ch_fl) {
          if (dash_fl) {
            re_rng2set(e, ch, '-');
            ch_fl = dash_fl = 0;
          } else
            dash_fl = 1;
        } else {
          ch = '-';
          ch_fl = 1;
        }
        continue;
      }
    }
    if (ch_fl) {
      if (dash_fl) {
        re_rng2set(e, ch, e->curr_rune);
        ch_fl = dash_fl = 0;
      } else {
        re_char2set(e, ch);
        ch = e->curr_rune;
      }
    } else {
      ch = e->curr_rune;
      ch_fl = 1;
    }
  }
  if (ch_fl) {
    re_char2set(e, ch);
    if (dash_fl) re_char2set(e, '-');
  }
  return type;
}

static int re_lexer(struct slre_env *e) {
  if (re_nextc_env(e)) {
    switch (e->curr_rune) {
      case '0':
        e->curr_rune = 0;
        return L_EOS;
      case 'b':
        return L_WORD;
      case 'B':
        return L_WORD_N;
      case 'd':
        re_nchset(e);
        re_d_2set(e);
        return L_CHSET;
      case 'D':
        re_nchset(e);
        re_d_2set(e);
        return L_SET_N;
      case 's':
        re_nchset(e);
        re_s_2set(e);
        return L_CHSET;
      case 'S':
        re_nchset(e);
        re_s_2set(e);
        return L_SET_N;
      case 'w':
        re_nchset(e);
        re_w_2set(e);
        return L_CHSET;
      case 'W':
        re_nchset(e);
        re_w_2set(e);
        return L_SET_N;
    }
    if (isdigitrune(e->curr_rune)) {
      e->curr_rune -= '0';
      if (isdigitrune(*e->src))
        e->curr_rune = e->curr_rune * 10 + *e->src++ - '0';
      return L_REF;
    }
    return L_CH;
  }

  if (e->is_regex) {
    switch (e->curr_rune) {
      case 0:
        return 0;
      case '$':
      case ')':
      case '*':
      case '+':
      case '.':
      case '?':
      case '^':
      case '|':
        return e->curr_rune;
      case '{':
        return re_countrep(e);
      case '[':
        return re_lexset(e);
      case '(':
        if (e->src[0] == '?') switch (e->src[1]) {
            case '=':
              e->src += 2;
              return L_LA;
            case ':':
              e->src += 2;
              return L_LA_CAP;
            case '!':
              e->src += 2;
              return L_LA_N;
          }
        return '(';
    }
  } else if (e->curr_rune == 0) {
    return 0;
  }

  return L_CH;
}

#define RE_NEXT(env) (env)->lookahead = re_lexer(env)
#define RE_ACCEPT(env, t) ((env)->lookahead == (t) ? RE_NEXT(env), 1 : 0)

static struct slre_node *re_nnode(struct slre_env *e, int type) {
  memset(e->pend, 0, sizeof(struct slre_node));
  e->pend->type = type;
  return e->pend++;
}

static unsigned char re_isemptynd(struct slre_node *nd) {
  if (!nd) return 1;
  switch (nd->type) {
    default:
      return 1;
    case P_ANY:
    case P_CH:
    case P_SET:
    case P_SET_N:
      return 0;
    case P_BRA:
    case P_REF:
      return re_isemptynd(nd->par.xy.x);
    case P_CAT:
      return re_isemptynd(nd->par.xy.x) && re_isemptynd(nd->par.xy.y.y);
    case P_ALT:
      return re_isemptynd(nd->par.xy.x) || re_isemptynd(nd->par.xy.y.y);
    case P_REP:
      return re_isemptynd(nd->par.xy.x) || !nd->par.xy.y.rp.min;
  }
}

static struct slre_node *re_nrep(struct slre_env *e, struct slre_node *nd,
                                 int ng, unsigned short min,
                                 unsigned short max) {
  struct slre_node *rep = re_nnode(e, P_REP);
  if (max == SLRE_MAX_REP && re_isemptynd(nd)) {
    SLRE_THROW(e, SLRE_INF_LOOP_M_EMP_STR);
  }
  rep->par.xy.y.rp.ng = ng;
  rep->par.xy.y.rp.min = min;
  rep->par.xy.y.rp.max = max;
  rep->par.xy.x = nd;
  return rep;
}

static struct slre_node *re_parser(struct slre_env *e);

static struct slre_node *re_parse_la(struct slre_env *e) {
  struct slre_node *nd;
  int min, max;
  switch (e->lookahead) {
    case '^':
      RE_NEXT(e);
      return re_nnode(e, P_BOL);
    case '$':
      RE_NEXT(e);
      return re_nnode(e, P_EOL);
    case L_EOS:
      RE_NEXT(e);
      return re_nnode(e, P_EOS);
    case L_WORD:
      RE_NEXT(e);
      return re_nnode(e, P_WORD);
    case L_WORD_N:
      RE_NEXT(e);
      return re_nnode(e, P_WORD_N);
  }

  switch (e->lookahead) {
    case L_CH:
      nd = re_nnode(e, P_CH);
      nd->par.c = e->curr_rune;
      RE_NEXT(e);
      break;
    case L_CHSET:
      nd = re_nnode(e, P_SET);
      nd->par.cp = e->curr_set;
      RE_NEXT(e);
      break;
    case L_SET_N:
      nd = re_nnode(e, P_SET_N);
      nd->par.cp = e->curr_set;
      RE_NEXT(e);
      break;
    case L_REF:
      nd = re_nnode(e, P_REF);
      if (!e->curr_rune || e->curr_rune > e->num_captures ||
          !e->caps[e->curr_rune]) {
        SLRE_THROW(e, SLRE_INVALID_BACK_REFERENCE);
      }
      nd->par.xy.y.n = e->curr_rune;
      nd->par.xy.x = e->caps[e->curr_rune];
      RE_NEXT(e);
      break;
    case '.':
      RE_NEXT(e);
      nd = re_nnode(e, P_ANY);
      break;
    case '(':
      RE_NEXT(e);
      nd = re_nnode(e, P_BRA);
      if (e->num_captures == SLRE_MAX_CAPS) {
        SLRE_THROW(e, SLRE_TOO_MANY_CAPTURES);
      }
      nd->par.xy.y.n = e->num_captures++;
      nd->par.xy.x = re_parser(e);
      e->caps[nd->par.xy.y.n] = nd;
      if (!RE_ACCEPT(e, ')')) {
        SLRE_THROW(e, SLRE_UNMATCH_LBR);
      }
      break;
    case L_LA:
      RE_NEXT(e);
      nd = re_nnode(e, P_LA);
      nd->par.xy.x = re_parser(e);
      if (!RE_ACCEPT(e, ')')) {
        SLRE_THROW(e, SLRE_UNMATCH_LBR);
      }
      break;
    case L_LA_CAP:
      RE_NEXT(e);
      nd = re_parser(e);
      if (!RE_ACCEPT(e, ')')) {
        SLRE_THROW(e, SLRE_UNMATCH_LBR);
      }
      break;
    case L_LA_N:
      RE_NEXT(e);
      nd = re_nnode(e, P_LA_N);
      nd->par.xy.x = re_parser(e);
      if (!RE_ACCEPT(e, ')')) {
        SLRE_THROW(e, SLRE_UNMATCH_LBR);
      }
      break;
    default:
      SLRE_THROW(e, SLRE_SYNTAX_ERROR);
  }

  switch (e->lookahead) {
    case '*':
      RE_NEXT(e);
      return re_nrep(e, nd, RE_ACCEPT(e, '?'), 0, SLRE_MAX_REP);
    case '+':
      RE_NEXT(e);
      return re_nrep(e, nd, RE_ACCEPT(e, '?'), 1, SLRE_MAX_REP);
    case '?':
      RE_NEXT(e);
      return re_nrep(e, nd, RE_ACCEPT(e, '?'), 0, 1);
    case L_COUNT:
      min = e->min_rep, max = e->max_rep;
      RE_NEXT(e);
      if (max < min) {
        SLRE_THROW(e, SLRE_INVALID_QUANTIFIER);
      }
      return re_nrep(e, nd, RE_ACCEPT(e, '?'), min, max);
  }
  return nd;
}

static unsigned char re_endofcat(Rune c, int is_regex) {
  switch (c) {
    case 0:
      return 1;
    case '|':
    case ')':
      if (is_regex) return 1;
  }
  return 0;
}

static struct slre_node *re_parser(struct slre_env *e) {
  struct slre_node *alt = NULL, *cat, *nd;
  if (!re_endofcat(e->lookahead, e->is_regex)) {
    cat = re_parse_la(e);
    while (!re_endofcat(e->lookahead, e->is_regex)) {
      nd = cat;
      cat = re_nnode(e, P_CAT);
      cat->par.xy.x = nd;
      cat->par.xy.y.y = re_parse_la(e);
    }
    alt = cat;
  }
  if (e->lookahead == '|') {
    RE_NEXT(e);
    nd = alt;
    alt = re_nnode(e, P_ALT);
    alt->par.xy.x = nd;
    alt->par.xy.y.y = re_parser(e);
  }
  return alt;
}

static unsigned int re_nodelen(struct slre_node *nd) {
  unsigned int n = 0;
  if (!nd) return 0;
  switch (nd->type) {
    case P_ALT:
      n = 2;
    case P_CAT:
      return re_nodelen(nd->par.xy.x) + re_nodelen(nd->par.xy.y.y) + n;
    case P_BRA:
    case P_LA:
    case P_LA_N:
      return re_nodelen(nd->par.xy.x) + 2;
    case P_REP:
      n = nd->par.xy.y.rp.max - nd->par.xy.y.rp.min;
      switch (nd->par.xy.y.rp.min) {
        case 0:
          if (!n) return 0;
          if (nd->par.xy.y.rp.max >= SLRE_MAX_REP)
            return re_nodelen(nd->par.xy.x) + 2;
        case 1:
          if (!n) return re_nodelen(nd->par.xy.x);
          if (nd->par.xy.y.rp.max >= SLRE_MAX_REP)
            return re_nodelen(nd->par.xy.x) + 1;
        default:
          n = 4;
          if (nd->par.xy.y.rp.max >= SLRE_MAX_REP) n++;
          return re_nodelen(nd->par.xy.x) + n;
      }
    default:
      return 1;
  }
}

static struct slre_instruction *re_newinst(struct slre_prog *prog, int opcode) {
  memset(prog->end, 0, sizeof(struct slre_instruction));
  prog->end->opcode = opcode;
  return prog->end++;
}

static void re_compile(struct slre_env *e, struct slre_node *nd) {
  struct slre_instruction *inst, *split, *jump, *rep;
  unsigned int n;

  if (!nd) return;

  switch (nd->type) {
    case P_ALT:
      split = re_newinst(e->prog, I_SPLIT);
      re_compile(e, nd->par.xy.x);
      jump = re_newinst(e->prog, I_JUMP);
      re_compile(e, nd->par.xy.y.y);
      split->par.xy.x = split + 1;
      split->par.xy.y.y = jump + 1;
      jump->par.xy.x = e->prog->end;
      break;

    case P_ANY:
      re_newinst(e->prog, I_ANY);
      break;

    case P_BOL:
      re_newinst(e->prog, I_BOL);
      break;

    case P_BRA:
      inst = re_newinst(e->prog, I_LBRA);
      inst->par.n = nd->par.xy.y.n;
      re_compile(e, nd->par.xy.x);
      inst = re_newinst(e->prog, I_RBRA);
      inst->par.n = nd->par.xy.y.n;
      break;

    case P_CAT:
      re_compile(e, nd->par.xy.x);
      re_compile(e, nd->par.xy.y.y);
      break;

    case P_CH:
      inst = re_newinst(e->prog, I_CH);
      inst->par.c = nd->par.c;
      break;

    case P_EOL:
      re_newinst(e->prog, I_EOL);
      break;

    case P_EOS:
      re_newinst(e->prog, I_EOS);
      break;

    case P_LA:
      split = re_newinst(e->prog, I_LA);
      re_compile(e, nd->par.xy.x);
      re_newinst(e->prog, I_END);
      split->par.xy.x = split + 1;
      split->par.xy.y.y = e->prog->end;
      break;
    case P_LA_N:
      split = re_newinst(e->prog, I_LA_N);
      re_compile(e, nd->par.xy.x);
      re_newinst(e->prog, I_END);
      split->par.xy.x = split + 1;
      split->par.xy.y.y = e->prog->end;
      break;

    case P_REF:
      inst = re_newinst(e->prog, I_REF);
      inst->par.n = nd->par.xy.y.n;
      break;

    case P_REP:
      n = nd->par.xy.y.rp.max - nd->par.xy.y.rp.min;
      switch (nd->par.xy.y.rp.min) {
        case 0:
          if (!n) break;
          if (nd->par.xy.y.rp.max >= SLRE_MAX_REP) {
            split = re_newinst(e->prog, I_SPLIT);
            re_compile(e, nd->par.xy.x);
            jump = re_newinst(e->prog, I_JUMP);
            jump->par.xy.x = split;
            split->par.xy.x = split + 1;
            split->par.xy.y.y = e->prog->end;
            if (nd->par.xy.y.rp.ng) {
              split->par.xy.y.y = split + 1;
              split->par.xy.x = e->prog->end;
            }
            break;
          }
        case 1:
          if (!n) {
            re_compile(e, nd->par.xy.x);
            break;
          }
          if (nd->par.xy.y.rp.max >= SLRE_MAX_REP) {
            inst = e->prog->end;
            re_compile(e, nd->par.xy.x);
            split = re_newinst(e->prog, I_SPLIT);
            split->par.xy.x = inst;
            split->par.xy.y.y = e->prog->end;
            if (nd->par.xy.y.rp.ng) {
              split->par.xy.y.y = inst;
              split->par.xy.x = e->prog->end;
            }
            break;
          }
        default:
          inst = re_newinst(e->prog, I_REP_INI);
          inst->par.xy.y.rp.min = nd->par.xy.y.rp.min;
          inst->par.xy.y.rp.max = n;
          rep = re_newinst(e->prog, I_REP);
          split = re_newinst(e->prog, I_SPLIT);
          re_compile(e, nd->par.xy.x);
          jump = re_newinst(e->prog, I_JUMP);
          jump->par.xy.x = rep;
          rep->par.xy.x = e->prog->end;
          split->par.xy.x = split + 1;
          split->par.xy.y.y = e->prog->end;
          if (nd->par.xy.y.rp.ng) {
            split->par.xy.y.y = split + 1;
            split->par.xy.x = e->prog->end;
          }
          if (nd->par.xy.y.rp.max >= SLRE_MAX_REP) {
            inst = split + 1;
            split = re_newinst(e->prog, I_SPLIT);
            split->par.xy.x = inst;
            split->par.xy.y.y = e->prog->end;
            if (nd->par.xy.y.rp.ng) {
              split->par.xy.y.y = inst;
              split->par.xy.x = e->prog->end;
            }
            break;
          }
          break;
      }
      break;

    case P_SET:
      inst = re_newinst(e->prog, I_SET);
      inst->par.cp = nd->par.cp;
      break;
    case P_SET_N:
      inst = re_newinst(e->prog, I_SET_N);
      inst->par.cp = nd->par.cp;
      break;

    case P_WORD:
      re_newinst(e->prog, I_WORD);
      break;
    case P_WORD_N:
      re_newinst(e->prog, I_WORD_N);
      break;
  }
}

#ifdef RE_TEST
static void print_set(struct slre_class *cp) {
  struct slre_range *p;
  for (p = cp->spans; p < cp->end; p++) {
    printf("%s", p == cp->spans ? "'" : ",'");
    printf(
        p->s >= 32 && p->s < 127 ? "%c" : (p->s < 256 ? "\\x%02X" : "\\u%04X"),
        p->s);
    if (p->s != p->e) {
      printf(p->e >= 32 && p->e < 127 ? "-%c"
                                      : (p->e < 256 ? "-\\x%02X" : "-\\u%04X"),
             p->e);
    }
    printf("'");
  }
  printf("]");
}

static void node_print(struct slre_node *nd) {
  if (!nd) {
    printf("Empty");
    return;
  }
  switch (nd->type) {
    case P_ALT:
      printf("{");
      node_print(nd->par.xy.x);
      printf(" | ");
      node_print(nd->par.xy.y.y);
      printf("}");
      break;
    case P_ANY:
      printf(".");
      break;
    case P_BOL:
      printf("^");
      break;
    case P_BRA:
      node_print(nd->par.xy.x);
      printf(")");
      break;
    case P_CAT:
      printf("{");
      node_print(nd->par.xy.x);
      printf(" & ");
      node_print(nd->par.xy.y.y);
      printf("}");
      break;
    case P_CH:
      printf(nd->par.c >= 32 && nd->par.c < 127 ? "'%c'" : "'\\u%04X'",
             nd->par.c);
      break;
    case P_EOL:
      printf("$");
      break;
    case P_EOS:
      printf("\\0");
      break;
    case P_LA:
      printf("LA(");
      node_print(nd->par.xy.x);
      printf(")");
      break;
    case P_LA_N:
      printf("LA_N(");
      node_print(nd->par.xy.x);
      printf(")");
      break;
    case P_REF:
      printf("\\%d", nd->par.xy.y.n);
      break;
    case P_REP:
      node_print(nd->par.xy.x);
      printf(nd->par.xy.y.rp.ng ? "{%d,%d}?" : "{%d,%d}", nd->par.xy.y.rp.min,
             nd->par.xy.y.rp.max);
      break;
    case P_SET:
      printf("[");
      print_set(nd->par.cp);
      break;
    case P_SET_N:
      printf("[^");
      print_set(nd->par.cp);
      break;
    case P_WORD:
      printf("\\b");
      break;
    case P_WORD_N:
      printf("\\B");
      break;
  }
}

static void program_print(struct slre_prog *prog) {
  struct slre_instruction *inst;
  for (inst = prog->start; inst < prog->end; ++inst) {
    printf("%3d: ", inst - prog->start);
    switch (inst->opcode) {
      case I_END:
        puts("end");
        break;
      case I_ANY:
        puts(".");
        break;
      case I_ANYNL:
        puts(". | '\\r' | '\\n'");
        break;
      case I_BOL:
        puts("^");
        break;
      case I_CH:
        printf(
            inst->par.c >= 32 && inst->par.c < 127 ? "'%c'\n" : "'\\u%04X'\n",
            inst->par.c);
        break;
      case I_EOL:
        puts("$");
        break;
      case I_EOS:
        puts("\\0");
        break;
      case I_JUMP:
        printf("-->%d\n", inst->par.xy.x - prog->start);
        break;
      case I_LA:
        printf("la %d %d\n", inst->par.xy.x - prog->start,
               inst->par.xy.y.y - prog->start);
        break;
      case I_LA_N:
        printf("la_n %d %d\n", inst->par.xy.x - prog->start,
               inst->par.xy.y.y - prog->start);
        break;
      case I_LBRA:
        printf("( %d\n", inst->par.n);
        break;
      case I_RBRA:
        printf(") %d\n", inst->par.n);
        break;
      case I_SPLIT:
        printf("-->%d | -->%d\n", inst->par.xy.x - prog->start,
               inst->par.xy.y.y - prog->start);
        break;
      case I_REF:
        printf("\\%d\n", inst->par.n);
        break;
      case I_REP:
        printf("repeat -->%d\n", inst->par.xy.x - prog->start);
        break;
      case I_REP_INI:
        printf("init_rep %d %d\n", inst->par.xy.y.rp.min,
               inst->par.xy.y.rp.min + inst->par.xy.y.rp.max);
        break;
      case I_SET:
        printf("[");
        print_set(inst->par.cp);
        puts("");
        break;
      case I_SET_N:
        printf("[^");
        print_set(inst->par.cp);
        puts("");
        break;
      case I_WORD:
        puts("\\w");
        break;
      case I_WORD_N:
        puts("\\W");
        break;
    }
  }
}
#endif

int slre_compile(const char *pat, size_t pat_len, const char *flags,
                 volatile size_t fl_len, struct slre_prog **pr, int is_regex) {
  struct slre_env e;
  struct slre_node *nd;
  struct slre_instruction *split, *jump;
  int err_code;

  e.is_regex = is_regex;
  e.prog = (struct slre_prog *) SLRE_MALLOC(sizeof(struct slre_prog));
  e.pstart = e.pend =
      (struct slre_node *) SLRE_MALLOC(sizeof(struct slre_node) * pat_len * 2);
  e.prog->flags = is_regex ? SLRE_FLAG_RE : 0;

  if ((err_code = setjmp(e.jmp_buf)) != SLRE_OK) {
    SLRE_FREE(e.pstart);
    SLRE_FREE(e.prog);
    return err_code;
  }

  while (fl_len--) {
    switch (flags[fl_len]) {
      case 'g':
        e.prog->flags |= SLRE_FLAG_G;
        break;
      case 'i':
        e.prog->flags |= SLRE_FLAG_I;
        break;
      case 'm':
        e.prog->flags |= SLRE_FLAG_M;
        break;
    }
  }

  e.src = pat;
  e.src_end = pat + pat_len;
  e.sets_num = 0;
  e.num_captures = 1;
  /*e.flags = flags;*/
  memset(e.caps, 0, sizeof(e.caps));

  RE_NEXT(&e);
  nd = re_parser(&e);
  if (e.lookahead == ')') {
    SLRE_THROW(&e, SLRE_UNMATCH_RBR);
  }
  if (e.lookahead != 0) {
    SLRE_THROW(&e, SLRE_SYNTAX_ERROR);
  }

  e.prog->num_captures = e.num_captures;
  e.prog->start = e.prog->end = (struct slre_instruction *) SLRE_MALLOC(
      (re_nodelen(nd) + 6) * sizeof(struct slre_instruction));

  split = re_newinst(e.prog, I_SPLIT);
  split->par.xy.x = split + 3;
  split->par.xy.y.y = split + 1;
  re_newinst(e.prog, I_ANYNL);
  jump = re_newinst(e.prog, I_JUMP);
  jump->par.xy.x = split;
  re_newinst(e.prog, I_LBRA);
  re_compile(&e, nd);
  re_newinst(e.prog, I_RBRA);
  re_newinst(e.prog, I_END);

#ifdef RE_TEST
  node_print(nd);
  putchar('\n');
  program_print(e.prog);
#endif

  SLRE_FREE(e.pstart);

  if (pr != NULL) {
    *pr = e.prog;
  } else {
    slre_free(e.prog);
  }

  return err_code;
}

void slre_free(struct slre_prog *prog) {
  if (prog) {
    SLRE_FREE(prog->start);
    SLRE_FREE(prog);
  }
}

static struct slre_thread *re_newthread(struct slre_thread *t,
                                        struct slre_instruction *pc,
                                        const char *start,
                                        struct slre_loot *loot) {
  struct slre_thread *new_thread =
      (struct slre_thread *) SLRE_MALLOC(sizeof(struct slre_thread));
  if (new_thread != NULL) new_thread->prev = t;
  t->pc = pc;
  t->start = start;
  t->loot = *loot;
  return new_thread;
}

static struct slre_thread *get_prev_thread(struct slre_thread *t) {
  struct slre_thread *tmp_thr = t->prev;
  SLRE_FREE(t);
  return tmp_thr;
}

static void free_threads(struct slre_thread *t) {
  while (t->prev != NULL) t = get_prev_thread(t);
}

#define RE_NO_MATCH() \
  if (!(thr = 0)) continue

static unsigned char re_match(struct slre_instruction *pc, const char *current,
                              const char *end, const char *bol,
                              unsigned int flags, struct slre_loot *loot) {
  struct slre_loot sub, tmpsub;
  Rune c, r;
  struct slre_range *p;
  unsigned char thr;
  size_t i;
  struct slre_thread thread, *curr_thread, *tmp_thr;

  /* queue initial thread */
  thread.prev = NULL;
  curr_thread = re_newthread(&thread, pc, current, loot);

  /* run threads in stack order */
  do {
    curr_thread = get_prev_thread(curr_thread);
    pc = curr_thread->pc;
    current = curr_thread->start;
    sub = curr_thread->loot;
    for (thr = 1; thr;) {
      switch (pc->opcode) {
        case I_END:
          memcpy(loot->caps, sub.caps, sizeof loot->caps);
          free_threads(curr_thread);
          return 1;
        case I_ANY:
        case I_ANYNL:
          if (current < end) {
            current += chartorune(&c, current);
            if (c && !(pc->opcode == I_ANY && isnewline(c))) break;
          }
          RE_NO_MATCH();

        case I_BOL:
          if (current == bol) break;
          if ((flags & SLRE_FLAG_M) && isnewline(current[-1])) break;
          RE_NO_MATCH();
        case I_CH:
          if (current < end) {
            current += chartorune(&c, current);
            if (c &&
                (c == pc->par.c || ((flags & SLRE_FLAG_I) &&
                                    tolowerrune(c) == tolowerrune(pc->par.c))))
              break;
          }
          RE_NO_MATCH();
        case I_EOL:
          if (current >= end) break;
          if ((flags & SLRE_FLAG_M) && isnewline(*current)) break;
          RE_NO_MATCH();
        case I_EOS:
          if (current >= end) break;
          RE_NO_MATCH();

        case I_JUMP:
          pc = pc->par.xy.x;
          continue;

        case I_LA:
          if (re_match(pc->par.xy.x, current, end, bol, flags, &sub)) {
            pc = pc->par.xy.y.y;
            continue;
          }
          RE_NO_MATCH();
        case I_LA_N:
          tmpsub = sub;
          if (!re_match(pc->par.xy.x, current, end, bol, flags, &tmpsub)) {
            pc = pc->par.xy.y.y;
            continue;
          }
          RE_NO_MATCH();

        case I_LBRA:
          sub.caps[pc->par.n].start = current;
          break;

        case I_REF:
          i = sub.caps[pc->par.n].end - sub.caps[pc->par.n].start;
          if (flags & SLRE_FLAG_I) {
            int num = i;
            const char *s = current, *p = sub.caps[pc->par.n].start;
            Rune rr;
            for (; num && *s && *p; num--) {
              s += chartorune(&r, s);
              p += chartorune(&rr, p);
              if (tolowerrune(r) != tolowerrune(rr)) break;
            }
            if (num) RE_NO_MATCH();
          } else if (strncmp(current, sub.caps[pc->par.n].start, i)) {
            RE_NO_MATCH();
          }
          if (i > 0) current += i;
          break;

        case I_REP:
          if (pc->par.xy.y.rp.min) {
            pc->par.xy.y.rp.min--;
            pc++;
          } else if (!pc->par.xy.y.rp.max--) {
            pc = pc->par.xy.x;
            continue;
          }
          break;

        case I_REP_INI:
          (pc + 1)->par.xy.y.rp.min = pc->par.xy.y.rp.min;
          (pc + 1)->par.xy.y.rp.max = pc->par.xy.y.rp.max;
          break;

        case I_RBRA:
          sub.caps[pc->par.n].end = current;
          break;

        case I_SET:
        case I_SET_N:
          if (current >= end) RE_NO_MATCH();
          current += chartorune(&c, current);
          if (!c) RE_NO_MATCH();

          i = 1;
          for (p = pc->par.cp->spans; i && p < pc->par.cp->end; p++)
            if (flags & SLRE_FLAG_I) {
              for (r = p->s; r <= p->e; ++r)
                if (tolowerrune(c) == tolowerrune(r)) {
                  i = 0;
                  break;
                }
            } else if (p->s <= c && c <= p->e)
              i = 0;

          if (pc->opcode == I_SET) i = !i;
          if (i) break;
          RE_NO_MATCH();

        case I_SPLIT:
          tmp_thr = curr_thread;
          curr_thread =
              re_newthread(curr_thread, pc->par.xy.y.y, current, &sub);
          if (curr_thread == NULL) {
            fprintf(stderr, "re_match: no memory for thread!\n");
            free_threads(tmp_thr);
            return 0;
          }
          pc = pc->par.xy.x;
          continue;

        case I_WORD:
        case I_WORD_N:
          i = (current > bol && iswordchar(current[-1]));
          if (iswordchar(current[0])) i = !i;
          if (pc->opcode == I_WORD_N) i = !i;
          if (i) break;
        /* RE_NO_MATCH(); */

        default:
          RE_NO_MATCH();
      }
      pc++;
    }
  } while (curr_thread->prev != NULL);
  return 0;
}

int slre_exec(struct slre_prog *prog, int flag_g, const char *start,
              const char *end, struct slre_loot *loot) {
  struct slre_loot tmpsub;
  const char *st = start;

  if (!loot) loot = &tmpsub;
  memset(loot, 0, sizeof(*loot));

  if (!flag_g) {
    loot->num_captures = prog->num_captures;
    return !re_match(prog->start, start, end, start, prog->flags, loot);
  }

  while (re_match(prog->start, st, end, start, prog->flags, &tmpsub)) {
    unsigned int i;
    st = tmpsub.caps[0].end;
    for (i = 0; i < prog->num_captures; i++) {
      struct slre_cap *l = &loot->caps[loot->num_captures + i];
      struct slre_cap *s = &tmpsub.caps[i];
      l->start = s->start;
      l->end = s->end;
    }
    loot->num_captures += prog->num_captures;
  }
  return !loot->num_captures;
}

int slre_replace(struct slre_loot *loot, const char *src, size_t src_len,
                 const char *rstr, size_t rstr_len, struct slre_loot *dstsub) {
  int size = 0, n;
  Rune curr_rune;
  const char *const rstr_end = rstr + rstr_len;

  memset(dstsub, 0, sizeof(*dstsub));
  while (rstr < rstr_end && !(n = re_nextc(&curr_rune, &rstr, rstr_end)) &&
         curr_rune) {
    int sz;
    if (n < 0) return n;
    if (curr_rune == '$') {
      n = re_nextc(&curr_rune, &rstr, rstr_end);
      if (n < 0) return n;
      switch (curr_rune) {
        case '&':
          sz = loot->caps[0].end - loot->caps[0].start;
          size += sz;
          dstsub->caps[dstsub->num_captures++] = loot->caps[0];
          break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9': {
          int sbn = dec(curr_rune);
          if (0 == sbn && rstr[0] && isdigitrune(rstr[0])) {
            n = re_nextc(&curr_rune, &rstr, rstr_end);
            if (n < 0) return n;
            sz = dec(curr_rune);
            sbn = sbn * 10 + sz;
          }
          if (sbn >= loot->num_captures) break;
          sz = loot->caps[sbn].end - loot->caps[sbn].start;
          size += sz;
          dstsub->caps[dstsub->num_captures++] = loot->caps[sbn];
          break;
        }
        case '`':
          sz = loot->caps[0].start - src;
          size += sz;
          dstsub->caps[dstsub->num_captures].start = src;
          dstsub->caps[dstsub->num_captures++].end = loot->caps[0].start;
          break;
        case '\'':
          sz = src + src_len - loot->caps[0].end;
          size += sz;
          dstsub->caps[dstsub->num_captures].start = loot->caps[0].end;
          dstsub->caps[dstsub->num_captures++].end = loot->caps[0].end + sz;
          break;
        case '$':
          size++;
          dstsub->caps[dstsub->num_captures].start = rstr - 1;
          dstsub->caps[dstsub->num_captures++].end = rstr;
          break;
        default:
          return SLRE_BAD_CHAR_AFTER_USD;
      }
    } else {
      char tmps[300], *d = tmps;
      size += (sz = runetochar(d, &curr_rune));
      if (!dstsub->num_captures ||
          dstsub->caps[dstsub->num_captures - 1].end != rstr - sz) {
        dstsub->caps[dstsub->num_captures].start = rstr - sz;
        dstsub->caps[dstsub->num_captures++].end = rstr;
      } else
        dstsub->caps[dstsub->num_captures - 1].end = rstr;
    }
  }
  return size;
}

int slre_match(const char *re, size_t re_len, const char *flags, size_t fl_len,
               const char *str, size_t str_len, struct slre_loot *loot) {
  struct slre_prog *prog = NULL;
  int res;

  if ((res = slre_compile(re, re_len, flags, fl_len, &prog, 1)) == SLRE_OK) {
    res = slre_exec(prog, prog->flags & SLRE_FLAG_G, str, str + str_len, loot);
    slre_free(prog);
  }

  return res;
}

int slre_get_flags(struct slre_prog *crp) {
  return crp->flags;
}

#ifdef SLRE_TEST

#include <errno.h>

static const char *err_code_to_str(int err_code) {
  static const char *ar[] = {
      "no error", "invalid decimal digit", "invalid hex digit",
      "invalid escape character", "invalid unterminated escape sequence",
      "syntax error", "unmatched left parenthesis",
      "unmatched right parenthesis", "numeric overflow",
      "infinite loop empty string", "too many charsets",
      "invalid charset range", "charset is too large", "malformed charset",
      "invalid back reference", "too many captures", "invalid quantifier",
      "bad character after $"};

  typedef char static_assertion_err_codes_out_of_sync
      [2 * !!(((sizeof(ar) / sizeof(ar[0])) == SLRE_BAD_CHAR_AFTER_USD + 1)) -
       1];

  return err_code >= 0 && err_code < (int) (sizeof(ar) / sizeof(ar[0]))
             ? ar[err_code]
             : "invalid error code";
}

#define RE_TEST_STR_SIZE 2000

static unsigned get_flags(const char *ch) {
  unsigned int flags = 0;

  while (*ch != '\0') {
    switch (*ch) {
      case 'g':
        flags |= SLRE_FLAG_G;
        break;
      case 'i':
        flags |= SLRE_FLAG_I;
        break;
      case 'm':
        flags |= SLRE_FLAG_M;
        break;
      case 'r':
        flags |= SLRE_FLAG_RE;
        break;
      default:
        return flags;
    }
    ch++;
  }
  return flags;
}

static void show_usage_and_exit(char *argv[]) {
  fprintf(stderr, "Usage: %s [OPTIONS]\n", argv[0]);
  fprintf(stderr, "%s\n", "OPTIONS:");
  fprintf(stderr, "%s\n", "  -p <regex_pattern>     Regex pattern");
  fprintf(stderr, "%s\n", "  -o <regex_flags>       Combination of g,i,m");
  fprintf(stderr, "%s\n", "  -s <string>            String to match");
  fprintf(stderr, "%s\n", "  -f <file_name>         Match lines from file");
  fprintf(stderr, "%s\n", "  -n <cap_no>            Show given capture");
  fprintf(stderr, "%s\n", "  -r <replace_str>       Replace given capture");
  fprintf(stderr, "%s\n", "  -v                     Show verbose stats");
  exit(1);
}

static int process_line(struct slre_prog *pr, const char *flags,
                        const char *line, const char *cap_no,
                        const char *replace, const char *verbose) {
  struct slre_loot loot;
  unsigned int fl = flags == NULL ? 0 : get_flags(flags);
  int i, n = cap_no == NULL ? -1 : atoi(cap_no), err_code = 0;
  struct slre_cap *cap = &loot.caps[n];

  err_code =
      slre_exec(pr, pr->flags & SLRE_FLAG_G, line, line + strlen(line), &loot);
  if (err_code == SLRE_OK) {
    if (n >= 0 && n < loot.num_captures && replace != NULL) {
      struct slre_cap *cap = &loot.caps[n];
      printf("%.*s", (int) (cap->start - line), line);
      printf("%s", replace);
      printf("%.*s", (int) ((line + strlen(line)) - cap->end), cap->end);
    } else if (n >= 0 && n < loot.num_captures) {
      printf("%.*s\n", (int) (cap->end - cap->start), cap->start);
    }

    if (verbose != NULL) {
      fprintf(stderr, "%s\n", "Captures:");
      for (i = 0; i < loot.num_captures; i++) {
        fprintf(stderr, "%d [%.*s]\n", i,
                (int) (loot.caps[i].end - loot.caps[i].start),
                loot.caps[i].start);
      }
    }
  }

  return err_code;
}

int main(int argc, char **argv) {
  const char *str = NULL, *pattern = NULL, *replace = NULL;
  const char *flags = "", *file_name = NULL, *cap_no = NULL, *verbose = NULL;
  struct slre_prog *pr = NULL;
  int i, err_code = 0;

  /* Execute inline code */
  for (i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-p") == 0 && i + 1 < argc) {
      pattern = argv[++i];
    } else if (strcmp(argv[i], "-o") == 0 && i + 1 < argc) {
      flags = argv[++i];
    } else if (strcmp(argv[i], "-s") == 0 && i + 1 < argc) {
      str = argv[++i];
    } else if (strcmp(argv[i], "-f") == 0 && i + 1 < argc) {
      file_name = argv[++i];
    } else if (strcmp(argv[i], "-n") == 0 && i + 1 < argc) {
      cap_no = argv[++i];
    } else if (strcmp(argv[i], "-r") == 0 && i + 1 < argc) {
      replace = argv[++i];
    } else if (strcmp(argv[i], "-v") == 0) {
      verbose = "";
    } else if (strcmp(argv[i], "-h") == 0) {
      show_usage_and_exit(argv);
    } else {
      show_usage_and_exit(argv);
    }
  }

  if (pattern == NULL) {
    fprintf(stderr, "%s\n", "-p option is mandatory");
    exit(1);
  } else if ((err_code = slre_compile(pattern, strlen(pattern), flags,
                                      strlen(flags), &pr, 1)) != SLRE_OK) {
    fprintf(stderr, "slre_compile(%s): %s\n", argv[0],
            err_code_to_str(err_code));
    exit(1);
  } else if (str != NULL) {
    err_code = process_line(pr, flags, str, cap_no, replace, verbose);
  } else if (file_name != NULL) {
    FILE *fp = strcmp(file_name, "-") == 0 ? stdin : fopen(file_name, "rb");
    char line[20 * 1024];
    if (fp == NULL) {
      fprintf(stderr, "Cannot open %s: %s\n", file_name, strerror(errno));
      exit(1);
    } else {
      /* Return success if at least one line matches */
      err_code = 1;
      while (fgets(line, sizeof(line), fp) != NULL) {
        if (process_line(pr, flags, line, cap_no, replace, verbose) ==
            SLRE_OK) {
          err_code = 0;
        }
      }
      fclose(fp); /* If fp == stdin, it is safe to close, too */
    }
  } else {
    fprintf(stderr, "%s\n", "Please specify one of -s or -f options");
    exit(1);
  }
  slre_free(pr);

  return err_code;
}
#endif /* SLRE_TEST */

#endif /* V7_ENABLE__RegExp */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#if V7_ENABLE__Object__getPrototypeOf
static val_t Obj_getPrototypeOf(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg = v7_array_get(v7, args, 0);
  (void) this_obj;
  if (!v7_is_object(arg)) {
    throw_exception(v7, TYPE_ERROR,
                    "Object.getPrototypeOf called on non-object");
  }
  return v_get_prototype(v7, arg);
}
#endif

#if V7_ENABLE__Object__isPrototypeOf
static val_t Obj_isPrototypeOf(struct v7 *v7, val_t this_obj, val_t args) {
  val_t obj = v7_array_get(v7, args, 0);
  val_t proto = v7_array_get(v7, args, 1);
  (void) this_obj;
  return v7_create_boolean(is_prototype_of(v7, obj, proto));
}
#endif

#if V7_ENABLE__Object__getOwnPropertyNames || V7_ENABLE__Object__keys
/*
 * Hack to ensure that the iteration order of the keys array is consistent
 * with the iteration order if properties in `for in`
 * This will be obsoleted when arrays will have a special object type.
 */
static void _Obj_append_reverse(struct v7 *v7, struct v7_property *p, val_t res,
                                int i, unsigned int ignore_flags) {
  while (p && p->attributes & ignore_flags) p = p->next;
  if (p == NULL) return;
  if (p->next) _Obj_append_reverse(v7, p->next, res, i + 1, ignore_flags);

  v7_array_set(v7, res, i, p->name);
}

static val_t _Obj_ownKeys(struct v7 *v7, val_t args,
                          unsigned int ignore_flags) {
  val_t obj = v7_array_get(v7, args, 0);
  val_t res = v7_create_dense_array(v7);
  if (!v7_is_object(obj)) {
    throw_exception(v7, TYPE_ERROR, "Object.keys called on non-object");
  }

  _Obj_append_reverse(v7, v7_to_object(obj)->properties, res, 0, ignore_flags);
  return res;
}
#endif

static struct v7_property *_Obj_getOwnProperty(struct v7 *v7, val_t obj,
                                               val_t name) {
  char name_buf[512];
  int name_len;
  name_len = v7_stringify_value(v7, name, name_buf, sizeof(name_buf));
  return v7_get_own_property(v7, obj, name_buf, name_len);
}

#if V7_ENABLE__Object__keys
static val_t Obj_keys(struct v7 *v7, val_t this_obj, val_t args) {
  (void) this_obj;
  return _Obj_ownKeys(v7, args, V7_PROPERTY_HIDDEN | V7_PROPERTY_DONT_ENUM);
}
#endif

#if V7_ENABLE__Object__getOwnPropertyNames
static val_t Obj_getOwnPropertyNames(struct v7 *v7, val_t this_obj,
                                     val_t args) {
  (void) this_obj;
  return _Obj_ownKeys(v7, args, V7_PROPERTY_HIDDEN);
}
#endif

#if V7_ENABLE__Object__getOwnPropertyDescriptor
static val_t Obj_getOwnPropertyDescriptor(struct v7 *v7, val_t this_obj,
                                          val_t args) {
  struct v7_property *prop;
  val_t obj = v7_array_get(v7, args, 0);
  val_t name = v7_array_get(v7, args, 1);
  val_t desc;
  (void) this_obj;
  if ((prop = _Obj_getOwnProperty(v7, obj, name)) == NULL) {
    return V7_UNDEFINED;
  }
  desc = v7_create_object(v7);
  v7_set_property(v7, desc, "value", 5, 0, prop->value);
  v7_set_property(
      v7, desc, "writable", 8, 0,
      v7_create_boolean(!(prop->attributes & V7_PROPERTY_READ_ONLY)));
  v7_set_property(
      v7, desc, "enumerable", 10, 0,
      v7_create_boolean(
          !(prop->attributes & (V7_PROPERTY_HIDDEN | V7_PROPERTY_DONT_ENUM))));
  v7_set_property(
      v7, desc, "configurable", 12, 0,
      v7_create_boolean(!(prop->attributes & V7_PROPERTY_DONT_DELETE)));

  return desc;
}
#endif

static void o_set_attr(struct v7 *v7, val_t desc, const char *name, size_t n,
                       struct v7_property *prop, unsigned int attr) {
  val_t v = v7_get(v7, desc, name, n);
  if (v7_is_true(v7, v)) {
    prop->attributes &= ~attr;
  } else {
    prop->attributes |= attr;
  }
}

static val_t _Obj_defineProperty(struct v7 *v7, val_t obj, const char *name,
                                 int name_len, val_t desc) {
  val_t val = v7_get(v7, desc, "value", 5);
  struct v7_property *prop = v7_get_own_property(v7, obj, name, name_len);

  if (prop == NULL) {
    val_t key = v7_create_string(v7, name, name_len, 1);
    prop = v7_set_prop(v7, obj, key, 0, val);
  }

  if (prop == NULL) {
    throw_exception(v7, INTERNAL_ERROR, "OOM");
  } else {
    o_set_attr(v7, desc, "enumerable", 10, prop, V7_PROPERTY_DONT_ENUM);
    o_set_attr(v7, desc, "writable", 8, prop, V7_PROPERTY_READ_ONLY);
    o_set_attr(v7, desc, "configurable", 12, prop, V7_PROPERTY_DONT_DELETE);
    if (!v7_is_undefined(val)) {
      prop->value = val;
    }
  }

  return obj;
}

#if V7_ENABLE__Object__defineProperty
static val_t Obj_defineProperty(struct v7 *v7, val_t this_obj, val_t args) {
  val_t obj = v7_array_get(v7, args, 0);
  val_t name = v7_array_get(v7, args, 1);
  val_t desc = v7_array_get(v7, args, 2);
  char name_buf[512];
  int name_len;
  (void) this_obj;
  if (!v7_is_object(obj)) {
    throw_exception(v7, TYPE_ERROR, "object expected");
  }
  name_len = v7_stringify_value(v7, name, name_buf, sizeof(name_buf));
  return _Obj_defineProperty(v7, obj, name_buf, name_len, desc);
}
#endif

static void o_define_props(struct v7 *v7, val_t obj, val_t descs) {
  struct v7_property *p;
  if (!v7_is_object(descs)) {
    throw_exception(v7, TYPE_ERROR, "object expected");
  }
  for (p = v7_to_object(descs)->properties; p; p = p->next) {
    size_t n;
    const char *s = v7_to_string(v7, &p->name, &n);
    if (p->attributes & (V7_PROPERTY_HIDDEN | V7_PROPERTY_DONT_ENUM)) {
      continue;
    }
    _Obj_defineProperty(v7, obj, s, n, p->value);
  }
}

#if V7_ENABLE__Object__defineProperties
static val_t Obj_defineProperties(struct v7 *v7, val_t this_obj, val_t args) {
  val_t obj = v7_array_get(v7, args, 0);
  val_t descs = v7_array_get(v7, args, 1);
  (void) this_obj;
  o_define_props(v7, obj, descs);
  return obj;
}
#endif

#if V7_ENABLE__Object__create
static val_t Obj_create(struct v7 *v7, val_t this_obj, val_t args) {
  val_t res, proto = v7_array_get(v7, args, 0);
  val_t descs = v7_array_get(v7, args, 1);
  (void) this_obj;
  if (!v7_is_null(proto) && !v7_is_object(proto)) {
    throw_exception(v7, TYPE_ERROR,
                    "Object prototype may only be an Object or null");
  }
  res = create_object(v7, proto);
  if (v7_is_object(descs)) {
    o_define_props(v7, res, descs);
  }
  return res;
}
#endif

#if V7_ENABLE__Object__propertyIsEnumerable
static val_t Obj_propertyIsEnumerable(struct v7 *v7, val_t this_obj,
                                      val_t args) {
  struct v7_property *prop;
  val_t name = v7_array_get(v7, args, 0);
  if ((prop = _Obj_getOwnProperty(v7, this_obj, name)) == NULL) {
    return v7_create_boolean(0);
  }
  return v7_create_boolean(
      !(prop->attributes & (V7_PROPERTY_HIDDEN | V7_PROPERTY_DONT_ENUM)));
}
#endif

#if V7_ENABLE__Object__hasOwnProperty
static val_t Obj_hasOwnProperty(struct v7 *v7, val_t this_obj, val_t args) {
  val_t name = v7_array_get(v7, args, 0);
  return v7_create_boolean(_Obj_getOwnProperty(v7, this_obj, name) != NULL);
}
#endif

#if 0
static enum v7_err Obj_toString(struct v7_c_func_arg *cfa) {
  char *p, buf[500];
  p = v7_stringify(cfa->this_obj, buf, sizeof(buf));
  v7_push_string(cfa->v7, p, strlen(p), 1);
  if (p != buf) free(p);
  return V7_OK;
}
#endif

V7_PRIVATE val_t Obj_valueOf(struct v7 *v7, val_t this_obj, val_t args) {
  val_t res = this_obj;
  struct v7_property *p;

  if (v7_is_regexp(v7, this_obj)) return this_obj;

  (void) args;
  p = v7_get_own_property2(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN);
  if (p != NULL) {
    res = p->value;
  }

  return res;
}

static val_t Obj_toString(struct v7 *v7, val_t this_obj, val_t args) {
  char buf[20];
  const char *type = "Object";
  (void) args;
  if (is_prototype_of(v7, this_obj, v7->array_prototype)) {
    type = "Array";
  }
  c_snprintf(buf, sizeof(buf), "[object %s]", type);
  return v7_create_string(v7, buf, strlen(buf), 1);
}

#if V7_ENABLE__Object__preventExtensions
static val_t Obj_preventExtensions(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg = v7_array_get(v7, args, 0);
  (void) this_obj;
  if (!v7_is_object(arg)) {
    throw_exception(v7, TYPE_ERROR, "Object expected");
  }
  v7_to_object(arg)->attributes |= V7_OBJ_NOT_EXTENSIBLE;
  return arg;
}
#endif

#if V7_ENABLE__Object__isExtensible
static val_t Obj_isExtensible(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg = v7_array_get(v7, args, 0);
  (void) this_obj;
  if (!v7_is_object(arg)) {
    throw_exception(v7, TYPE_ERROR, "Object expected");
  }
  return v7_create_boolean(
      !(v7_to_object(arg)->attributes & V7_OBJ_NOT_EXTENSIBLE));
}
#endif

static const char js_function_Object[] =
    "function Object(v) {"
    "if (typeof v === 'boolean') return new Boolean(v);"
    "if (typeof v === 'number') return new Number(v);"
    "if (typeof v === 'string') return new String(v);"
    "if (typeof v === 'date') return new Date(v);"
    "}";

V7_PRIVATE void init_object(struct v7 *v7) {
  val_t object, v;
  /* TODO(mkm): initialize global object without requiring a parser */
  v7_exec(v7, &v, js_function_Object);

  object = v7_get(v7, v7->global_object, "Object", 6);
  v7_set(v7, object, "prototype", 9, 0, v7->object_prototype);
  v7_set(v7, v7->object_prototype, "constructor", 11, 0, object);

  set_method(v7, v7->object_prototype, "toString", Obj_toString, 0);
#if V7_ENABLE__Object__getPrototypeOf
  set_cfunc_prop(v7, object, "getPrototypeOf", Obj_getPrototypeOf);
#endif
#if V7_ENABLE__Object__getOwnPropertyDescriptor
  set_cfunc_prop(v7, object, "getOwnPropertyDescriptor",
                 Obj_getOwnPropertyDescriptor);
#endif
#if V7_ENABLE__Object__defineProperty
  set_method(v7, object, "defineProperty", Obj_defineProperty, 3);
#endif
#if V7_ENABLE__Object__defineProperties
  set_cfunc_prop(v7, object, "defineProperties", Obj_defineProperties);
#endif
#if V7_ENABLE__Object__create
  set_cfunc_prop(v7, object, "create", Obj_create);
#endif
#if V7_ENABLE__Object__keys
  set_cfunc_prop(v7, object, "keys", Obj_keys);
#endif
#if V7_ENABLE__Object__getOwnPropertyNames
  set_cfunc_prop(v7, object, "getOwnPropertyNames", Obj_getOwnPropertyNames);
#endif
#if V7_ENABLE__Object__preventExtensions
  set_method(v7, object, "preventExtensions", Obj_preventExtensions, 1);
#endif
#if V7_ENABLE__Object__isExtensible
  set_method(v7, object, "isExtensible", Obj_isExtensible, 1);
#endif

#if V7_ENABLE__Object__propertyIsEnumerable
  set_cfunc_prop(v7, v7->object_prototype, "propertyIsEnumerable",
                 Obj_propertyIsEnumerable);
#endif
#if V7_ENABLE__Object__hasOwnProperty
  set_cfunc_prop(v7, v7->object_prototype, "hasOwnProperty",
                 Obj_hasOwnProperty);
#endif
#if V7_ENABLE__Object__isPrototypeOf
  set_cfunc_prop(v7, v7->object_prototype, "isPrototypeOf", Obj_isPrototypeOf);
#endif
  set_cfunc_prop(v7, v7->object_prototype, "valueOf", Obj_valueOf);
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


static val_t Error_ctor(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_get(v7, args, 0);
  val_t res;

  if (v7_is_object(this_obj) && this_obj != v7->global_object) {
    res = this_obj;
  } else {
    res = create_object(v7, v7->error_prototype);
  }
  /* TODO(mkm): set non enumerable but provide toString method */
  v7_set_property(v7, res, "message", 7, 0, arg0);

  return res;
}

static const char *const error_names[] = {"TypeError", "SyntaxError",
                                          "ReferenceError", "InternalError",
                                          "RangeError"};
V7_STATIC_ASSERT(ARRAY_SIZE(error_names) == ERROR_CTOR_MAX,
                 error_name_count_mismatch);

V7_PRIVATE void init_error(struct v7 *v7) {
  val_t error;
  size_t i;

  error = v7_create_constructor(v7, v7->error_prototype, Error_ctor, 1);
  v7_set_property(v7, v7->global_object, "Error", 5, V7_PROPERTY_DONT_ENUM,
                  error);

  for (i = 0; i < ARRAY_SIZE(error_names); i++) {
    error = v7_create_constructor(v7, create_object(v7, v7->error_prototype),
                                  Error_ctor, 1);
    v7_set_property(v7, v7->global_object, error_names[i],
                    strlen(error_names[i]), V7_PROPERTY_DONT_ENUM, error);
    v7->error_objects[i] = error;
  }
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


static val_t Number_ctor(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_length(v7, args) == 0 ? v7_create_number(0.0)
                                              : v7_array_get(v7, args, 0);
  val_t res = v7_is_number(arg0) ? arg0 : v7_create_number(i_as_num(v7, arg0));

  if (v7_is_object(this_obj) && this_obj != v7->global_object) {
    v7_to_object(this_obj)->prototype = v7_to_object(v7->number_prototype);
    v7_set_property(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN, res);
    res = this_obj;
  }

  return res;
}

V7_PRIVATE val_t
n_to_str(struct v7 *v7, val_t t, val_t args, const char *format) {
  val_t arg0 = v7_array_get(v7, args, 0);
  double d = i_as_num(v7, arg0);
  int len, digits = d > 0 ? (int) d : 0;
  char fmt[10], buf[100];

  snprintf(fmt, sizeof(fmt), format, digits);
  len = snprintf(buf, sizeof(buf), fmt, v7_to_number(i_value_of(v7, t)));

  return v7_create_string(v7, buf, len, 1);
}

static val_t Number_toFixed(struct v7 *v7, val_t this_obj, val_t args) {
  return n_to_str(v7, this_obj, args, "%%.%dlf");
}

static val_t Number_toExp(struct v7 *v7, val_t this_obj, val_t args) {
  return n_to_str(v7, this_obj, args, "%%.%de");
}

static val_t Number_toPrecision(struct v7 *v7, val_t this_obj, val_t args) {
  return Number_toExp(v7, this_obj, args);
}

static val_t Number_valueOf(struct v7 *v7, val_t this_obj, val_t args) {
  if (!v7_is_number(this_obj) &&
      (v7_is_object(this_obj) &&
       v7_object_to_value(v7_to_object(this_obj)->prototype) !=
           v7->number_prototype)) {
    throw_exception(v7, TYPE_ERROR,
                    "Number.valueOf called on non-number object");
  }
  return Obj_valueOf(v7, this_obj, args);
}

static val_t Number_toString(struct v7 *v7, val_t this_obj, val_t args) {
  char buf[50];
  (void) args;

  if (this_obj == v7->number_prototype) {
    return v7_create_string(v7, "0", 1, 1);
  }

  if (!v7_is_number(this_obj) &&
      !(v7_is_object(this_obj) &&
        is_prototype_of(v7, this_obj, v7->number_prototype))) {
    throw_exception(v7, TYPE_ERROR,
                    "Number.toString called on non-number object");
  }

  /* TODO(mkm) handle radix first arg */
  v7_stringify_value(v7, i_value_of(v7, this_obj), buf, sizeof(buf));
  return v7_create_string(v7, buf, strlen(buf), 1);
}

static val_t n_isNaN(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_get(v7, args, 0);
  (void) this_obj;
  return v7_create_boolean(!v7_is_number(arg0) || arg0 == V7_TAG_NAN);
}

V7_PRIVATE void init_number(struct v7 *v7) {
  unsigned int attrs =
      V7_PROPERTY_READ_ONLY | V7_PROPERTY_DONT_ENUM | V7_PROPERTY_DONT_DELETE;
  val_t num = v7_create_constructor(v7, v7->number_prototype, Number_ctor, 1);
  v7_set_property(v7, v7->global_object, "Number", 6, V7_PROPERTY_DONT_ENUM,
                  num);

  set_cfunc_prop(v7, v7->number_prototype, "toFixed", Number_toFixed);
  set_cfunc_prop(v7, v7->number_prototype, "toPrecision", Number_toPrecision);
  set_cfunc_prop(v7, v7->number_prototype, "toExponential", Number_toExp);
  set_cfunc_prop(v7, v7->number_prototype, "valueOf", Number_valueOf);
  set_cfunc_prop(v7, v7->number_prototype, "toString", Number_toString);

  v7_set_property(v7, num, "MAX_VALUE", 9, attrs,
                  v7_create_number(1.7976931348623157e+308));
  v7_set_property(v7, num, "MIN_VALUE", 9, attrs, v7_create_number(5e-324));
#if V7_ENABLE__NUMBER__NEGATIVE_INFINITY
  v7_set_property(v7, num, "NEGATIVE_INFINITY", 17, attrs,
                  v7_create_number(-INFINITY));
#endif
#if V7_ENABLE__NUMBER__POSITIVE_INFINITY
  v7_set_property(v7, num, "POSITIVE_INFINITY", 17, attrs,
                  v7_create_number(INFINITY));
#endif
  v7_set_property(v7, num, "NaN", 3, attrs, V7_TAG_NAN);

  v7_set_property(v7, v7->global_object, "NaN", 3, attrs, V7_TAG_NAN);
  v7_set_property(v7, v7->global_object, "isNaN", 5, V7_PROPERTY_DONT_ENUM,
                  v7_create_cfunction(n_isNaN));
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


static val_t Json_stringify(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_get(v7, args, 0);
  char buf[100], *p = v7_to_json(v7, arg0, buf, sizeof(buf));
  val_t res = v7_create_string(v7, p, strlen(p), 1);
  (void) this_obj;
  if (p != buf) free(p);
  return res;
}

V7_PRIVATE v7_val_t Json_parse(struct v7 *v7, v7_val_t t, v7_val_t args) {
  (void) t;
  return _std_eval(v7, args, '(', ')');
}

V7_PRIVATE void init_json(struct v7 *v7) {
  val_t o = v7_create_object(v7);
  set_method(v7, o, "stringify", Json_stringify, 1);
  set_method(v7, o, "parse", Json_parse, 1);
  v7_set_property(v7, v7->global_object, "JSON", 4, V7_PROPERTY_DONT_ENUM, o);
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */



struct a_sort_data {
  struct v7 *v7;
  val_t sort_func;
};

static val_t Array_ctor(struct v7 *v7, val_t this_obj, val_t args) {
#if 0
  (void) v7;
  (void) this_obj;
  return args;
#else
  unsigned long i, len;
  val_t res = v7_create_array(v7);
  (void) v7;
  (void) this_obj;
  /*
   * The interpreter passes dense array to C functions.
   * However dense array implementation is not yet complete
   * so we don't want to propagate them at each call to Array()
   */
  len = v7_array_length(v7, args);
  for (i = 0; i < len; i++) {
    v7_array_set(v7, res, i, v7_array_get(v7, args, i));
  }
  return res;
#endif
}

static val_t Array_push(struct v7 *v7, val_t this_obj, val_t args) {
  val_t v = v7_create_undefined();
  int i, len = v7_array_length(v7, args);
  for (i = 0; i < len; i++) {
    v = v7_array_get(v7, args, i);
    v7_array_push(v7, this_obj, v);
  }
  return v;
}

static val_t Array_get_length(struct v7 *v7, val_t this_obj, val_t args) {
  long len = 0;
  (void) args;
  if (is_prototype_of(v7, this_obj, v7->array_prototype)) {
    len = v7_array_length(v7, this_obj);
  }
  return v7_create_number(len);
}

static val_t Array_set_length(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_get(v7, args, 0);
  long new_len = arg_long(v7, args, 0, -1);

  if (!v7_is_object(this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Array expected");
  } else if (new_len < 0 ||
             (v7_is_number(arg0) &&
              (isnan(v7_to_number(arg0)) || isinf(v7_to_number(arg0))))) {
    throw_exception(v7, RANGE_ERROR, "Invalid array length");
  } else {
    struct v7_property **p, **next;
    long index, max_index = -1;

    /* Remove all items with an index higher then new_len */
    for (p = &v7_to_object(this_obj)->properties; *p != NULL; p = next) {
      size_t n;
      const char *s = v7_to_string(v7, &p[0]->name, &n);
      next = &p[0]->next;
      index = strtol(s, NULL, 10);
      if (index >= new_len) {
        v7_destroy_property(p);
        *p = *next;
        next = p;
      } else if (index > max_index) {
        max_index = index;
      }
    }

    /* If we have to expand, insert an item with appropriate index */
    if (new_len > 0 && max_index < new_len - 1) {
      char buf[40];
      c_snprintf(buf, sizeof(buf), "%ld", new_len - 1);
      v7_set_property(v7, this_obj, buf, strlen(buf), 0, V7_UNDEFINED);
    }
  }
  return v7_create_number(new_len);
}

static int a_cmp(void *user_data, const void *pa, const void *pb) {
  struct a_sort_data *sort_data = (struct a_sort_data *) user_data;
  struct v7 *v7 = sort_data->v7;
  val_t a = *(val_t *) pa, b = *(val_t *) pb, func = sort_data->sort_func;

  if (v7_is_function(func)) {
    val_t res, args = v7_create_dense_array(v7);
    v7_array_push(v7, args, a);
    v7_array_push(v7, args, b);
    res = v7_apply(v7, func, V7_UNDEFINED, args);
    return (int) -v7_to_number(res);
  } else {
    char sa[100], sb[100];
    to_str(v7, a, sa, sizeof(sa), 0);
    to_str(v7, b, sb, sizeof(sb), 0);
    sa[sizeof(sa) - 1] = sb[sizeof(sb) - 1] = '\0';
    return strcmp(sb, sa);
  }
}

static int a_partition(val_t *a, int l, int r, void *user_data) {
  val_t t, pivot = a[l];
  int i = l, j = r + 1;

  for (;;) {
    do
      ++i;
    while (i <= r && a_cmp(user_data, &a[i], &pivot) <= 0);
    do
      --j;
    while (a_cmp(user_data, &a[j], &pivot) > 0);
    if (i >= j) break;
    t = a[i];
    a[i] = a[j];
    a[j] = t;
  }
  t = a[l];
  a[l] = a[j];
  a[j] = t;
  return j;
}

static void a_qsort(val_t *a, int l, int r, void *user_data) {
  if (l < r) {
    int j = a_partition(a, l, r, user_data);
    a_qsort(a, l, j - 1, user_data);
    a_qsort(a, j + 1, r, user_data);
  }
}

static val_t a_sort(struct v7 *v7, val_t obj, val_t args,
                    int (*sorting_func)(void *, const void *, const void *)) {
  int i = 0, len = v7_array_length(v7, obj);
  val_t *arr;
  val_t arg0 = v7_array_get(v7, args, 0);
  jmp_buf saved_jmp_buf;
  volatile enum jmp_type j;

  if (!v7_is_object(obj)) return obj;

  /* TODO(mkm): guard against exceptions thrown by custom comparators */
  arr = (val_t *) malloc(len * sizeof(arr[0]));

  memcpy(&saved_jmp_buf, &v7->jmp_buf, sizeof(saved_jmp_buf));
  if ((j = (enum jmp_type) sigsetjmp(v7->jmp_buf, 0)) != 0) {
    memcpy(&v7->jmp_buf, &saved_jmp_buf, sizeof(saved_jmp_buf));
    free(arr);
    siglongjmp(v7->jmp_buf, j);
  }

  assert(obj != v7->global_object);

  for (i = 0; i < len; i++) {
    arr[i] = v7_array_get(v7, obj, i);
  }

  if (sorting_func != NULL) {
    struct a_sort_data sort_data;
    sort_data.v7 = v7;
    sort_data.sort_func = arg0;
    a_qsort(arr, 0, len - 1, &sort_data);
  }

  for (i = 0; i < len; i++) {
    v7_array_set(v7, obj, i, arr[len - (i + 1)]);
  }

  memcpy(&v7->jmp_buf, &saved_jmp_buf, sizeof(saved_jmp_buf));
  free(arr);
  return obj;
}

static val_t Array_sort(struct v7 *v7, val_t this_obj, val_t args) {
  return a_sort(v7, this_obj, args, a_cmp);
}

static val_t Array_reverse(struct v7 *v7, val_t this_obj, val_t args) {
  return a_sort(v7, this_obj, args, NULL);
}

static val_t Array_join(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_get(v7, args, 0);
  val_t res = v7_create_undefined();
  size_t sep_size = 0;
  const char *sep = NULL;

  /* Get pointer to the separator string */
  if (!v7_is_string(arg0)) {
    /* If no separator is provided, use comma */
    arg0 = v7_create_string(v7, ",", 1, 1);
  }
  sep = v7_to_string(v7, &arg0, &sep_size);

  /* Do the actual join */
  if (is_prototype_of(v7, this_obj, v7->array_prototype)) {
    struct mbuf m;
    char buf[100], *p;
    long i, n, num_elems = v7_array_length(v7, this_obj);

    mbuf_init(&m, 0);

    for (i = 0; i < num_elems; i++) {
      /* Append separator */
      if (i > 0) {
        mbuf_append(&m, sep, sep_size);
      }

      /* Append next item from an array */
      p = buf;
      n = to_str(v7, v7_array_get(v7, this_obj, i), buf, sizeof(buf), 0);
      if (n > (long) sizeof(buf)) {
        p = (char *) malloc(n + 1);
        to_str(v7, v7_array_get(v7, this_obj, i), p, n, 0);
      }
      mbuf_append(&m, p, n);
      if (p != buf) {
        free(p);
      }
    }

    /* mbuf contains concatenated string now. Copy it to the result. */
    res = v7_create_string(v7, m.buf, m.len, 1);
    mbuf_free(&m);
  }

  return res;
}

static val_t Array_toString(struct v7 *v7, val_t this_obj, val_t args) {
  return Array_join(v7, this_obj, args);
}

static val_t a_splice(struct v7 *v7, val_t this_obj, val_t args, int mutate) {
  val_t res = v7_create_dense_array(v7);
  long i, len = v7_array_length(v7, this_obj);
  long num_args = v7_array_length(v7, args);
  long elems_to_insert = num_args > 2 ? num_args - 2 : 0;
  long arg0 = arg_long(v7, args, 0, 0);
  long arg1 = arg_long(v7, args, 1, len);

  /* Bounds check */
  if (len <= 0) return res;
  if (arg0 < 0) arg0 = len + arg0;
  if (arg0 < 0) arg0 = 0;
  if (arg0 > len) arg0 = len;
  if (mutate) {
    if (arg1 < 0) arg1 = 0;
    arg1 += arg0;
  } else if (arg1 < 0) {
    arg1 = len + arg1;
  }

  /* Create return value - slice */
  for (i = arg0; i < arg1 && i < len; i++) {
    v7_array_push(v7, res, v7_array_get(v7, this_obj, i));
  }

  if (mutate && v7_to_object(this_obj)->attributes & V7_OBJ_DENSE_ARRAY) {
    /*
     * dense arrays are spliced by memmoving leaving the trailing
     * space allocated for future appends.
     * TODO(mkm): figure out if trimming is better
     */
    struct v7_property *p =
        v7_get_own_property2(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN);
    struct mbuf *abuf;
    if (p == NULL) return res;
    abuf = (struct mbuf *) v7_to_foreign(p->value);
    if (abuf == NULL) return res;

    memmove(abuf->buf + arg0 * sizeof(val_t), abuf->buf + arg1 * sizeof(val_t),
            (len - arg1) * sizeof(val_t));
    abuf->len -= (arg1 - arg0) * sizeof(val_t);
  } else if (mutate) {
    /* If splicing, modify this_obj array: remove spliced sub-array */
    struct v7_property **p, **next;
    long i;

    for (p = &v7_to_object(this_obj)->properties; *p != NULL; p = next) {
      size_t n;
      const char *s = v7_to_string(v7, &p[0]->name, &n);
      next = &p[0]->next;
      i = strtol(s, NULL, 10);
      if (i >= arg0 && i < arg1) {
        /* Remove items from spliced sub-array */
        v7_destroy_property(p);
        *p = *next;
        next = p;
      } else if (i >= arg1) {
        /* Modify indices of the elements past sub-array */
        char key[20];
        size_t n = c_snprintf(key, sizeof(key), "%ld",
                              i - (arg1 - arg0) + elems_to_insert);
        p[0]->name = v7_create_string(v7, key, n, 1);
      }
    }

    /* Insert optional extra elements */
    for (i = 2; i < num_args; i++) {
      char key[20];
      size_t n = c_snprintf(key, sizeof(key), "%ld", arg0 + i - 2);
      v7_set(v7, this_obj, key, n, 0, v7_array_get(v7, args, i));
    }
  }

  return res;
}

static val_t Array_slice(struct v7 *v7, val_t this_obj, val_t args) {
  return a_splice(v7, this_obj, args, 0);
}

static val_t Array_splice(struct v7 *v7, val_t this_obj, val_t args) {
  return a_splice(v7, this_obj, args, 1);
}

static void a_prep1(struct v7 *v7, val_t t, val_t args, val_t *a0, val_t *a1) {
  *a0 = v7_array_get(v7, args, 0);
  *a1 = v7_array_get(v7, args, 1);
  if (v7_is_undefined(*a1)) {
    *a1 = t;
  }
}

static val_t a_prep2(struct v7 *v7, val_t a, val_t v, val_t n, val_t t) {
  val_t params = v7_create_dense_array(v7);
  v7_array_push(v7, params, v);
  v7_array_push(v7, params, n);
  v7_array_push(v7, params, t);
  return v7_apply(v7, a, t, params);
}

static val_t Array_map(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0, arg1, el, v, res = v7_create_undefined();
  unsigned long len, i;
  int has;

  if (!v7_is_object(this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Array expected");
  } else {
    a_prep1(v7, this_obj, args, &arg0, &arg1);
    res = v7_create_dense_array(v7);
    len = v7_array_length(v7, this_obj);
    for (i = 0; i < len; i++) {
      v = v7_array_get2(v7, this_obj, i, &has);
      if (!has) continue;
      el = a_prep2(v7, arg0, v, v7_create_number(i), arg1);
      v7_array_set(v7, res, i, el);
    }
  }

  return res;
}

static val_t Array_every(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0, arg1, el, v;
  unsigned long i, len;
  int has;

  if (!v7_is_object(this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Array expected");
  } else {
    a_prep1(v7, this_obj, args, &arg0, &arg1);

    len = v7_array_length(v7, this_obj);
    for (i = 0; i < len; i++) {
      v = v7_array_get2(v7, this_obj, i, &has);
      if (!has) continue;
      el = a_prep2(v7, arg0, v, v7_create_number(i), arg1);
      if (!v7_is_true(v7, el)) {
        return v7_create_boolean(0);
      }
    }
  }
  return v7_create_boolean(1);
}

static val_t Array_some(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0, arg1, el, v;
  unsigned long i, len;
  int has;

  if (!v7_is_object(this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Array expected");
  } else {
    a_prep1(v7, this_obj, args, &arg0, &arg1);

    len = v7_array_length(v7, this_obj);
    for (i = 0; i < len; i++) {
      v = v7_array_get2(v7, this_obj, i, &has);
      if (!has) continue;
      el = a_prep2(v7, arg0, v, v7_create_number(i), arg1);
      if (v7_is_true(v7, el)) {
        return v7_create_boolean(1);
      }
    }
  }
  return v7_create_boolean(0);
}

static val_t Array_filter(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0, arg1, el, v, res = v7_create_undefined();
  unsigned long len, i;
  int has;

  if (!v7_is_object(this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Array expected");
  } else {
    a_prep1(v7, this_obj, args, &arg0, &arg1);
    res = v7_create_dense_array(v7);
    len = v7_array_length(v7, this_obj);
    for (i = 0; i < len; i++) {
      v = v7_array_get2(v7, this_obj, i, &has);
      if (!has) continue;
      el = a_prep2(v7, arg0, v, v7_create_number(i), arg1);
      if (v7_is_true(v7, el)) {
        v7_array_push(v7, res, v);
      }
    }
  }
  return res;
}

static val_t Array_concat(struct v7 *v7, val_t this_obj, val_t args) {
  size_t i, j;
  val_t res;
  size_t len;
  struct gc_tmp_frame tf = new_tmp_frame(v7);
  tmp_stack_push(&tf, &res);

  if (!v7_is_array(v7, this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Array expected");
  }

  len = v7_array_length(v7, args);
  res = a_splice(v7, this_obj, v7_create_undefined(), 1);
  for (i = 0; i < len; i++) {
    val_t a = v7_array_get(v7, args, i);
    if (!v7_is_array(v7, a)) {
      v7_array_push(v7, res, a);
    } else {
      size_t alen = v7_array_length(v7, a);
      for (j = 0; j < alen; j++) {
        v7_array_push(v7, res, v7_array_get(v7, a, j));
      }
    }
  }
  return res;
}

static val_t Array_isArray(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_get(v7, args, 0);
  (void) this_obj;
  return v7_create_boolean(v7_is_array(v7, arg0));
}

V7_PRIVATE void init_array(struct v7 *v7) {
  val_t ctor = v7_create_function(v7, Array_ctor, 1);
  val_t length = v7_create_dense_array(v7);

  v7_set_property(v7, ctor, "prototype", 9, 0, v7->array_prototype);
  set_method(v7, ctor, "isArray", Array_isArray, 1);
  v7_set_property(v7, v7->global_object, "Array", 5, 0, ctor);

  set_method(v7, v7->array_prototype, "concat", Array_concat, 1);
  set_method(v7, v7->array_prototype, "every", Array_every, 1);
  set_method(v7, v7->array_prototype, "filter", Array_filter, 1);
  set_method(v7, v7->array_prototype, "join", Array_join, 1);
  set_method(v7, v7->array_prototype, "map", Array_map, 1);
  set_method(v7, v7->array_prototype, "push", Array_push, 1);
  set_method(v7, v7->array_prototype, "reverse", Array_reverse, 0);
  set_method(v7, v7->array_prototype, "slice", Array_slice, 2);
  set_method(v7, v7->array_prototype, "some", Array_some, 1);
  set_method(v7, v7->array_prototype, "sort", Array_sort, 1);
  set_method(v7, v7->array_prototype, "splice", Array_splice, 2);
  set_method(v7, v7->array_prototype, "toString", Array_toString, 0);

  v7_array_set(v7, length, 0, v7_create_cfunction(Array_get_length));
  v7_array_set(v7, length, 1, v7_create_cfunction(Array_set_length));
  v7_set_property(v7, v7->array_prototype, "length", 6,
                  V7_PROPERTY_GETTER | V7_PROPERTY_SETTER, length);
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


V7_PRIVATE val_t Boolean_ctor(struct v7 *v7, val_t this_obj, val_t args) {
  val_t v = v7_create_boolean(0); /* false by default */

  if (v7_is_true(v7, v7_array_get(v7, args, 0))) {
    v = v7_create_boolean(1);
  }

  if (v7_is_object(this_obj) && this_obj != v7->global_object) {
    /* called as "new Boolean(...)" */
    v7_to_object(this_obj)->prototype = v7_to_object(v7->boolean_prototype);
    v7_set_property(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN, v);
    v = this_obj;
  }

  return v;
}

static val_t Boolean_valueOf(struct v7 *v7, val_t this_obj, val_t args) {
  if (!v7_is_boolean(this_obj) &&
      (v7_is_object(this_obj) &&
       v7_object_to_value(v7_to_object(this_obj)->prototype) !=
           v7->boolean_prototype)) {
    throw_exception(v7, TYPE_ERROR,
                    "Boolean.valueOf called on non-boolean object");
  }
  return Obj_valueOf(v7, this_obj, args);
}

static val_t Boolean_toString(struct v7 *v7, val_t this_obj, val_t args) {
  char buf[50];
  (void) args;

  if (this_obj == v7->boolean_prototype) {
    return v7_create_string(v7, "false", 5, 1);
  }

  if (!v7_is_boolean(this_obj) &&
      !(v7_is_object(this_obj) &&
        is_prototype_of(v7, this_obj, v7->boolean_prototype))) {
    throw_exception(v7, TYPE_ERROR,
                    "Boolean.toString called on non-boolean object");
  }

  v7_stringify_value(v7, i_value_of(v7, this_obj), buf, sizeof(buf));
  return v7_create_string(v7, buf, strlen(buf), 1);
}

V7_PRIVATE void init_boolean(struct v7 *v7) {
  val_t ctor =
      v7_create_constructor(v7, v7->boolean_prototype, Boolean_ctor, 1);
  v7_set_property(v7, v7->global_object, "Boolean", 7, 0, ctor);

  set_cfunc_prop(v7, v7->boolean_prototype, "valueOf", Boolean_valueOf);
  set_cfunc_prop(v7, v7->boolean_prototype, "toString", Boolean_toString);
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#if V7_ENABLE__Math

#ifdef __WATCOM__
int matherr(struct _exception *exc) {
  if (exc->type == DOMAIN) {
    exc->retval = NAN;
    return 0;
  }
}
#endif

#if V7_ENABLE__Math__abs || V7_ENABLE__Math__acos || V7_ENABLE__Math__asin ||  \
    V7_ENABLE__Math__atan || V7_ENABLE__Math__ceil || V7_ENABLE__Math__cos ||  \
    V7_ENABLE__Math__exp || V7_ENABLE__Math__floor || V7_ENABLE__Math__log ||  \
    V7_ENABLE__Math__round || V7_ENABLE__Math__sin || V7_ENABLE__Math__sqrt || \
    V7_ENABLE__Math__tan
static val_t m_one_arg(struct v7 *v7, val_t args, double (*f)(double)) {
  val_t arg0 = v7_array_get(v7, args, 0);
  double d0 = v7_to_number(arg0);
#ifdef V7_BROKEN_NAN
  if (isnan(d0)) return V7_TAG_NAN;
#endif
  return v7_create_number(f(d0));
}
#endif /* V7_ENABLE__Math__* */

#if V7_ENABLE__Math__pow || V7_ENABLE__Math__atan2
static val_t m_two_arg(struct v7 *v7, val_t args, double (*f)(double, double)) {
  val_t arg0 = v7_array_get(v7, args, 0);
  val_t arg1 = v7_array_get(v7, args, 1);
  double d0 = v7_to_number(arg0);
  double d1 = v7_to_number(arg1);
#ifdef V7_BROKEN_NAN
  /* pow(NaN,0) == 1, doesn't fix atan2, but who cares */
  if (isnan(d1)) return V7_TAG_NAN;
#endif
  return v7_create_number(f(d0, d1));
}
#endif /* V7_ENABLE__Math__pow || V7_ENABLE__Math__atan2 */

#define DEFINE_WRAPPER(name, func)                                          \
  V7_PRIVATE val_t Math_##name(struct v7 *v7, val_t this_obj, val_t args) { \
    (void) this_obj;                                                        \
    return func(v7, args, name);                                            \
  }

/* Visual studio 2012+ has round() */
#if V7_ENABLE__Math__round && \
    ((defined(V7_WINDOWS) && _MSC_VER < 1700) || defined(__WATCOM__))
static double round(double n) {
  return n;
}
#endif

#if V7_ENABLE__Math__abs
DEFINE_WRAPPER(fabs, m_one_arg)
#endif
#if V7_ENABLE__Math__acos
DEFINE_WRAPPER(acos, m_one_arg)
#endif
#if V7_ENABLE__Math__asin
DEFINE_WRAPPER(asin, m_one_arg)
#endif
#if V7_ENABLE__Math__atan
DEFINE_WRAPPER(atan, m_one_arg)
#endif
#if V7_ENABLE__Math__atan2
DEFINE_WRAPPER(atan2, m_two_arg)
#endif
#if V7_ENABLE__Math__ceil
DEFINE_WRAPPER(ceil, m_one_arg)
#endif
#if V7_ENABLE__Math__cos
DEFINE_WRAPPER(cos, m_one_arg)
#endif
#if V7_ENABLE__Math__exp
DEFINE_WRAPPER(exp, m_one_arg)
#endif
#if V7_ENABLE__Math__floor
DEFINE_WRAPPER(floor, m_one_arg)
#endif
#if V7_ENABLE__Math__log
DEFINE_WRAPPER(log, m_one_arg)
#endif
#if V7_ENABLE__Math__pow
DEFINE_WRAPPER(pow, m_two_arg)
#endif
#if V7_ENABLE__Math__round
DEFINE_WRAPPER(round, m_one_arg)
#endif
#if V7_ENABLE__Math__sin
DEFINE_WRAPPER(sin, m_one_arg)
#endif
#if V7_ENABLE__Math__sqrt
DEFINE_WRAPPER(sqrt, m_one_arg)
#endif
#if V7_ENABLE__Math__tan
DEFINE_WRAPPER(tan, m_one_arg)
#endif

#if V7_ENABLE__Math__random
V7_PRIVATE val_t Math_random(struct v7 *v7, val_t this_obj, val_t args) {
  static int srand_called = 0;

  if (!srand_called) {
    srand((unsigned) (unsigned long) v7);
    srand_called++;
  }

  (void) this_obj;
  (void) args;
  return v7_create_number((double) rand() / RAND_MAX);
}
#endif /* V7_ENABLE__Math__random */

#if V7_ENABLE__Math__min || V7_ENABLE__Math__max
static val_t min_max(struct v7 *v7, val_t args, int is_min) {
  double res = NAN;
  int i, len = v7_array_length(v7, args);

  for (i = 0; i < len; i++) {
    double v = v7_to_number(v7_array_get(v7, args, i));
    if (isnan(res) || (is_min && v < res) || (!is_min && v > res)) {
      res = v;
    }
  }

  return v7_create_number(res);
}
#endif /* V7_ENABLE__Math__min || V7_ENABLE__Math__max */

#if V7_ENABLE__Math__min
V7_PRIVATE val_t Math_min(struct v7 *v7, val_t this_obj, val_t args) {
  (void) this_obj;
  return min_max(v7, args, 1);
}
#endif

#if V7_ENABLE__Math__max
V7_PRIVATE val_t Math_max(struct v7 *v7, val_t this_obj, val_t args) {
  (void) this_obj;
  return min_max(v7, args, 0);
}
#endif

V7_PRIVATE void init_math(struct v7 *v7) {
  val_t math = v7_create_object(v7);

#if V7_ENABLE__Math__abs
  set_cfunc_prop(v7, math, "abs", Math_fabs);
#endif
#if V7_ENABLE__Math__acos
  set_cfunc_prop(v7, math, "acos", Math_acos);
#endif
#if V7_ENABLE__Math__asin
  set_cfunc_prop(v7, math, "asin", Math_asin);
#endif
#if V7_ENABLE__Math__atan
  set_cfunc_prop(v7, math, "atan", Math_atan);
#endif
#if V7_ENABLE__Math__atan2
  set_cfunc_prop(v7, math, "atan2", Math_atan2);
#endif
#if V7_ENABLE__Math__ceil
  set_cfunc_prop(v7, math, "ceil", Math_ceil);
#endif
#if V7_ENABLE__Math__cos
  set_cfunc_prop(v7, math, "cos", Math_cos);
#endif
#if V7_ENABLE__Math__exp
  set_cfunc_prop(v7, math, "exp", Math_exp);
#endif
#if V7_ENABLE__Math__floor
  set_cfunc_prop(v7, math, "floor", Math_floor);
#endif
#if V7_ENABLE__Math__log
  set_cfunc_prop(v7, math, "log", Math_log);
#endif
#if V7_ENABLE__Math__max
  set_cfunc_prop(v7, math, "max", Math_max);
#endif
#if V7_ENABLE__Math__min
  set_cfunc_prop(v7, math, "min", Math_min);
#endif
#if V7_ENABLE__Math__pow
  set_cfunc_prop(v7, math, "pow", Math_pow);
#endif
#if V7_ENABLE__Math__random
  set_cfunc_prop(v7, math, "random", Math_random);
#endif
#if V7_ENABLE__Math__round
  set_cfunc_prop(v7, math, "round", Math_round);
#endif
#if V7_ENABLE__Math__sin
  set_cfunc_prop(v7, math, "sin", Math_sin);
#endif
#if V7_ENABLE__Math__sqrt
  set_cfunc_prop(v7, math, "sqrt", Math_sqrt);
#endif
#if V7_ENABLE__Math__tan
  set_cfunc_prop(v7, math, "tan", Math_tan);
#endif

#if V7_ENABLE__Math__constants
  v7_set_property(v7, math, "E", 1, 0, v7_create_number(M_E));
  v7_set_property(v7, math, "PI", 2, 0, v7_create_number(M_PI));
  v7_set_property(v7, math, "LN2", 3, 0, v7_create_number(M_LN2));
  v7_set_property(v7, math, "LN10", 4, 0, v7_create_number(M_LN10));
  v7_set_property(v7, math, "LOG2E", 5, 0, v7_create_number(M_LOG2E));
  v7_set_property(v7, math, "LOG10E", 6, 0, v7_create_number(M_LOG10E));
  v7_set_property(v7, math, "SQRT1_2", 7, 0, v7_create_number(M_SQRT1_2));
  v7_set_property(v7, math, "SQRT2", 5, 0, v7_create_number(M_SQRT2));
#endif

  v7_set_property(v7, v7->global_object, "Math", 4, 0, math);
}

#endif /* V7_ENABLE__Math */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


V7_PRIVATE val_t to_string(struct v7 *, val_t);

static val_t String_ctor(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = v7_array_get(v7, args, 0), res = arg0;

  if (v7_array_length(v7, args) == 0)
    res = v7_create_string(v7, NULL, 0, 1);
  else if (!v7_is_string(arg0))
    res = to_string(v7, arg0);

  if (v7_is_object(this_obj) && this_obj != v7->global_object) {
    v7_to_object(this_obj)->prototype = v7_to_object(v7->string_prototype);
    v7_set_property(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN, res);
    return this_obj;
  }

  return res;
}

static val_t Str_fromCharCode(struct v7 *v7, val_t this_obj, val_t args) {
  int i, num_args = v7_array_length(v7, args);
  val_t res = v7_create_string(v7, "", 0, 1); /* Empty string */

  (void) this_obj;
  for (i = 0; i < num_args; i++) {
    char buf[10];
    val_t arg = v7_array_get(v7, args, i);
    double d = v7_to_number(arg);
    Rune r = (Rune)((int32_t)(isnan(d) || isinf(d) ? 0 : d) & 0xffff);
    int n = runetochar(buf, &r);
    val_t s = v7_create_string(v7, buf, n, 1);
    res = s_concat(v7, res, s);
  }

  return res;
}

V7_PRIVATE double v7_char_code_at(struct v7 *v7, val_t this_obj, val_t arg) {
  size_t n;
  val_t s = to_string(v7, this_obj);
  const char *p = v7_to_string(v7, &s, &n);
  double at = v7_to_number(arg);

  n = utfnlen((char *) p, n);
  if (v7_is_number(arg) && at >= 0 && at < n) {
    Rune r = 0;
    p = utfnshift((char *) p, at);
    chartorune(&r, (char *) p);
    return r;
  }
  return NAN;
}

static double s_charCodeAt(struct v7 *v7, val_t this_obj, val_t args) {
  return v7_char_code_at(v7, this_obj, v7_array_get(v7, args, 0));
}

static val_t Str_charCodeAt(struct v7 *v7, val_t this_obj, val_t args) {
  return v7_create_number(s_charCodeAt(v7, this_obj, args));
}

static val_t Str_charAt(struct v7 *v7, val_t this_obj, val_t args) {
  double code = s_charCodeAt(v7, this_obj, args);
  char buf[10] = {0};
  int len = 0;

  if (!isnan(code)) {
    Rune r = (Rune) code;
    len = runetochar(buf, &r);
  }
  return v7_create_string(v7, buf, len, 1);
}

static val_t Str_concat(struct v7 *v7, val_t this_obj, val_t args) {
  val_t res = to_string(v7, this_obj);
  int i, num_args = v7_array_length(v7, args);

  for (i = 0; i < num_args; i++) {
    val_t str = to_string(v7, v7_array_get(v7, args, i));
    res = s_concat(v7, res, str);
  }

  return res;
}

static val_t s_index_of(struct v7 *v7, val_t this_obj, val_t args, int last) {
  val_t arg0 = v7_array_get(v7, args, 0);
  size_t fromIndex = 0;
  double res = -1;

  if (!v7_is_undefined(arg0)) {
    const char *p1, *p2, *end;
    size_t i, n1, n2;
    val_t sub = to_string(v7, arg0);
    this_obj = to_string(v7, this_obj);
    p1 = v7_to_string(v7, &this_obj, &n1);
    p2 = v7_to_string(v7, &sub, &n2);

    if (n2 <= n1) {
      end = p1 + n1;
      n1 = utfnlen((char *) p1, n1);
      if (v7_array_length(v7, args) > 1) {
        double d = i_as_num(v7, v7_array_get(v7, args, 1));
        if (isnan(d) || d < 0) {
          d = 0.0;
        } else if (isinf(d)) {
          d = n1;
        }
        fromIndex = d;
      }
      if (fromIndex > 0) {
        if (fromIndex >= n1) return v7_create_number(-1);
        if (last)
          end = utfnshift((char *) p1, fromIndex + 1);
        else
          p1 = utfnshift((char *) p1, fromIndex);
      }
      if (!last || fromIndex != 0) {
        if (0 == n2 || end - p1 == 0)
          res = 0;
        else {
          for (i = 0; p1 <= (end - n2); i++, p1 = utfnshift((char *) p1, 1))
            if (memcmp(p1, p2, n2) == 0) {
              res = i;
              if (!last) break;
            }
        }
      }
    }
  }
  if (!last && res >= 0) res += fromIndex;
  return v7_create_number(res);
}

static val_t Str_valueOf(struct v7 *v7, val_t this_obj, val_t args) {
  if (!v7_is_string(this_obj) &&
      (v7_is_object(this_obj) &&
       v7_object_to_value(v7_to_object(this_obj)->prototype) !=
           v7->string_prototype)) {
    throw_exception(v7, TYPE_ERROR,
                    "String.valueOf called on non-string object");
  }
  return Obj_valueOf(v7, this_obj, args);
}

static val_t Str_indexOf(struct v7 *v7, val_t this_obj, val_t args) {
  return s_index_of(v7, this_obj, args, 0);
}

static val_t Str_lastIndexOf(struct v7 *v7, val_t this_obj, val_t args) {
  return s_index_of(v7, this_obj, args, 1);
}

#if V7_ENABLE__String__localeCompare
static val_t Str_localeCompare(struct v7 *v7, val_t this_obj, val_t args) {
  val_t arg0 = to_string(v7, v7_array_get(v7, args, 0));
  val_t s = to_string(v7, this_obj);
  return v7_create_number(s_cmp(v7, s, arg0));
}
#endif

static val_t Str_toString(struct v7 *v7, val_t this_obj, val_t args) {
  (void) args;

  if (this_obj == v7->string_prototype) {
    return v7_create_string(v7, "false", 5, 1);
  }

  if (!v7_is_string(this_obj) &&
      !(v7_is_object(this_obj) &&
        is_prototype_of(v7, this_obj, v7->string_prototype))) {
    throw_exception(v7, TYPE_ERROR,
                    "String.toString called on non-string object");
  }

  return to_string(v7, i_value_of(v7, this_obj));
}

#if V7_ENABLE__RegExp
static val_t Str_match(struct v7 *v7, val_t this_obj, val_t args) {
  val_t so, ro, arr = v7_create_null();
  long previousLastIndex = 0;
  int lastMatch = 1, n = 0, flag_g;
  struct v7_regexp *rxp;

  so = to_string(v7, this_obj);
  if (v7_array_length(v7, args) == 0)
    ro = v7_create_regexp(v7, "", 0, "", 0);
  else
    ro = i_value_of(v7, v7_array_get(v7, args, 0));
  if (!v7_is_regexp(v7, ro)) {
    val_t arg = v7_create_dense_array(v7);
    v7_array_push(v7, arg, ro);
    ro = Regex_ctor(v7, v7_create_null(), arg);
  }

  rxp = v7_to_regexp(v7, ro);
  flag_g = slre_get_flags(rxp->compiled_regexp) & SLRE_FLAG_G;
  if (!flag_g) return rx_exec(v7, ro, so, 0);

  rxp->lastIndex = 0;
  arr = v7_create_dense_array(v7);
  v7_own(v7, &arr);
  while (lastMatch) {
    val_t result = rx_exec(v7, ro, so, 1);
    if (v7_is_null(result))
      lastMatch = 0;
    else {
      long thisIndex = rxp->lastIndex;
      if (thisIndex == previousLastIndex) {
        previousLastIndex = thisIndex + 1;
        rxp->lastIndex = previousLastIndex;
      } else
        previousLastIndex = thisIndex;
      v7_array_push(v7, arr, v7_array_get(v7, result, 0));
      n++;
    }
  }
  v7_disown(v7, &arr);
  if (n == 0) return v7_create_null();
  return arr;
}

static val_t Str_replace(struct v7 *v7, val_t this_obj, val_t args) {
  const char *s;
  size_t s_len;
  val_t out_str_o;
  char *old_owned_mbuf_base = v7->owned_strings.buf;
  char *old_owned_mbuf_end = v7->owned_strings.buf + v7->owned_strings.len;
  this_obj = to_string(v7, this_obj);
  s = v7_to_string(v7, &this_obj, &s_len);

  if (s_len != 0 && v7_array_length(v7, args) > 1) {
    const char *const str_end = s + s_len;
    char *p = (char *) s;
    uint32_t out_sub_num = 0;
    val_t ro = i_value_of(v7, v7_array_get(v7, args, 0)),
          str_func = i_value_of(v7, v7_array_get(v7, args, 1));
    struct slre_prog *prog;
    struct slre_cap out_sub[V7_RE_MAX_REPL_SUB], *ptok = out_sub;
    struct slre_loot loot;
    int flag_g;

    if (!v7_is_regexp(v7, ro)) {
      val_t arg = v7_create_dense_array(v7);
      v7_array_push(v7, arg, ro);
      ro = Regex_ctor(v7, v7_create_null(), arg);
    }
    prog = v7_to_regexp(v7, ro)->compiled_regexp;
    flag_g = slre_get_flags(prog) & SLRE_FLAG_G;

    if (!v7_is_function(str_func)) str_func = to_string(v7, str_func);

    do {
      int i;
      if (slre_exec(prog, 0, p, str_end, &loot)) break;
      if (p != loot.caps->start) {
        ptok->start = p;
        ptok->end = loot.caps->start;
        ptok++;
        out_sub_num++;
      }

      if (v7_is_function(str_func)) { /* replace function */
        const char *rez_str;
        size_t rez_len;
        val_t arr = v7_create_dense_array(v7);

        for (i = 0; i < loot.num_captures; i++) {
          v7_array_push(v7, arr, v7_create_string(
                                     v7, loot.caps[i].start,
                                     loot.caps[i].end - loot.caps[i].start, 1));
        }
        v7_array_push(v7, arr, v7_create_number(utfnlen(
                                   (char *) s, loot.caps[0].start - s)));
        v7_array_push(v7, arr, this_obj);
        out_str_o = to_string(v7, v7_apply(v7, str_func, this_obj, arr));
        rez_str = v7_to_string(v7, &out_str_o, &rez_len);
        if (rez_len) {
          ptok->start = rez_str;
          ptok->end = rez_str + rez_len;
          ptok++;
          out_sub_num++;
        }
      } else { /* replace string */
        struct slre_loot newsub;
        size_t f_len;
        const char *f_str = v7_to_string(v7, &str_func, &f_len);
        slre_replace(&loot, s, s_len, f_str, f_len, &newsub);
        for (i = 0; i < newsub.num_captures; i++) {
          ptok->start = newsub.caps[i].start;
          ptok->end = newsub.caps[i].end;
          ptok++;
          out_sub_num++;
        }
      }
      p = (char *) loot.caps[0].end;
    } while (flag_g && p < str_end);
    if (p < str_end) {
      ptok->start = p;
      ptok->end = str_end;
      ptok++;
      out_sub_num++;
    }
    out_str_o = v7_create_string(v7, NULL, 0, 1);
    ptok = out_sub;
    do {
      size_t ln = ptok->end - ptok->start;
      const char *ps = ptok->start;
      if (ptok->start >= old_owned_mbuf_base &&
          ptok->start < old_owned_mbuf_end) {
        ps += v7->owned_strings.buf - old_owned_mbuf_base;
      }
      out_str_o = s_concat(v7, out_str_o, v7_create_string(v7, ps, ln, 1));
      p += ln;
      ptok++;
    } while (--out_sub_num);

    return out_str_o;
  }
  /* return v7_create_string(v7, s, s_len, 1); */
  return this_obj;
}

static val_t Str_search(struct v7 *v7, val_t this_obj, val_t args) {
  long utf_shift = -1;

  if (v7_array_length(v7, args) > 0) {
    size_t s_len;
    struct slre_loot sub;
    val_t so, ro = i_value_of(v7, v7_array_get(v7, args, 0));
    const char *s;
    if (!v7_is_regexp(v7, ro)) {
      val_t arg = v7_create_dense_array(v7);
      v7_array_push(v7, arg, ro);
      ro = Regex_ctor(v7, v7_create_null(), arg);
    }

    so = to_string(v7, this_obj);
    s = v7_to_string(v7, &so, &s_len);

    if (!slre_exec(v7_to_regexp(v7, ro)->compiled_regexp, 0, s, s + s_len,
                   &sub))
      utf_shift =
          utfnlen((char *) s, sub.caps[0].start - s); /* calc shift for UTF-8 */
  } else
    utf_shift = 0;
  return v7_create_number(utf_shift);
}

#endif /* V7_ENABLE__RegExp */

static val_t Str_slice(struct v7 *v7, val_t this_obj, val_t args) {
  long from = 0, to = 0;
  size_t len;
  val_t so = to_string(v7, this_obj);
  const char *begin = v7_to_string(v7, &so, &len), *end;
  int num_args = v7_array_length(v7, args);

  to = len = utfnlen((char *) begin, len);
  if (num_args > 0) {
    from = arg_long(v7, args, 0, 0);
    if (from < 0) {
      from += len;
      if (from < 0) from = 0;
    } else if ((size_t) from > len)
      from = len;
    if (num_args > 1) {
      to = arg_long(v7, args, 1, 0);
      if (to < 0) {
        to += len;
        if (to < 0) to = 0;
      } else if ((size_t) to > len)
        to = len;
    }
  }
  if (from > to) to = from;
  end = utfnshift((char *) begin, to);
  begin = utfnshift((char *) begin, from);
  return v7_create_string(v7, begin, end - begin, 1);
}

static val_t s_transform(struct v7 *v7, val_t this_obj, val_t args,
                         Rune (*func)(Rune)) {
  val_t s = to_string(v7, this_obj);
  size_t i, n, len;
  const char *p = v7_to_string(v7, &s, &len);
  val_t res = v7_create_string(v7, p, len, 1);
  Rune r;

  (void) args;

  p = v7_to_string(v7, &res, &len);
  for (i = 0; i < len; i += n) {
    n = chartorune(&r, p + i);
    r = func(r);
    runetochar((char *) p + i, &r);
  }

  return res;
}

static val_t Str_toLowerCase(struct v7 *v7, val_t this_obj, val_t args) {
  return s_transform(v7, this_obj, args, tolowerrune);
}

static val_t Str_toUpperCase(struct v7 *v7, val_t this_obj, val_t args) {
  return s_transform(v7, this_obj, args, toupperrune);
}

static int s_isspace(Rune c) {
  return isspacerune(c) || isnewline(c);
}

static val_t Str_trim(struct v7 *v7, val_t this_obj, val_t args) {
  val_t s = to_string(v7, this_obj);
  size_t i, n, len, start = 0, end, state = 0;
  const char *p = v7_to_string(v7, &s, &len);
  Rune r;

  (void) args;
  end = len;
  for (i = 0; i < len; i += n) {
    n = chartorune(&r, p + i);
    if (!s_isspace(r)) {
      if (state++ == 0) start = i;
      end = i + n;
    }
  }

  return v7_create_string(v7, p + start, end - start, 1);
}

static val_t Str_length(struct v7 *v7, val_t this_obj, val_t args) {
  size_t len = 0;
  val_t s = i_value_of(v7, this_obj);

  (void) args;
  if (v7_is_string(s)) {
    const char *p = v7_to_string(v7, &s, &len);
    len = utfnlen((char *) p, len);
  }

  return v7_create_number(len);
}

static val_t Str_at(struct v7 *v7, val_t this_obj, val_t args) {
  long arg0 = arg_long(v7, args, 0, -1);
  val_t s = i_value_of(v7, this_obj);

  if (v7_is_string(s)) {
    size_t n;
    const unsigned char *p = (unsigned char *) v7_to_string(v7, &s, &n);
    if (arg0 >= 0 && (size_t) arg0 < n) {
      return v7_create_number(p[arg0]);
    }
  }

  return v7_create_number(NAN);
}

static val_t Str_blen(struct v7 *v7, val_t this_obj, val_t args) {
  size_t len = 0;
  val_t s = i_value_of(v7, this_obj);
  (void) args;
  if (v7_is_string(s)) {
    v7_to_string(v7, &s, &len);
  }
  return v7_create_number(len);
}

V7_PRIVATE long to_long(struct v7 *v7, val_t v, long default_value) {
  char buf[40];
  size_t l;
  double d;
  if (v7_is_number(v)) {
    d = v7_to_number(v);
    /* We want to return LONG_MAX if d is positive Inf, thus d < 0 check */
    if (isnan(d) || (isinf(d) && d < 0)) {
      return 0;
    } else if (d > LONG_MAX) {
      return LONG_MAX;
    }
    return (long) d;
  }
  if (v7_is_null(v)) return 0;
  l = to_str(v7, v, buf, sizeof(buf), 0);
  if (l > 0 && isdigit(buf[0])) return strtol(buf, NULL, 10);
  return default_value;
}

#if 0
/*
 * Conforms to ECMA 5.1, chapter 9.3
 * TODO(lsm): replace to_long() with to_number()
 */
V7_PRIVATE double to_number(struct v7 *v7, val_t v) {
  if (v7_is_undefined(v)) {
    return NAN;
  } else if (v7_is_null(v)) {
    return +0;
  } else if (v7_is_boolean(v)) {
    return v7_to_boolean(v);
  } else if (v7_is_number(v)) {
    return v7_to_number(v);
  } else if (v7_is_string(v)) {
    /* TODO(lsm): implement */
  } else {
    /* TODO(lsm): implement */
    val_t vo = i_value_of(v7, v);
    return 0;
  }
}
#endif

V7_PRIVATE long arg_long(struct v7 *v7, val_t args, int n, long default_value) {
  val_t arg_n = i_value_of(v7, v7_array_get(v7, args, n));
  return to_long(v7, arg_n, default_value);
}

static val_t s_substr(struct v7 *v7, val_t s, long start, long len) {
  size_t n;
  const char *p;
  s = to_string(v7, s);
  p = v7_to_string(v7, &s, &n);
  n = utfnlen((char *) p, n);

  if (start < (long) n && len > 0) {
    if (start < 0) start = (long) n + start;
    if (start < 0) start = 0;

    if (start > (long) n) start = n;
    if (len < 0) len = 0;
    if (len > (long) n - start) len = n - start;
    p = utfnshift((char *) p, start);
  } else
    len = 0;

  return v7_create_string(v7, p, len, 1);
}

static val_t Str_substr(struct v7 *v7, val_t this_obj, val_t args) {
  long start = arg_long(v7, args, 0, 0);
  long len = arg_long(v7, args, 1, LONG_MAX);
  return s_substr(v7, this_obj, start, len);
}

static val_t Str_substring(struct v7 *v7, val_t this_obj, val_t args) {
  long start = arg_long(v7, args, 0, 0);
  long end = arg_long(v7, args, 1, LONG_MAX);
  if (start < 0) start = 0;
  if (end < 0) end = 0;
  if (start > end) {
    long tmp = start;
    start = end;
    end = tmp;
  }
  return s_substr(v7, this_obj, start, end - start);
}

/* TODO(mkm): make an alternative implementation without regexps */
#if V7_ENABLE__RegExp
static val_t Str_split(struct v7 *v7, val_t this_obj, val_t args) {
  val_t res = v7_create_dense_array(v7);
  const char *s, *s_end;
  size_t s_len;
  long num_args = v7_array_length(v7, args);
  struct slre_prog *prog = NULL;
  this_obj = to_string(v7, this_obj);
  s = v7_to_string(v7, &this_obj, &s_len);
  s_end = s + s_len;

  if (num_args == 0 || s_len == 0) {
    v7_array_push(v7, res, this_obj);
  } else {
    val_t ro = i_value_of(v7, v7_array_get(v7, args, 0));
    long len, elem = 0, limit = arg_long(v7, args, 1, LONG_MAX);
    size_t shift = 0;
    struct slre_loot loot;
    if (!v7_is_regexp(v7, ro)) {
      val_t arg = v7_create_dense_array(v7);
      v7_array_push(v7, arg, ro);
      ro = Regex_ctor(v7, v7_create_null(), arg);
    }
    prog = v7_to_regexp(v7, ro)->compiled_regexp;

    for (; elem < limit && shift < s_len; elem++) {
      val_t tmp_s;
      int i;
      if (slre_exec(prog, 0, s + shift, s_end, &loot)) break;
      if (loot.caps[0].end - loot.caps[0].start == 0) {
        tmp_s = v7_create_string(v7, s + shift, 1, 1);
        shift++;
      } else {
        tmp_s =
            v7_create_string(v7, s + shift, loot.caps[0].start - s - shift, 1);
        shift = loot.caps[0].end - s;
      }
      v7_array_push(v7, res, tmp_s);

      for (i = 1; i < loot.num_captures; i++) {
        v7_array_push(
            v7, res,
            (loot.caps[i].start != NULL)
                ? v7_create_string(v7, loot.caps[i].start,
                                   loot.caps[i].end - loot.caps[i].start, 1)
                : v7_create_undefined());
      }
    }
    len = s_len - shift;
    if (len > 0 && elem < limit) {
      v7_array_push(v7, res, v7_create_string(v7, s + shift, len, 1));
    }
  }

  return res;
}
#endif /* V7_ENABLE__RegExp */

V7_PRIVATE void init_string(struct v7 *v7) {
  val_t str = v7_create_constructor(v7, v7->string_prototype, String_ctor, 1);
  v7_set_property(v7, v7->global_object, "String", 6, V7_PROPERTY_DONT_ENUM,
                  str);

  set_cfunc_prop(v7, str, "fromCharCode", Str_fromCharCode);
  set_cfunc_prop(v7, v7->string_prototype, "charCodeAt", Str_charCodeAt);
  set_cfunc_prop(v7, v7->string_prototype, "charAt", Str_charAt);
  set_cfunc_prop(v7, v7->string_prototype, "concat", Str_concat);
  set_cfunc_prop(v7, v7->string_prototype, "indexOf", Str_indexOf);
  set_cfunc_prop(v7, v7->string_prototype, "substr", Str_substr);
  set_cfunc_prop(v7, v7->string_prototype, "substring", Str_substring);
  set_cfunc_prop(v7, v7->string_prototype, "valueOf", Str_valueOf);
  set_cfunc_prop(v7, v7->string_prototype, "lastIndexOf", Str_lastIndexOf);
#if V7_ENABLE__String__localeCompare
  set_cfunc_prop(v7, v7->string_prototype, "localeCompare", Str_localeCompare);
#endif
#if V7_ENABLE__RegExp
  set_cfunc_prop(v7, v7->string_prototype, "match", Str_match);
  set_cfunc_prop(v7, v7->string_prototype, "replace", Str_replace);
  set_cfunc_prop(v7, v7->string_prototype, "search", Str_search);
  set_cfunc_prop(v7, v7->string_prototype, "split", Str_split);
#endif
  set_cfunc_prop(v7, v7->string_prototype, "slice", Str_slice);
  set_cfunc_prop(v7, v7->string_prototype, "trim", Str_trim);
  set_cfunc_prop(v7, v7->string_prototype, "toLowerCase", Str_toLowerCase);
#if V7_ENABLE__String__localeLowerCase
  set_cfunc_prop(v7, v7->string_prototype, "toLocaleLowerCase",
                 Str_toLowerCase);
#endif
  set_cfunc_prop(v7, v7->string_prototype, "toUpperCase", Str_toUpperCase);
#if V7_ENABLE__String__localeUpperCase
  set_cfunc_prop(v7, v7->string_prototype, "toLocaleUpperCase",
                 Str_toUpperCase);
#endif
  set_cfunc_prop(v7, v7->string_prototype, "toString", Str_toString);

  v7_set_property(v7, v7->string_prototype, "length", 6, V7_PROPERTY_GETTER,
                  v7_create_cfunction(Str_length));

  /* Non-standard Cesanta extension */
  set_cfunc_prop(v7, v7->string_prototype, "at", Str_at);
  v7_set_property(v7, v7->string_prototype, "blen", 4, V7_PROPERTY_GETTER,
                  v7_create_cfunction(Str_blen));
}
/*
 * Copyright (c) 2015 Cesanta Software Limited
 * All rights reserved
 */


#if V7_ENABLE__Date

#include <locale.h>
#include <time.h>

#ifdef __APPLE__
int64_t strtoll(const char *, char **, int);
#elif !defined(_WIN32)
extern long timezone;
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1800
#define tzset _tzset
#endif

typedef double etime_t; /* double is suitable type for ECMA time */
/* inernally we have to use 64-bit integer for some operations */
typedef int64_t etimeint_t;
#define INVALID_TIME NAN

#define msPerDay 86400000
#define HoursPerDay 24
#define MinutesPerHour 60
#define SecondsPerMinute 60
#define SecondsPerHour 3600
#define msPerSecond 1000
#define msPerMinute 60000
#define msPerHour 3600000
#define MonthsInYear 12

/* ECMA alternative to struct tm */
struct timeparts {
  int year;  /* can be negative, up to +-282000 */
  int month; /* 0-11 */
  int day;   /* 1-31 */
  int hour;  /* 0-23 */
  int min;   /* 0-59 */
  int sec;   /* 0-59 */
  int msec;
  int dayofweek; /* 0-6 */
};

static etimeint_t g_gmtoffms; /* timezone offset, ms, no DST */
static const char *g_tzname;  /* current timezone name */

/* Leap year formula copied from ECMA 5.1 standart as is */
static int ecma_DaysInYear(int y) {
  if (y % 4 != 0) {
    return 365;
  } else if (y % 4 == 0 && y % 100 != 0) {
    return 366;
  } else if (y % 100 == 0 && y % 400 != 0) {
    return 365;
  } else if (y % 400 == 0) {
    return 366;
  } else {
    return 365;
  }
}

static etimeint_t ecma_DayFromYear(etimeint_t y) {
  return 365 * (y - 1970) + floor((y - 1969) / 4) - floor((y - 1901) / 100) +
         floor((y - 1601) / 400);
}

static etimeint_t ecma_TimeFromYear(etimeint_t y) {
  return msPerDay * ecma_DayFromYear(y);
}

static int ecma_IsLeapYear(int year) {
  return ecma_DaysInYear(year) == 366;
}

static int *ecma_getfirstdays(int isleap) {
  static int sdays[2][MonthsInYear + 1] = {
      {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
      {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}};

  return sdays[isleap];
}

static int ecma_DaylightSavingTA(etime_t t) {
  time_t time = t / 1000;
  /*
   * Win32 doesn't have locatime_r
   * nixes don't have localtime_s
   * as result using localtime
   */
  struct tm *tm = localtime(&time);
  if (tm == NULL) {
    /* doesn't work on windows for times before epoch */
    return 0;
  }
  if (tm->tm_isdst > 0) {
    return msPerHour;
  } else {
    return 0;
  }
}

static int ecma_LocalTZA() {
  return (int) -g_gmtoffms;
}

static etimeint_t ecma_UTC(etime_t t) {
  return t - ecma_LocalTZA() - ecma_DaylightSavingTA(t - ecma_LocalTZA());
}

#if V7_ENABLE__Date__toString || V7_ENABLE__Date__toLocaleString || \
    V7_ENABLE__Date__toJSON || V7_ENABLE__Date__getters ||          \
    V7_ENABLE__Date__setters
static int ecma_YearFromTime_s(etime_t t) {
  int first = floor((t / msPerDay) / 366) + 1970,
      last = floor((t / msPerDay) / 365) + 1970, middle = 0;

  if (last < first) {
    int temp = first;
    first = last;
    last = temp;
  }

  while (last > first) {
    middle = (last + first) / 2;
    if (ecma_TimeFromYear(middle) > t) {
      last = middle - 1;
    } else {
      if (ecma_TimeFromYear(middle) <= t) {
        if (ecma_TimeFromYear(middle + 1) > t) {
          first = middle;
          break;
        }
        first = middle + 1;
      }
    }
  }

  return first;
}

static etimeint_t ecma_Day(etime_t t) {
  return floor(t / msPerDay);
}

static int ecma_DayWithinYear(etime_t t, int year) {
  return (int) (ecma_Day(t) - ecma_DayFromYear(year));
}

static int ecma_MonthFromTime(etime_t t, int year) {
  int *days, i;
  etimeint_t dwy = ecma_DayWithinYear(t, year);

  days = ecma_getfirstdays(ecma_IsLeapYear(year));

  for (i = 0; i < MonthsInYear; i++) {
    if (dwy >= days[i] && dwy < days[i + 1]) {
      return i;
    }
  }

  return -1;
}

static int ecma_DateFromTime(etime_t t, int year) {
  int *days, mft = ecma_MonthFromTime(t, year),
             dwy = ecma_DayWithinYear(t, year);

  if (mft > 11) {
    return -1;
  }

  days = ecma_getfirstdays(ecma_IsLeapYear(year));

  return dwy - days[mft] + 1;
}

#define DEF_EXTRACT_TIMEPART(funcname, c1, c2) \
  static int ecma_##funcname(etime_t t) {      \
    int ret = (etimeint_t) floor(t / c1) % c2; \
    if (ret < 0) {                             \
      ret += c2;                               \
    }                                          \
    return ret;                                \
  }

DEF_EXTRACT_TIMEPART(HourFromTime, msPerHour, HoursPerDay)
DEF_EXTRACT_TIMEPART(MinFromTime, msPerMinute, MinutesPerHour)
DEF_EXTRACT_TIMEPART(SecFromTime, msPerSecond, SecondsPerMinute)
DEF_EXTRACT_TIMEPART(msFromTime, 1, msPerSecond)

static int ecma_WeekDay(etime_t t) {
  int ret = (ecma_Day(t) + 4) % 7;
  if (ret < 0) {
    ret += 7;
  }

  return ret;
}

static void d_gmtime(const etime_t *t, struct timeparts *tp) {
  tp->year = ecma_YearFromTime_s(*t);
  tp->month = ecma_MonthFromTime(*t, tp->year);
  tp->day = ecma_DateFromTime(*t, tp->year);
  tp->hour = ecma_HourFromTime(*t);
  tp->min = ecma_MinFromTime(*t);
  tp->sec = ecma_SecFromTime(*t);
  tp->msec = ecma_msFromTime(*t);
  tp->dayofweek = ecma_WeekDay(*t);
}
#endif /* V7_ENABLE__Date__toString || V7_ENABLE__Date__toLocaleString || \
          V7_ENABLE__Date__getters || V7_ENABLE__Date__setters */

#if V7_ENABLE__Date__toString || V7_ENABLE__Date__toLocaleString || \
    V7_ENABLE__Date__getters || V7_ENABLE__Date__setters
static etimeint_t ecma_LocalTime(etime_t t) {
  return t + ecma_LocalTZA() + ecma_DaylightSavingTA(t);
}

static void d_localtime(const etime_t *time, struct timeparts *tp) {
  etime_t local_time = ecma_LocalTime(*time);
  d_gmtime(&local_time, tp);
}
#endif

static etimeint_t ecma_MakeTime(etimeint_t hour, etimeint_t min, etimeint_t sec,
                                etimeint_t ms) {
  return ((hour * MinutesPerHour + min) * SecondsPerMinute + sec) *
             msPerSecond +
         ms;
}

static etimeint_t ecma_MakeDay(int year, int month, int date) {
  int *days;
  etimeint_t yday, mday;

  year += floor(month / 12);
  month = month % 12;
  yday = floor(ecma_TimeFromYear(year) / msPerDay);
  days = ecma_getfirstdays(ecma_IsLeapYear(year));
  mday = days[month];

  return yday + mday + date - 1;
}

static etimeint_t ecma_MakeDate(etimeint_t day, etimeint_t time) {
  return (day * msPerDay + time);
}

static void d_gettime(etime_t *t) {
  *t = time(NULL);
}

static etime_t d_mktime_impl(const struct timeparts *tp) {
  return ecma_MakeDate(ecma_MakeDay(tp->year, tp->month, tp->day),
                       ecma_MakeTime(tp->hour, tp->min, tp->sec, tp->msec));
}

#if V7_ENABLE__Date__setters
static etime_t d_lmktime(const struct timeparts *tp) {
  return ecma_UTC(d_mktime_impl(tp));
}
#endif

static etime_t d_gmktime(const struct timeparts *tp) {
  return d_mktime_impl(tp);
}

typedef etime_t (*fmaketime_t)(const struct timeparts *);
typedef void (*fbreaktime_t)(const etime_t *, struct timeparts *);

#if V7_ENABLE__Date__toString || V7_ENABLE__Date__toLocaleString || \
    V7_ENABLE__Date__toJSON
static val_t d_trytogetobjforstring(struct v7 *v7, val_t obj) {
  val_t ret = i_value_of(v7, obj);
  if (ret == V7_TAG_NAN) {
    throw_exception(v7, TYPE_ERROR, "Date is invalid (for string)");
  }
  return ret;
}
#endif

#if V7_ENABLE__Date__parse || V7_ENABLE__Date__UTC
static int d_iscalledasfunction(struct v7 *v7, val_t this_obj) {
  /* TODO(alashkin): verify this statement */
  return is_prototype_of(v7, this_obj, v7->date_prototype);
}
#endif

static const char *mon_name[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                 "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

int d_getnumbyname(const char **arr, int arr_size, const char *str) {
  int i;
  for (i = 0; i < arr_size; i++) {
    if (strncmp(arr[i], str, 3) == 0) {
      return i + 1;
    }
  }

  return -1;
}

int date_parse(const char *str, int *a1, int *a2, int *a3, char sep,
               char *rest) {
  char frmDate[] = " %d/%d/%d%[^\0]";
  frmDate[3] = frmDate[6] = sep;
  return sscanf(str, frmDate, a1, a2, a3, rest);
}

#define NO_TZ 0x7FFFFFFF

/*
 * not very smart but simple, and working according
 * to ECMA5.1 StringToDate function
 */
static int d_parsedatestr(const char *jstr, size_t len, struct timeparts *tp,
                          int *tz) {
  char gmt[4];
  char buf1[100] = {0}, buf2[100] = {0};
  int res = 0;
  char str[101];
  memcpy(str, jstr, len);
  str[len] = '\0';
  memset(tp, 0, sizeof(*tp));
  *tz = NO_TZ;

  /* trying toISOSrting() format */
  {
    const char *frmISOString = " %d-%02d-%02dT%02d:%02d:%02d.%03dZ";
    res = sscanf(str, frmISOString, &tp->year, &tp->month, &tp->day, &tp->hour,
                 &tp->min, &tp->sec, &tp->msec);
    if (res == 7) {
      *tz = 0;
      return 1;
    }
  }

  /* trying toString()/toUTCString()/toDateFormat() formats */
  {
    char month[4];
    int dowlen;
    const char *frmString = " %*s%n %03s %02d %d %02d:%02d:%02d %03s%d";
    res = sscanf(str, frmString, &dowlen, month, &tp->day, &tp->year, &tp->hour,
                 &tp->min, &tp->sec, gmt, tz);
    if ((res == 3 || (res >= 6 && res <= 8)) && dowlen == 3) {
      if ((tp->month = d_getnumbyname(mon_name, ARRAY_SIZE(mon_name), month)) !=
          -1) {
        if (res == 7 && strncmp(gmt, "GMT", 3) == 0) {
          *tz = 0;
        }
        return 1;
      }
    }
  }

  /* trying the rest */

  /* trying date */

  if (!(date_parse(str, &tp->month, &tp->day, &tp->year, '/', buf1) >= 3 ||
        date_parse(str, &tp->day, &tp->month, &tp->year, '.', buf1) >= 3 ||
        date_parse(str, &tp->year, &tp->month, &tp->day, '-', buf1) >= 3)) {
    return 0;
  }

  /*  there is date, trying time; from here return 0 only on errors */

  /* trying HH:mm */
  {
    const char *frmMMhh = " %d:%d%[^\0]";
    res = sscanf(buf1, frmMMhh, &tp->hour, &tp->min, buf2);
    /* can't get time, but have some symbols, assuming error */
    if (res < 2) {
      return (strlen(buf2) == 0);
    }
  }

  /* trying seconds */
  {
    const char *frmss = ":%d%[^\0]";
    memset(buf1, 0, sizeof(buf1));
    res = sscanf(buf2, frmss, &tp->sec, buf1);
  }

  /* even if we don't get seconds we gonna try to get tz */
  {
    char *rest = res ? buf1 : buf2;
    char *buf = res ? buf2 : buf1;
    const char *frmtz = " %03s%d%[^\0]";

    res = sscanf(rest, frmtz, gmt, tz, buf);
    if (res == 1 && strncmp(gmt, "GMT", 3) == 0) {
      *tz = 0;
    }
  }

  /* return OK if we are at the end of string */
  return res <= 2;
}

static int d_timeFromString(etime_t *time, const char *str, size_t str_len) {
  struct timeparts tp;
  int tz;

  *time = INVALID_TIME;

  if (str_len > 100) {
    /* too long for valid date string */
    return 0;
  }

  if (d_parsedatestr(str, str_len, &tp, &tz)) {
    /* check results */
    int valid = 0;

    tp.month--;
    valid = tp.day >= 1 && tp.day <= 31;
    valid &= tp.month >= 0 && tp.month <= 11;
    valid &= tp.hour >= 0 && tp.hour <= 23;
    valid &= tp.min >= 0 && tp.min <= 59;
    valid &= tp.sec >= 0 && tp.sec <= 59;

    if (tz != NO_TZ && tz > 12) {
      tz /= 100;
    }

    valid &= (abs(tz) <= 12 || tz == NO_TZ);

    if (valid) {
      *time = d_gmktime(&tp);

      if (tz != NO_TZ) {
        /* timezone specified, use it */
        *time -= (tz * msPerHour);
      } else if (tz != 0) {
        /* assuming local timezone and moving back to UTC */
        *time = ecma_UTC(*time);
      }
    }
  }

  return !isnan(*time);
}

/* notice: holding month in calendar format (1-12, not 0-11) */
struct dtimepartsarr {
  etime_t args[7];
};

enum detimepartsarr {
  tpyear = 0,
  tpmonth,
  tpdate,
  tphours,
  tpminutes,
  tpseconds,
  tpmsec,
  tpmax
};

static etime_t d_changepartoftime(const etime_t *current,
                                  struct dtimepartsarr *a,
                                  fbreaktime_t breaktimefunc,
                                  fmaketime_t maketimefunc) {
  /*
   * 0 = year, 1 = month , 2 = date , 3 = hours,
   * 4 = minutes, 5 = seconds, 6 = ms
   */
  struct timeparts tp;
  unsigned long i;
  int *tp_arr[7];
  /*
   * C89 doesn't allow initialization
   * like x = {&tp.year, &tp.month, .... }
   */
  tp_arr[0] = &tp.year;
  tp_arr[1] = &tp.month;
  tp_arr[2] = &tp.day;
  tp_arr[3] = &tp.hour;
  tp_arr[4] = &tp.min;
  tp_arr[5] = &tp.sec;
  tp_arr[6] = &tp.msec;

  memset(&tp, 0, sizeof(tp));

  if (breaktimefunc != NULL) {
    breaktimefunc(current, &tp);
  }

  for (i = 0; i < ARRAY_SIZE(tp_arr); i++) {
    if (!isnan(a->args[i]) && !isinf(a->args[i])) {
      *tp_arr[i] = (int) a->args[i];
    }
  }

  return maketimefunc(&tp);
}

#if V7_ENABLE__Date__setters || V7_ENABLE__Date__UTC
static etime_t d_time_number_from_arr(struct v7 *v7, val_t this_obj, val_t args,
                                      int start_pos, fbreaktime_t breaktimefunc,
                                      fmaketime_t makefilefunc) {
  etime_t ret_time = INVALID_TIME;
  long cargs;

  val_t objtime = i_value_of(v7, this_obj);

  if ((cargs = v7_array_length(v7, args)) >= 1 && objtime != V7_TAG_NAN) {
    int i;
    etime_t new_part = INVALID_TIME;
    struct dtimepartsarr a;
    for (i = 0; i < 7; i++) {
      a.args[i] = INVALID_TIME;
    }

    for (i = 0; i < cargs && (i + start_pos < tpmax); i++) {
      new_part = i_as_num(v7, v7_array_get(v7, args, i));
      if (isnan(new_part)) {
        break;
      }

      a.args[i + start_pos] = new_part;
    }

    if (!isnan(new_part)) {
      etime_t current_time = v7_to_number(objtime);
      ret_time =
          d_changepartoftime(&current_time, &a, breaktimefunc, makefilefunc);
    }
  }

  return ret_time;
}
#endif /* V7_ENABLE__Date__setters */

#if V7_ENABLE__Date__toString
static int d_tptostr(const struct timeparts *tp, char *buf, int addtz);
#endif

/* constructor */
static val_t Date_ctor(struct v7 *v7, val_t this_obj, val_t args) {
  etime_t ret_time = INVALID_TIME;
  if (v7_is_object(this_obj) && this_obj != v7->global_object) {
    long cargs = v7_array_length(v7, args);
    if (cargs <= 0) {
      /* no parameters - return current date & time */
      d_gettime(&ret_time);
    } else if (cargs == 1) {
      /* one parameter */
      val_t arg = v7_array_get(v7, args, 0);
      if (v7_is_string(arg)) { /* it could be string */
        size_t str_size;
        const char *str = v7_to_string(v7, &arg, &str_size);
        d_timeFromString(&ret_time, str, str_size);
      }
      if (isnan(ret_time)) {
        /*
         * if cannot be parsed or
         * not string at all - trying to convert to number
         */
        ret_time = i_as_num(v7, arg);
      }
    } else {
      /* 2+ paramaters - should be parts of a date */
      struct dtimepartsarr a;
      int i;

      memset(&a, 0, sizeof(a));

      for (i = 0; i < cargs; i++) {
        a.args[i] = i_as_num(v7, v7_array_get(v7, args, i));
        if (isnan(a.args[i])) {
          break;
        }
      }

      if (i >= cargs) {
        /*
         * If date is supplied then let
         * dt be ToNumber(date); else let dt be 1.
         */
        if (a.args[tpdate] == 0) {
          a.args[tpdate] = 1;
        }

        if (a.args[tpyear] >= 0 && a.args[tpyear] <= 99) {
          /*
           * If y is not NaN and 0 <= ToInteger(y) <= 99,
           * then let yr be 1900+ToInteger(y); otherwise, let yr be y.
           */
          a.args[tpyear] += 1900;
        }

        ret_time = ecma_UTC(d_changepartoftime(0, &a, 0, d_gmktime));
      }
    }

    v7_to_object(this_obj)->prototype = v7_to_object(v7->date_prototype);
    v7_set_property(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN,
                    v7_create_number(ret_time));
    return this_obj;
  } else {
    /*
     * according to 15.9.2.1 we should ignore all
     * parameters in case of function-call
     */
    char buf[50];
    int len;

#if V7_ENABLE__Date__toString
    struct timeparts tp;
    d_gettime(&ret_time);
    d_localtime(&ret_time, &tp);
    len = d_tptostr(&tp, buf, 1);
#else
    len = 0;
#endif /* V7_ENABLE__Date__toString */

    return v7_create_string(v7, buf, len, 1);
  }
}

#if V7_ENABLE__Date__toString || V7_ENABLE__Date__toJSON
static int d_timetoISOstr(const etime_t *time, char *buf, size_t buf_size) {
  /* ISO format: "+XXYYYY-MM-DDTHH:mm:ss.sssZ"; */
  struct timeparts tp;
  char use_ext = 0;
  const char *ey_frm = "%06d-%02d-%02dT%02d:%02d:%02d.%03dZ";
  const char *simpl_frm = "%d-%02d-%02dT%02d:%02d:%02d.%03dZ";

  d_gmtime(time, &tp);

  if (abs(tp.year) > 9999 || tp.year < 0) {
    *buf = (tp.year > 0) ? '+' : '-';
    use_ext = 1;
  }

  return c_snprintf(buf + use_ext, buf_size - use_ext,
                    use_ext ? ey_frm : simpl_frm, abs(tp.year), tp.month + 1,
                    tp.day, tp.hour, tp.min, tp.sec, tp.msec) +
         use_ext;
}

static val_t Date_toISOString(struct v7 *v7, val_t this_obj, val_t args) {
  char buf[30];
  etime_t time;
  int len;
  (void) args;

  time = v7_to_number(d_trytogetobjforstring(v7, this_obj));
  len = d_timetoISOstr(&time, buf, sizeof(buf));

  return v7_create_string(v7, buf, len, 1);
}
#endif /* V7_ENABLE__Date__toString || V7_ENABLE__Date__toJSON */

#if V7_ENABLE__Date__toString
typedef int (*ftostring_t)(const struct timeparts *, char *, int);

static val_t d_tostring(struct v7 *v7, val_t obj, fbreaktime_t breaktimefunc,
                        ftostring_t tostringfunc, int addtz) {
  struct timeparts tp;
  int len;
  char buf[100];
  etime_t time;

  time = v7_to_number(d_trytogetobjforstring(v7, obj));

  breaktimefunc(&time, &tp);
  len = tostringfunc(&tp, buf, addtz);

  return v7_create_string(v7, buf, len, 1);
}

/* using macros to avoid copy-paste technic */
#define DEF_TOSTR(funcname, breaktimefunc, tostrfunc, addtz)                  \
  static val_t Date_to##funcname(struct v7 *v7, val_t this_obj, val_t args) { \
    (void) args;                                                              \
    return d_tostring(v7, this_obj, breaktimefunc, tostrfunc, addtz);         \
  }

/* non-locale function should always return in english and 24h-format */
static const char *wday_name[] = {"Sun", "Mon", "Tue", "Wed",
                                  "Thu", "Fri", "Sat"};

static int d_tptodatestr(const struct timeparts *tp, char *buf, int addtz) {
  (void) addtz;

  return sprintf(buf, "%s %s %02d %d", wday_name[tp->dayofweek],
                 mon_name[tp->month], tp->day, tp->year);
}

DEF_TOSTR(DateString, d_localtime, d_tptodatestr, 1)

static const char *d_gettzname() {
  return g_tzname;
}

static int d_tptotimestr(const struct timeparts *tp, char *buf, int addtz) {
  int len;

  len = sprintf(buf, "%02d:%02d:%02d GMT", tp->hour, tp->min, tp->sec);

  if (addtz && g_gmtoffms != 0) {
    len = sprintf(buf + len, "%c%02d00 (%s)", g_gmtoffms > 0 ? '-' : '+',
                  abs((int) g_gmtoffms / msPerHour), d_gettzname());
  }

  return (int) strlen(buf);
}

DEF_TOSTR(TimeString, d_localtime, d_tptotimestr, 1)

static int d_tptostr(const struct timeparts *tp, char *buf, int addtz) {
  int len = d_tptodatestr(tp, buf, addtz);
  *(buf + len) = ' ';
  return d_tptotimestr(tp, buf + len + 1, addtz) + len + 1;
}

DEF_TOSTR(String, d_localtime, d_tptostr, 1)
DEF_TOSTR(UTCString, d_gmtime, d_tptostr, 0)
#endif /* V7_ENABLE__Date__toString */

#if V7_ENABLE__Date__toLocaleString
struct d_locale {
  char locale[50];
};

static void d_getcurrentlocale(struct d_locale *loc) {
  strcpy(setlocale(LC_TIME, 0), loc->locale);
}

static void d_setlocale(const struct d_locale *loc) {
  setlocale(LC_TIME, loc ? loc->locale : "");
}

/* TODO(alashkin): check portability */
static val_t d_tolocalestr(struct v7 *v7, val_t obj, const char *frm) {
  char buf[250];
  size_t len;
  struct tm t;
  etime_t time;
  struct d_locale prev_locale;
  struct timeparts tp;

  time = v7_to_number(d_trytogetobjforstring(v7, obj));

  d_getcurrentlocale(&prev_locale);
  d_setlocale(0);
  d_localtime(&time, &tp);

  memset(&t, 0, sizeof(t));
  t.tm_year = tp.year - 1900;
  t.tm_mon = tp.month;
  t.tm_mday = tp.day;
  t.tm_hour = tp.hour;
  t.tm_min = tp.min;
  t.tm_sec = tp.sec;
  t.tm_wday = tp.dayofweek;

  len = strftime(buf, sizeof(buf), frm, &t);

  d_setlocale(&prev_locale);

  return v7_create_string(v7, buf, len, 1);
}

#define DEF_TOLOCALESTR(funcname, frm)                                        \
  static val_t Date_to##funcname(struct v7 *v7, val_t this_obj, val_t args) { \
    (void) args;                                                              \
    return d_tolocalestr(v7, this_obj, frm);                                  \
  }

DEF_TOLOCALESTR(LocaleString, "%c")
DEF_TOLOCALESTR(LocaleDateString, "%x")
DEF_TOLOCALESTR(LocaleTimeString, "%X")
#endif /* V7_ENABLE__Date__toLocaleString */

static val_t Date_valueOf(struct v7 *v7, val_t this_obj, val_t args) {
  (void) args;
  if (!v7_is_object(this_obj) ||
      (v7_is_object(this_obj) &&
       v7_to_object(this_obj)->prototype != v7_to_object(v7->date_prototype))) {
    throw_exception(v7, TYPE_ERROR, "Date.valueOf called on non-Date object");
  }

  return Obj_valueOf(v7, this_obj, args);
}

#if V7_ENABLE__Date__getters
static struct timeparts *d_getTimePart(val_t val, struct timeparts *tp,
                                       fbreaktime_t breaktimefunc) {
  etime_t time;
  time = v7_to_number(val);
  breaktimefunc(&time, tp);
  return tp;
}

#define DEF_GET_TP_FUNC(funcName, tpmember, breaktimefunc)                     \
  static val_t Date_get##funcName(struct v7 *v7, val_t this_obj, val_t args) { \
    struct timeparts tp;                                                       \
    val_t v = i_value_of(v7, this_obj);                                        \
    (void) args;                                                               \
    return v7_create_number(                                                   \
        v == V7_TAG_NAN ? NAN                                                  \
                        : d_getTimePart(v, &tp, breaktimefunc)->tpmember);     \
  }

#define DEF_GET_TP(funcName, tpmember)               \
  DEF_GET_TP_FUNC(UTC##funcName, tpmember, d_gmtime) \
  DEF_GET_TP_FUNC(funcName, tpmember, d_localtime)

DEF_GET_TP(Date, day)
DEF_GET_TP(FullYear, year)
DEF_GET_TP(Month, month)
DEF_GET_TP(Hours, hour)
DEF_GET_TP(Minutes, min)
DEF_GET_TP(Seconds, sec)
DEF_GET_TP(Milliseconds, msec)
DEF_GET_TP(Day, dayofweek)

static val_t Date_getTime(struct v7 *v7, val_t this_obj, val_t args) {
  return Date_valueOf(v7, this_obj, args);
}

static val_t Date_getTimezoneOffset(struct v7 *v7, val_t this_obj, val_t args) {
  (void) args;
  (void) v7;
  (void) this_obj;
  return v7_create_number(g_gmtoffms / msPerMinute);
}
#endif /* V7_ENABLE__Date__getters */

#if V7_ENABLE__Date__setters
static val_t d_setTimePart(struct v7 *v7, val_t this_obj, val_t args,
                           int start_pos, fbreaktime_t breaktimefunc,
                           fmaketime_t makefilefunc) {
  val_t n;
  etime_t ret_time = d_time_number_from_arr(v7, this_obj, args, start_pos,
                                            breaktimefunc, makefilefunc);

  n = v7_create_number(ret_time);
  v7_set_property(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN, n);

  return n;
}

#define DEF_SET_TP(name, start_pos)                                           \
  static val_t Date_setUTC##name(struct v7 *v7, val_t this_obj, val_t args) { \
    return d_setTimePart(v7, this_obj, args, start_pos, d_gmtime, d_gmktime); \
  }                                                                           \
  static val_t Date_set##name(struct v7 *v7, val_t this_obj, val_t args) {    \
    return d_setTimePart(v7, this_obj, args, start_pos, d_localtime,          \
                         d_lmktime);                                          \
  }

DEF_SET_TP(Milliseconds, tpmsec)
DEF_SET_TP(Seconds, tpseconds)
DEF_SET_TP(Minutes, tpminutes)
DEF_SET_TP(Hours, tphours)
DEF_SET_TP(Date, tpdate)
DEF_SET_TP(Month, tpmonth)
DEF_SET_TP(FullYear, tpyear)

static val_t Date_setTime(struct v7 *v7, val_t this_obj, val_t args) {
  etime_t ret_time = INVALID_TIME;
  val_t n;
  if (v7_array_length(v7, args) >= 1) {
    ret_time = i_as_num(v7, v7_array_get(v7, args, 0));
  }

  n = v7_create_number(ret_time);
  v7_set_property(v7, this_obj, "", 0, V7_PROPERTY_HIDDEN, n);
  return n;
}
#endif /* V7_ENABLE__Date__setters */

#if V7_ENABLE__Date__toJSON
static val_t Date_toJSON(struct v7 *v7, val_t this_obj, val_t args) {
  return Date_toISOString(v7, this_obj, args);
}
#endif /* V7_ENABLE__Date__toJSON */

#if V7_ENABLE__Date__now
static val_t Date_now(struct v7 *v7, val_t this_obj, val_t args) {
  etime_t ret_time;
  (void) args;
  (void) v7;
  (void) this_obj;

  d_gettime(&ret_time);

  return v7_create_number(ret_time);
}
#endif /* V7_ENABLE__Date__now */

#if V7_ENABLE__Date__parse
static val_t Date_parse(struct v7 *v7, val_t this_obj, val_t args) {
  etime_t ret_time = INVALID_TIME;
  (void) args;

  if (!d_iscalledasfunction(v7, this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Date.parse() called on object");
  }

  if (v7_array_length(v7, args) >= 1) {
    val_t arg0 = v7_array_get(v7, args, 0);
    if (v7_is_string(arg0)) {
      size_t size;
      const char *time_str = v7_to_string(v7, &arg0, &size);

      d_timeFromString(&ret_time, time_str, size);
    }
  }

  return v7_create_number(ret_time);
}
#endif /* V7_ENABLE__Date__parse */

#if V7_ENABLE__Date__UTC
static val_t Date_UTC(struct v7 *v7, val_t this_obj, val_t args) {
  etime_t ret_time;
  (void) args;

  if (!d_iscalledasfunction(v7, this_obj)) {
    throw_exception(v7, TYPE_ERROR, "Date.now() called on object");
  }

  ret_time = d_time_number_from_arr(v7, this_obj, args, tpyear, 0, d_gmktime);
  return v7_create_number(ret_time);
}
#endif /* V7_ENABLE__Date__UTC */

/****** Initialization *******/

/*
 * We should set V7_PROPERTY_DONT_ENUM for all Date props
 * TODO(mkm): check other objects
*/
static int d_set_cfunc_prop(struct v7 *v7, val_t o, const char *name,
                            v7_cfunction_t f) {
  return v7_set_property(v7, o, name, strlen(name), V7_PROPERTY_DONT_ENUM,
                         v7_create_cfunction(f));
}

#define DECLARE_GET(func)                                                      \
  d_set_cfunc_prop(v7, v7->date_prototype, "getUTC" #func, Date_getUTC##func); \
  d_set_cfunc_prop(v7, v7->date_prototype, "get" #func, Date_get##func);

#define DECLARE_SET(func)                                                      \
  d_set_cfunc_prop(v7, v7->date_prototype, "setUTC" #func, Date_setUTC##func); \
  d_set_cfunc_prop(v7, v7->date_prototype, "set" #func, Date_set##func);

V7_PRIVATE void init_date(struct v7 *v7) {
  val_t date = v7_create_constructor(v7, v7->date_prototype, Date_ctor, 7);
  v7_set_property(v7, v7->global_object, "Date", 4, V7_PROPERTY_DONT_ENUM,
                  date);
  d_set_cfunc_prop(v7, v7->date_prototype, "valueOf", Date_valueOf);

#if V7_ENABLE__Date__getters
  DECLARE_GET(Date);
  DECLARE_GET(FullYear);
  DECLARE_GET(Month);
  DECLARE_GET(Hours);
  DECLARE_GET(Minutes);
  DECLARE_GET(Seconds);
  DECLARE_GET(Milliseconds);
  DECLARE_GET(Day);
  d_set_cfunc_prop(v7, v7->date_prototype, "getTime", Date_getTime);
#endif

#if V7_ENABLE__Date__setters
  DECLARE_SET(Date);
  DECLARE_SET(FullYear);
  DECLARE_SET(Month);
  DECLARE_SET(Hours);
  DECLARE_SET(Minutes);
  DECLARE_SET(Seconds);
  DECLARE_SET(Milliseconds);
  d_set_cfunc_prop(v7, v7->date_prototype, "setTime", Date_setTime);
  d_set_cfunc_prop(v7, v7->date_prototype, "getTimezoneOffset",
                   Date_getTimezoneOffset);
#endif

#if V7_ENABLE__Date__now
  d_set_cfunc_prop(v7, date, "now", Date_now);
#endif
#if V7_ENABLE__Date__parse
  d_set_cfunc_prop(v7, date, "parse", Date_parse);
#endif
#if V7_ENABLE__Date__UTC
  d_set_cfunc_prop(v7, date, "UTC", Date_UTC);
#endif

#if V7_ENABLE__Date__toString
  d_set_cfunc_prop(v7, v7->date_prototype, "toString", Date_toString);
  d_set_cfunc_prop(v7, v7->date_prototype, "toISOString", Date_toISOString);
  d_set_cfunc_prop(v7, v7->date_prototype, "toUTCString", Date_toUTCString);
  d_set_cfunc_prop(v7, v7->date_prototype, "toDateString", Date_toDateString);
  d_set_cfunc_prop(v7, v7->date_prototype, "toTimeString", Date_toTimeString);
#endif
#if V7_ENABLE__Date__toLocaleString
  d_set_cfunc_prop(v7, v7->date_prototype, "toLocaleString",
                   Date_toLocaleString);
  d_set_cfunc_prop(v7, v7->date_prototype, "toLocaleDateString",
                   Date_toLocaleDateString);
  d_set_cfunc_prop(v7, v7->date_prototype, "toLocaleTimeString",
                   Date_toLocaleTimeString);
#endif
#if V7_ENABLE__Date__toJSON
  d_set_cfunc_prop(v7, v7->date_prototype, "toJSON", Date_toJSON);
#endif

  /*
   * GTM offset without DST
   * TODO(alashkin): check this
   * Could be changed to tm::tm_gmtoff,
   * but tm_gmtoff includes DST, so
   * side effects are possible
   */
  tzset();
  g_gmtoffms = timezone * msPerSecond;
  /*
   * tzname could be changed by localtime_r call,
   * so we have to store pointer
   * TODO(alashkin): need restart on tz change???
   */
  g_tzname = tzname[0];
}

#endif /* V7_ENABLE__Date */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


static val_t Function_ctor(struct v7 *v7, val_t this_obj, val_t args) {
  long i, num_args = v7_array_length(v7, args);
  size_t size;
  const char *s;
  struct mbuf m;
  val_t tmp;
  enum v7_err ret;

  (void) this_obj;

  if (num_args <= 0) return v7_create_undefined();

  mbuf_init(&m, 0);
  mbuf_append(&m, "(function(", 10);

  for (i = 0; i < num_args - 1; i++) {
    tmp = i_value_of(v7, v7_array_get(v7, args, i));
    if (v7_is_string(tmp)) {
      if (i > 0) mbuf_append(&m, ",", 1);
      s = v7_to_string(v7, &tmp, &size);
      mbuf_append(&m, s, size);
    }
  }
  mbuf_append(&m, "){", 2);
  tmp = i_value_of(v7, v7_array_get(v7, args, num_args - 1));
  if (v7_is_string(tmp)) {
    s = v7_to_string(v7, &tmp, &size);
    mbuf_append(&m, s, size);
  }
  mbuf_append(&m, "})\0", 3);

  ret = v7_exec(v7, &tmp, m.buf);
  mbuf_free(&m);
  if (ret != V7_OK) {
    throw_exception(v7, SYNTAX_ERROR, "Invalid function body");
  }
  return tmp;
}

static val_t Function_length(struct v7 *v7, val_t this_obj, val_t args) {
  struct v7_function *func = v7_to_function(this_obj);
  ast_off_t body, pos = func->ast_off;
  struct ast *a = func->ast;
  int argn = 0;

  if (!v7_is_function(i_value_of(v7, this_obj))) return 0;

  (void) args;

  V7_CHECK(v7, ast_fetch_tag(a, &pos) == AST_FUNC);
  body = ast_get_skip(a, pos, AST_FUNC_BODY_SKIP);

  ast_move_to_children(a, &pos);
  if (ast_fetch_tag(a, &pos) == AST_IDENT) {
    ast_move_to_children(a, &pos);
  }
  while (pos < body) {
    V7_CHECK(v7, ast_fetch_tag(a, &pos) == AST_IDENT);
    ast_move_to_children(a, &pos);
    argn++;
  }

  return v7_create_number(argn);
}

static val_t Function_apply(struct v7 *v7, val_t this_obj, val_t args) {
  val_t f = i_value_of(v7, this_obj);
  val_t this_arg = v7_array_get(v7, args, 0);
  val_t func_args = v7_array_get(v7, args, 1);
  return v7_apply(v7, f, this_arg, func_args);
}

V7_PRIVATE void init_function(struct v7 *v7) {
  val_t ctor = v7_create_function(v7, Function_ctor, 1);
  v7_set_property(v7, ctor, "prototype", 9, 0, v7->function_prototype);
  v7_set_property(v7, v7->global_object, "Function", 8, 0, ctor);
  set_method(v7, v7->function_prototype, "apply", Function_apply, 1);
  v7_set_property(v7, v7->function_prototype, "length", 6, V7_PROPERTY_GETTER,
                  v7_create_cfunction(Function_length));
}
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#if V7_ENABLE__RegExp

V7_PRIVATE val_t to_string(struct v7 *, val_t);

V7_PRIVATE val_t Regex_ctor(struct v7 *v7, val_t this_obj, val_t args) {
  long argnum = v7_array_length(v7, args);
  if (argnum > 0) {
    val_t ro = to_string(v7, v7_array_get(v7, args, 0));
    size_t re_len, flags_len = 0;
    const char *re, *flags = NULL;

    (void) this_obj;
    if (argnum > 1) {
      val_t fl = to_string(v7, v7_array_get(v7, args, 1));
      flags = v7_to_string(v7, &fl, &flags_len);
    }
    re = v7_to_string(v7, &ro, &re_len);
    return v7_create_regexp(v7, re, re_len, flags, flags_len);
  }
  return v7_create_regexp(v7, "(?:)", 4, NULL, 0);
}

static val_t Regex_global(struct v7 *v7, val_t this_obj, val_t args) {
  int flags = 0;
  val_t r = i_value_of(v7, this_obj);

  (void) args;
  if (v7_is_regexp(v7, r))
    flags = slre_get_flags(v7_to_regexp(v7, r)->compiled_regexp);

  return v7_create_boolean(flags & SLRE_FLAG_G);
}

static val_t Regex_ignoreCase(struct v7 *v7, val_t this_obj, val_t args) {
  int flags = 0;
  val_t r = i_value_of(v7, this_obj);

  (void) args;
  if (v7_is_regexp(v7, r))
    flags = slre_get_flags(v7_to_regexp(v7, r)->compiled_regexp);

  return v7_create_boolean(flags & SLRE_FLAG_I);
}

static val_t Regex_multiline(struct v7 *v7, val_t this_obj, val_t args) {
  int flags = 0;
  val_t r = i_value_of(v7, this_obj);

  (void) args;
  if (v7_is_regexp(v7, r))
    flags = slre_get_flags(v7_to_regexp(v7, r)->compiled_regexp);

  return v7_create_boolean(flags & SLRE_FLAG_M);
}

static val_t Regex_source(struct v7 *v7, val_t this_obj, val_t args) {
  val_t r = i_value_of(v7, this_obj);
  const char *buf = 0;
  size_t len = 0;

  (void) args;
  if (v7_is_regexp(v7, r))
    buf = v7_to_string(v7, &v7_to_regexp(v7, r)->regexp_string, &len);

  return v7_create_string(v7, buf, len, 1);
}

static val_t Regex_get_lastIndex(struct v7 *v7, val_t this_obj, val_t args) {
  long lastIndex = 0;

  (void) v7;
  (void) args;
  if (v7_is_regexp(v7, this_obj))
    lastIndex = v7_to_regexp(v7, this_obj)->lastIndex;

  return v7_create_number(lastIndex);
}

static val_t Regex_set_lastIndex(struct v7 *v7, val_t this_obj, val_t args) {
  long lastIndex = 0;

  if (v7_is_regexp(v7, this_obj))
    v7_to_regexp(v7, this_obj)->lastIndex = lastIndex =
        arg_long(v7, args, 0, 0);

  return v7_create_number(lastIndex);
}

V7_PRIVATE val_t rx_exec(struct v7 *v7, val_t rx, val_t str, int lind) {
  if (v7_is_regexp(v7, rx)) {
    val_t s = to_string(v7, str);
    size_t len;
    struct slre_loot sub;
    struct slre_cap *ptok = sub.caps;
    char *const str = (char *) v7_to_string(v7, &s, &len);
    const char *const end = str + len;
    const char *begin = str;
    struct v7_regexp *rp = v7_to_regexp(v7, rx);
    int flag_g = slre_get_flags(rp->compiled_regexp) & SLRE_FLAG_G;
    if (rp->lastIndex < 0) rp->lastIndex = 0;
    if (flag_g || lind) begin = utfnshift(str, rp->lastIndex);

    if (!slre_exec(rp->compiled_regexp, 0, begin, end, &sub)) {
      int i;
      val_t arr = v7_create_array(v7);
      char *old_mbuf_base = v7->owned_strings.buf;
      ptrdiff_t rel = 0; /* creating strings might relocate the mbuf */

      for (i = 0; i < sub.num_captures; i++, ptok++) {
        rel = v7->owned_strings.buf - old_mbuf_base;
        v7_array_push(v7, arr, v7_create_string(v7, ptok->start + rel,
                                                ptok->end - ptok->start, 1));
      }
      if (flag_g) rp->lastIndex = utfnlen(str, sub.caps->end + rel - str);
      v7_set_property(
          v7, arr, "index", 5, V7_PROPERTY_READ_ONLY,
          v7_create_number(utfnlen(str + rel, sub.caps->start - str)));
      return arr;
    } else
      rp->lastIndex = 0;
  }
  return v7_create_null();
}

static val_t Regex_exec(struct v7 *v7, val_t this_obj, val_t args) {
  if (v7_array_length(v7, args) > 0) {
    return rx_exec(v7, this_obj, v7_array_get(v7, args, 0), 0);
  }
  return v7_create_null();
}

static val_t Regex_test(struct v7 *v7, val_t this_obj, val_t args) {
  return v7_create_boolean(!v7_is_null(Regex_exec(v7, this_obj, args)));
}

V7_PRIVATE void init_regex(struct v7 *v7) {
  val_t ctor = v7_create_constructor(v7, v7->regexp_prototype, Regex_ctor, 1);
  val_t lastIndex = v7_create_dense_array(v7);

  v7_set_property(v7, v7->global_object, "RegExp", 6, V7_PROPERTY_DONT_ENUM,
                  ctor);

  set_cfunc_prop(v7, v7->regexp_prototype, "exec", Regex_exec);
  set_cfunc_prop(v7, v7->regexp_prototype, "test", Regex_test);

  v7_set_property(v7, v7->regexp_prototype, "global", 6, V7_PROPERTY_GETTER,
                  v7_create_cfunction(Regex_global));
  v7_set_property(v7, v7->regexp_prototype, "ignoreCase", 10,
                  V7_PROPERTY_GETTER, v7_create_cfunction(Regex_ignoreCase));
  v7_set_property(v7, v7->regexp_prototype, "multiline", 9, V7_PROPERTY_GETTER,
                  v7_create_cfunction(Regex_multiline));
  v7_set_property(v7, v7->regexp_prototype, "source", 6, V7_PROPERTY_GETTER,
                  v7_create_cfunction(Regex_source));

  v7_array_set(v7, lastIndex, 0, v7_create_cfunction(Regex_get_lastIndex));
  v7_array_set(v7, lastIndex, 1, v7_create_cfunction(Regex_set_lastIndex));
  v7_set_property(v7, v7->regexp_prototype, "lastIndex", 9,
                  V7_PROPERTY_GETTER | V7_PROPERTY_SETTER, lastIndex);
}

#endif /* V7_ENABLE__RegExp */
/*
 * Copyright (c) 2014 Cesanta Software Limited
 * All rights reserved
 */


#if defined(_MSC_VER) && _MSC_VER >= 1800
#define fileno _fileno
#endif

#ifdef V7_EXE
#define V7_MAIN
#endif

#ifdef V7_MAIN

#include <sys/stat.h>

static void show_usage(char *argv[]) {
  fprintf(stderr, "V7 version %s (c) Cesanta Software, built on %s\n",
          V7_VERSION, __DATE__);
  fprintf(stderr, "Usage: %s [OPTIONS] js_file ...\n", argv[0]);
  fprintf(stderr, "%s\n", "OPTIONS:");
  fprintf(stderr, "%s\n", "  -e <expr>  execute expression");
  fprintf(stderr, "%s\n", "  -t         dump generated text AST");
  fprintf(stderr, "%s\n", "  -b         dump generated binary AST");
  fprintf(stderr, "%s\n", "  -mm        dump memory stats");
  fprintf(stderr, "%s\n", "  -vo <n>    object arena size");
  fprintf(stderr, "%s\n", "  -vf <n>    function arena size");
  fprintf(stderr, "%s\n", "  -vp <n>    property arena size");
  exit(EXIT_FAILURE);
}

static char *read_file(const char *path, size_t *size) {
  FILE *fp;
  struct stat st;
  char *data = NULL;
  if ((fp = fopen(path, "rb")) != NULL && !fstat(fileno(fp), &st)) {
    *size = st.st_size;
    data = (char *) malloc(*size + 1);
    if (data != NULL) {
      if (fread(data, 1, *size, fp) != *size) {
        free(data);
        return NULL;
      }
      data[*size] = '\0';
    }
    fclose(fp);
  }
  return data;
}

static void print_error(struct v7 *v7, const char *f, val_t e) {
  char buf[512];
  char *s = v7_to_json(v7, e, buf, sizeof(buf));
  fprintf(stderr, "Exec error [%s]: %s\n", f, s);
  if (s != buf) {
    free(s);
  }
}

#if V7_ENABLE__Memory__stats
static void dump_mm_arena_stats(const char *msg, struct gc_arena *a) {
  printf("%s: total allocations %lu, total garbage %lu, max %lu, alive %lu\n",
         msg, a->allocations, a->garbage, gc_arena_size(a), a->alive);
  printf(
      "%s: (bytes: total allocations %lu, total garbage %lu, max %lu, alive "
      "%lu)\n",
      msg, a->allocations * a->cell_size, a->garbage * a->cell_size,
      gc_arena_size(a) * a->cell_size, a->alive * a->cell_size);
}

static void dump_mm_stats(struct v7 *v7) {
  dump_mm_arena_stats("object: ", &v7->object_arena);
  dump_mm_arena_stats("function: ", &v7->function_arena);
  dump_mm_arena_stats("property: ", &v7->property_arena);
  printf("string arena len: %lu\n", v7->owned_strings.len);
  printf("Total heap size: %lu\n",
         v7->owned_strings.len +
             gc_arena_size(&v7->object_arena) * v7->object_arena.cell_size +
             gc_arena_size(&v7->function_arena) * v7->function_arena.cell_size +
             gc_arena_size(&v7->property_arena) * v7->property_arena.cell_size);
}
#endif

/*
 * V7 executable main function.
 * `init_func()` is an optional intialization function, aimed to export any
 * extra functionality into vanilla v7 engine.
 */
int v7_main(int argc, char *argv[], void (*init_func)(struct v7 *)) {
  struct v7 *v7;
  struct v7_create_opts opts = {0, 0, 0};
  int i, j, show_ast = 0, binary_ast = 0, dump_stats = 0;
  val_t res = v7_create_undefined();
  const char *exprs[16];
  int nexprs = 0;

  /* Execute inline code */
  for (i = 1; i < argc && argv[i][0] == '-'; i++) {
    if (strcmp(argv[i], "-e") == 0 && i + 1 < argc) {
      exprs[nexprs++] = argv[i + 1];
      i++;
    } else if (strcmp(argv[i], "-t") == 0) {
      show_ast = 1;
    } else if (strcmp(argv[i], "-b") == 0) {
      show_ast = 1;
      binary_ast = 1;
    } else if (strcmp(argv[i], "-h") == 0) {
      show_usage(argv);
#if V7_ENABLE__Memory__stats
    } else if (strcmp(argv[i], "-mm") == 0) {
      dump_stats = 1;
#endif
    } else if (strcmp(argv[i], "-vo") == 0 && i + 1 < argc) {
      opts.object_arena_size = atoi(argv[i + 1]);
      i++;
    } else if (strcmp(argv[i], "-vf") == 0 && i + 1 < argc) {
      opts.function_arena_size = atoi(argv[i + 1]);
      i++;
    } else if (strcmp(argv[i], "-vp") == 0 && i + 1 < argc) {
      opts.property_arena_size = atoi(argv[i + 1]);
      i++;
    }
  }

  if (argc == 1) {
    show_usage(argv);
  }

  v7 = v7_create_opt(opts);

  if (init_func != NULL) {
    init_func(v7);
  }

#if V7_ENABLE__Memory__stats > 0 && !defined(V7_DISABLE_GC)
  if (dump_stats) {
    printf("Memory stats during init:\n");
    dump_mm_stats(v7);
    v7_gc(v7, 0);
    printf("Memory stats before run:\n");
    dump_mm_stats(v7);
  }
#else
  (void) dump_stats;
#endif

  /* Execute inline expressions */
  for (j = 0; j < nexprs; j++) {
    if (show_ast) {
      v7_compile(exprs[j], binary_ast, stdout);
    } else if (v7_exec(v7, &res, exprs[j]) != V7_OK) {
      print_error(v7, exprs[j], res);
      res = v7_create_undefined();
    }
  }

  /* Execute files */
  for (; i < argc; i++) {
    if (show_ast) {
      size_t size;
      char *source_code;
      if ((source_code = read_file(argv[i], &size)) == NULL) {
        fprintf(stderr, "Cannot read [%s]\n", argv[i]);
      } else {
        v7_compile(source_code, binary_ast, stdout);
        free(source_code);
      }
    } else if (v7_exec_file(v7, &res, argv[i]) != V7_OK) {
      print_error(v7, argv[i], res);
      res = v7_create_undefined();
    }
  }

  if (!show_ast) {
    char buf[2000];
    char *s = v7_to_json(v7, res, buf, sizeof(buf));
    printf("%s\n", s);
    if (s != buf) {
      free(s);
    }
  }

#if V7_ENABLE__Memory__stats
  if (dump_stats) {
    printf("Memory stats after run:\n");
    dump_mm_stats(v7);
  }
#else
  (void) dump_stats;
#endif

  v7_destroy(v7);
  return EXIT_SUCCESS;
}
#endif

#ifdef V7_EXE
int main(int argc, char *argv[]) {
  return v7_main(argc, argv, NULL);
}
#endif
